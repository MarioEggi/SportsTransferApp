/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer

/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/1. Hauptdateien
//
//  AppDelegate.swift

import UIKit
import Firebase
import FirebaseMessaging
import FirebaseAuth
import UserNotifications

class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        FirebaseApp.configure()

        // Push-Benachrichtigungen konfigurieren
        UNUserNotificationCenter.current().delegate = self
        Messaging.messaging().delegate = self

        // Berechtigung für Push-Benachrichtigungen anfragen
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if let error = error {
                print("Fehler bei der Berechtigungsanfrage für Push-Benachrichtigungen: \(error.localizedDescription)")
            } else {
                print("Push-Benachrichtigungen erlaubt: \(granted)")
            }
        }
        application.registerForRemoteNotifications()

        return true
    }

    // FCM-Token empfangen und in Firestore speichern
    func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
        guard let fcmToken = fcmToken else { return }
        print("FCM-Token: \(fcmToken)")

        guard let userID = Auth.auth().currentUser?.uid else { return }
        let db = Firestore.firestore()
        db.collection("users").document(userID).setData(["fcmToken": fcmToken], merge: true) { error in
            if let error = error {
                print("Fehler beim Speichern des FCM-Tokens: \(error.localizedDescription)")
            } else {
                print("FCM-Token erfolgreich gespeichert für Benutzer \(userID)")
            }
        }
    }

    // Push-Benachrichtigung empfangen (im Vordergrund)
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        let userInfo = notification.request.content.userInfo
        print("Push-Benachrichtigung empfangen (im Vordergrund): \(userInfo)")
        completionHandler([.alert, .sound, .badge])
    }

    // Push-Benachrichtigung angeklickt
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        let userInfo = response.notification.request.content.userInfo
        print("Push-Benachrichtigung angeklickt: \(userInfo)")
        // Hier könnten wir z. B. zur Detailansicht eines Transferprozesses navigieren
        completionHandler()
    }

    // APNs-Token empfangen
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        Messaging.messaging().apnsToken = deviceToken
        print("APNs-Token empfangen: \(deviceToken.map { String(format: "%02.2hhx", $0) }.joined())")
    }

    // Fehler bei der Registrierung für Push-Benachrichtigungen
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("Fehler bei der Registrierung für Push-Benachrichtigungen: \(error.localizedDescription)")
    }
}



//
//  AuthManager.swift

import FirebaseAuth
import FirebaseFirestore
import Foundation

enum UserRole: String, Codable {
    case mitarbeiter = "Mitarbeiter"
    case klient = "Klient"
    case gast = "Gast"
}

class AuthManager: ObservableObject {
    @Published var isLoggedIn = false
    @Published var userRole: UserRole?
    @Published var userEmail: String?
    @Published var userID: String?
    @Published var errorMessage: String?
    private var authHandle: AuthStateDidChangeListenerHandle?

    var currentUser: User? {
        return Auth.auth().currentUser
    }

    init() {
        authHandle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            guard let self = self else { return }
            if let user = user {
                self.isLoggedIn = true
                self.userEmail = user.email
                self.userID = user.uid
                print("Benutzer angemeldet: \(user.uid), E-Mail: \(user.email ?? "Keine")")
                Task {
                    await self.loadUserRole(user.uid)
                }
            } else {
                self.isLoggedIn = false
                self.userRole = nil
                self.userEmail = nil
                self.userID = nil
                print("Kein Benutzer angemeldet")
            }
        }
    }

    func loadUserRole(_ uid: String) async {
        do {
            let snapshot = try await Firestore.firestore().collection("users").document(uid).getDocument()
            let data = snapshot.data()
            print("Firestore-Daten für UID \(uid): \(String(describing: data))")
            if let roleString = data?["rolle"] as? String, let role = UserRole(rawValue: roleString) {
                await MainActor.run {
                    self.userRole = role
                    print("Rolle gesetzt: \(role.rawValue)")
                }
            } else {
                await MainActor.run {
                    self.userRole = .gast
                    print("Keine gültige Rolle gefunden, auf Gast zurückgefallen")
                }
            }
        } catch {
            print("Fehler beim Laden der Rolle: \(error.localizedDescription)")
            await MainActor.run {
                self.userRole = .gast
                self.errorMessage = "Fehler beim Laden der Rolle: \(error.localizedDescription)"
            }
        }
    }

    func login(email: String, password: String, completion: @escaping (Result<Void, Error>) -> Void) {
        Auth.auth().signIn(withEmail: email, password: password) { [weak self] result, error in
            guard let self = self else { return }
            if let error = error {
                completion(.failure(error))
            } else if let user = result?.user {
                self.userEmail = user.email
                self.userID = user.uid
                self.isLoggedIn = true
                Task {
                    await self.loadUserRole(user.uid)
                }
                completion(.success(()))
            }
        }
    }

    func signOut() {
        do {
            try Auth.auth().signOut()
            DispatchQueue.main.async {
                self.isLoggedIn = false
                self.userRole = nil
                self.userEmail = nil
                self.userID = nil
            }
        } catch {
            print("Logout fehlgeschlagen: \(error.localizedDescription)")
            self.errorMessage = "Logout fehlgeschlagen: \(error.localizedDescription)"
        }
    }

    func register(email: String, password: String, role: UserRole, completion: @escaping (Result<Void, Error>) -> Void) {
        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            guard let self = self else { return }
            if let error = error {
                completion(.failure(error))
                return
            }
            guard let user = result?.user else {
                completion(.failure(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Benutzer konnte nicht erstellt werden"])))
                return
            }

            let db = Firestore.firestore()
            db.collection("users").document(user.uid).setData([
                "email": email,
                "rolle": role.rawValue
            ]) { error in
                if let error = error {
                    completion(.failure(error))
                } else {
                    self.userEmail = email
                    self.userID = user.uid
                    self.userRole = role
                    self.isLoggedIn = true
                    completion(.success(()))
                }
            }
        }
    }

    func createClientLogin(email: String, password: String, clientID: String, userID: String, completion: @escaping (Result<Void, Error>) -> Void) {
        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            guard let self = self else { return }
            if let error = error {
                completion(.failure(error))
                return
            }
            guard let user = result?.user else {
                completion(.failure(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Benutzer konnte nicht erstellt werden"])))
                return
            }

            let db = Firestore.firestore()
            db.collection("users").document(userID).setData([
                "email": email,
                "rolle": UserRole.klient.rawValue,
                "clientID": clientID
            ]) { error in
                if let error = error {
                    completion(.failure(error))
                    return
                }

                db.collection("clients").document(clientID).updateData([
                    "userID": userID
                ]) { error in
                    if let error = error {
                        completion(.failure(error))
                    } else {
                        completion(.success(()))
                    }
                }
            }
        }
    }

    func autoLogin() {
        let defaultEmail = "eggimann@t-online.de"
        let defaultPassword = "test123"
        login(email: defaultEmail, password: defaultPassword) { result in
            switch result {
            case .success:
                print("Automatischer Login erfolgreich für \(defaultEmail)")
            case .failure(let error):
                print("Automatischer Login fehlgeschlagen: \(error.localizedDescription)")
                self.errorMessage = "Autologin fehlgeschlagen: \(error.localizedDescription)"
            }
        }
    }

    func updateEmail(newEmail: String, completion: @escaping (Result<Void, Error>) -> Void) {
        guard let user = Auth.auth().currentUser else {
            completion(.failure(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Kein Benutzer angemeldet"])))
            return
        }
        user.updateEmail(to: newEmail) { [weak self] error in
            if let error = error {
                self?.errorMessage = "E-Mail-Änderung fehlgeschlagen: \(error.localizedDescription)"
                completion(.failure(error))
            } else {
                self?.userEmail = newEmail
                self?.updateEmailInFirestore(newEmail: newEmail)
                completion(.success(()))
            }
        }
    }

    func updatePassword(newPassword: String, completion: @escaping (Result<Void, Error>) -> Void) {
        guard let user = Auth.auth().currentUser else {
            completion(.failure(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Kein Benutzer angemeldet"])))
            return
        }
        user.updatePassword(to: newPassword) { [weak self] error in
            if let error = error {
                self?.errorMessage = "Passwort-Änderung fehlgeschlagen: \(error.localizedDescription)"
                completion(.failure(error))
            } else {
                completion(.success(()))
            }
        }
    }

    private func updateEmailInFirestore(newEmail: String) {
        guard let userID = userID else { return }
        let db = Firestore.firestore()
        db.collection("users").document(userID).updateData(["email": newEmail]) { error in
            if let error = error {
                print("Fehler beim Aktualisieren der E-Mail in Firestore: \(error.localizedDescription)")
            }
        }
    }

    deinit {
        if let handle = authHandle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}



//
//  LoginView.swift

import SwiftUI
import FirebaseAuth

struct LoginView: View {
    @EnvironmentObject var authManager: AuthManager
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var errorMessage: String = ""
    @State private var showingRegisterSheet = false

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                Text("Anmelden")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.white) // Weiße Schrift

                TextField("E-Mail", text: $email)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .autocapitalization(.none)
                    .keyboardType(.emailAddress)
                    .foregroundColor(.white) // Weiße Schrift
                    .background(Color.gray.opacity(0.2)) // Dunklerer Hintergrund
                    .cornerRadius(8)

                SecureField("Passwort", text: $password)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .autocapitalization(.none)
                    .foregroundColor(.white) // Weiße Schrift
                    .background(Color.gray.opacity(0.2)) // Dunklerer Hintergrund
                    .cornerRadius(8)

                Button(action: { login() }) {
                    Text("Anmelden")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white) // Weiße Schrift
                        .cornerRadius(10)
                }

                Button(action: { showingRegisterSheet = true }) {
                    Text("Registrieren")
                        .foregroundColor(.white) // Weiße Schrift
                }

                if !errorMessage.isEmpty {
                    Text(errorMessage)
                        .foregroundColor(.red)
                        .padding()
                }

                Spacer()
            }
            .padding()
            .background(Color.black) // Schwarzer Hintergrund für die gesamte View
            .navigationTitle("Login")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .sheet(isPresented: $showingRegisterSheet) {
                RegisterView()
            }
        }
    }

    private func login() {
        authManager.login(email: email, password: password) { result in
            switch result {
            case .success:
                errorMessage = ""
            case .failure(let error):
                errorMessage = "Anmeldung fehlgeschlagen: \(error.localizedDescription)"
            }
        }
    }
}

struct RegisterView: View {
    @EnvironmentObject var authManager: AuthManager
    @Environment(\.dismiss) var dismiss
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var role: UserRole = .gast
    @State private var errorMessage: String = ""

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Registrierung").foregroundColor(.white)) {
                    TextField("E-Mail", text: $email)
                        .autocapitalization(.none)
                        .keyboardType(.emailAddress)
                        .foregroundColor(.white) // Weiße Schrift
                    SecureField("Passwort", text: $password)
                        .autocapitalization(.none)
                        .foregroundColor(.white) // Weiße Schrift
                    Picker("Rolle", selection: $role) {
                        Text("Mitarbeiter").tag(UserRole.mitarbeiter)
                        Text("Klient").tag(UserRole.klient)
                        Text("Gast").tag(UserRole.gast)
                    }
                    .pickerStyle(MenuPickerStyle())
                    .foregroundColor(.white) // Weiße Schrift
                    .accentColor(.white) // Weiße Akzente
                }

                if !errorMessage.isEmpty {
                    Text(errorMessage)
                        .foregroundColor(.red)
                }
            }
            .scrollContentBackground(.hidden) // Standard-Hintergrund der Form ausblenden
            .background(Color.black) // Schwarzer Hintergrund für die Form
            .navigationTitle("Registrieren")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { dismiss() }
                        .foregroundColor(.white) // Weiße Schrift
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Registrieren") {
                        authManager.register(email: email, password: password, role: role) { result in
                            switch result {
                            case .success:
                                dismiss()
                            case .failure(let error):
                                errorMessage = "Registrierung fehlgeschlagen: \(error.localizedDescription)"
                            }
                        }
                    }
                    .foregroundColor(.white) // Weiße Schrift
                }
            }
        }
    }
}

#Preview {
    LoginView()
        .environmentObject(AuthManager())
}



//
//  SportsTransferApp.swift

import SwiftUI
import FirebaseCore
import FirebaseFirestore

@main
struct SportsTransferApp: App {
    @StateObject private var authManager = AuthManager()
    @StateObject private var transferProcessViewModel: TransferProcessViewModel
    @State private var hasAttemptedAutoLogin = false
    @State private var isLoadingRole = true

    init() {
        FirebaseApp.configure()
        _transferProcessViewModel = StateObject(wrappedValue: TransferProcessViewModel(authManager: AuthManager()))
        
        // Einmalige Migration
        Task {
            do {
                try await FirestoreManager.shared.migrateTransferProcesses()
                print("Migration abgeschlossen")
            } catch {
                print("Fehler bei der Migration: \(error)")
            }
        }
    }

    var body: some Scene {
        WindowGroup {
            if !hasAttemptedAutoLogin {
                ProgressView("Initialisiere...")
                    .task {
                        authManager.autoLogin()
                        await MainActor.run {
                            hasAttemptedAutoLogin = true
                        }
                    }
            } else if authManager.isLoggedIn && !isLoadingRole {
                switch authManager.userRole {
                case .mitarbeiter:
                    EmployeeView()
                        .environmentObject(authManager)
                        .environmentObject(transferProcessViewModel)
                        .onAppear {
                            print("EmployeeView - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                            updateClientsWithUserID()
                        }
                case .klient:
                    ClientHomeView()
                        .environmentObject(authManager)
                        .environmentObject(transferProcessViewModel)
                        .onAppear {
                            print("ClientHomeView - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                            updateClientsWithUserID()
                        }
                case .gast:
                    HomeView()
                        .environmentObject(authManager)
                        .environmentObject(transferProcessViewModel)
                        .onAppear {
                            print("HomeView (Gast) - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                        }
                case .none:
                    HomeView()
                        .environmentObject(authManager)
                        .environmentObject(transferProcessViewModel)
                        .onAppear {
                            print("HomeView (Fallback) - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                        }
                default:
                    HomeView()
                        .environmentObject(authManager)
                        .environmentObject(transferProcessViewModel)
                        .onAppear {
                            print("HomeView (Default) - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                        }
                }
            } else if !authManager.isLoggedIn {
                LoginView()
                    .environmentObject(authManager)
                    .environmentObject(transferProcessViewModel)
                    .onAppear {
                        print("LoginView - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                    }
            } else {
                ProgressView("Lade Benutzerrolle...")
                    .task {
                        if authManager.userID != nil && authManager.userRole == nil {
                            await authManager.loadUserRole(authManager.userID!)
                        }
                        while authManager.userRole == nil && authManager.isLoggedIn {
                            try? await Task.sleep(nanoseconds: 100_000_000)
                        }
                        await MainActor.run {
                            isLoadingRole = false
                        }
                    }
            }
        }
    }

    private func updateClientsWithUserID() {
        guard let userID = authManager.userID else { return }
        Task {
            do {
                try await FirestoreManager.shared.updateClientsWithUserID(userID: userID)
            } catch {
                print("Fehler beim Aktualisieren der userID für Klienten: \(error)")
            }
        }
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/2. Datenmodelle
//
//  Constants.swift

import SwiftUI

struct Constants {
    static let nationalities = ["Deutschland", "Schweiz", "Österreich", "Frankreich", "Italien", "Spanien"]
    static let positionOptions = ["Stürmer", "Mittelfeld", "Verteidiger", "Torwart"]
    static let strongFootOptions = ["Rechts", "Links", "Beidfüßig"]
    static let functionaryPositionOptions = ["Trainer", "Manager", "Sportdirektor"]
    static let leaguesMale = ["Bundesliga", "2. Bundesliga", "Premier League"]
    static let leaguesFemale = ["Frauen-Bundesliga", "2. Frauen-Bundesliga"]
    static let sponsorCategories = ["Sportartikelhersteller", "Finanzdienstleister", "Lebensmittel", "Technologie", "Andere"]
    static let activityCategories = ["Besprechung", "Training", "Spiel", "Verhandlung", "Sonstiges"]
    static let contactTypes = ["Telefon", "E-Mail", "Besuch", "Teams-Meeting"] // Hinzugefügt
    static let contactTopics = ["Besuch", "Vertragsverhandlung", "Feedback", "Trainingsplan"] // Hinzugefügt

    enum SortOption: String, CaseIterable {
        case nameAscending = "Name aufsteigend"
        case nameDescending = "Name absteigend"
        case birthDateAscending = "Geburtsdatum aufsteigend"
        case birthDateDescending = "Geburtsdatum absteigend"
    }

    enum ContactFilterType: String, CaseIterable, Identifiable {
        case all = "Alle"
        case clients = "Klienten"
        case funktionäre = "Funktionäre"
        var id: String { self.rawValue }
    }

    enum GroupByOption: String, CaseIterable, Identifiable {
        case none = "Keine"
        case club = "Verein"
        case type = "Typ"
        var id: String { self.rawValue }
    }
}



//
//  Extensions.swift

import SwiftUI
import UniformTypeIdentifiers
import UIKit

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

extension View {
    func customPlaceholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}

extension Array where Element: Hashable {
    func uniqued() -> [Element] {
        Array(Set(self))
    }
}

// DocumentPicker als Erweiterung
struct DocumentPicker: UIViewControllerRepresentable {
    let allowedContentTypes: [UTType]
    let onPick: (URL) -> Void

    func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
        let picker = UIDocumentPickerViewController(forOpeningContentTypes: allowedContentTypes, asCopy: true)
        picker.delegate = context.coordinator
        return picker
    }

    func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(onPick: onPick)
    }

    class Coordinator: NSObject, UIDocumentPickerDelegate {
        let onPick: (URL) -> Void

        init(onPick: @escaping (URL) -> Void) {
            self.onPick = onPick
        }

        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            if let url = urls.first {
                onPick(url)
            }
        }

        func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {}
    }
}



//
//  FirestoreManager.swift

import Foundation
import FirebaseFirestore
import FirebaseAuth
import FirebaseStorage

class FirestoreManager {
    static let shared = FirestoreManager()
    private let db = Firestore.firestore()

    private init() {}

    func getAllClients(lastDocument: DocumentSnapshot? = nil, limit: Int) async throws -> ([Client], QueryDocumentSnapshot?) {
        var query = db.collection("clients")
            .order(by: "name")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let clients = snapshot.documents.compactMap { doc -> Client? in
            do {
                var client = try doc.data(as: Client.self)
                client.id = doc.documentID
                return client
            } catch {
                print("Fehler beim Dekodieren des Klienten \(doc.documentID): \(error)")
                return nil
            }
        }
        let lastDocument = snapshot.documents.last
        return (clients, lastDocument)
    }

    func getClients(forUserID userID: String, lastDocument: DocumentSnapshot? = nil, limit: Int) async throws -> ([Client], QueryDocumentSnapshot?) {
        var query = db.collection("clients")
            .whereField("userID", isEqualTo: userID)
            .order(by: "name")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let clients = snapshot.documents.compactMap { doc -> Client? in
            do {
                var client = try doc.data(as: Client.self)
                client.id = doc.documentID
                return client
            } catch {
                print("Fehler beim Dekodieren des Klienten \(doc.documentID): \(error)")
                return nil
            }
        }
        let lastDocument = snapshot.documents.last
        return (clients, lastDocument)
    }

    func getClients(lastDocument: DocumentSnapshot? = nil, limit: Int) async throws -> ([Client], QueryDocumentSnapshot?) {
        guard let userID = Auth.auth().currentUser?.uid else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Benutzer-ID nicht verfügbar"])
        }
        return try await getClients(forUserID: userID, lastDocument: lastDocument, limit: limit)
    }

    func createClient(client: Client) async throws -> String {
        do {
            let data = try Firestore.Encoder().encode(client)
            print("FirestoreManager - Client zum Erstellen: \(client)")
            print("FirestoreManager - Encodierte Daten: \(data)")
            let ref = try await db.collection("clients").addDocument(data: data)
            print("FirestoreManager - Client erfolgreich in Firestore erstellt mit ID: \(ref.documentID)")
            return ref.documentID
        } catch {
            print("FirestoreManager - Fehler beim Erstellen des Klienten: \(error)")
            throw error
        }
    }

    func updateClient(client: Client) async throws {
        guard let id = client.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Client-ID nicht vorhanden"])
        }
        do {
            let data = try Firestore.Encoder().encode(client)
            print("FirestoreManager - Client zum Aktualisieren: \(client)")
            print("FirestoreManager - Encodierte Daten: \(data)")
            try await db.collection("clients").document(id).setData(data, merge: true)
            print("FirestoreManager - Client erfolgreich in Firestore aktualisiert")
        } catch {
            print("FirestoreManager - Fehler beim Aktualisieren des Klienten: \(error)")
            throw error
        }
    }

    func deleteClient(clientID: String) async throws {
        try await db.collection("clients").document(clientID).delete()
    }

    func getFunktionäre(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Funktionär], QueryDocumentSnapshot?) {
        var query = db.collection("funktionare")
            .order(by: "name")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let funktionäre = snapshot.documents.compactMap { doc -> Funktionär? in
            do {
                var funktionär = try doc.data(as: Funktionär.self)
                funktionär.id = doc.documentID
                return funktionär
            } catch {
                print("Fehler beim Dekodieren des Funktionärs \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (funktionäre, newLastDocument)
    }

    func createFunktionär(funktionär: Funktionär) async throws -> String {
        let ref = db.collection("funktionare").document()
        try await ref.setData(from: funktionär)
        return ref.documentID
    }

    func updateFunktionär(funktionär: Funktionär) async throws {
        guard let id = funktionär.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Funktionär-ID nicht vorhanden"])
        }
        try await db.collection("funktionare").document(id).setData(from: funktionär)
    }

    func deleteFunktionär(funktionärID: String) async throws {
        try await db.collection("funktionare").document(funktionärID).delete()
    }

    func getClubs(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Club], QueryDocumentSnapshot?) {
        var query = db.collection("clubs")
            .order(by: "name")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let clubs = snapshot.documents.compactMap { doc -> Club? in
            do {
                var club = try doc.data(as: Club.self)
                club.id = doc.documentID
                return club
            } catch {
                print("Fehler beim Dekodieren des Clubs \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (clubs, newLastDocument)
    }

    func createClub(club: Club) async throws {
        let data = try Firestore.Encoder().encode(club)
        try await db.collection("clubs").addDocument(data: data)
    }

    func updateClub(club: Club) async throws {
        guard let id = club.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Club-ID nicht vorhanden"])
        }
        try await db.collection("clubs").document(id).setData(from: club)
    }

    func deleteClub(clubID: String) async throws {
        try await db.collection("clubs").document(clubID).delete()
    }

    func getContracts(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Contract], QueryDocumentSnapshot?) {
        var query = db.collection("contracts")
            .order(by: "endDatum")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let contracts = snapshot.documents.compactMap { doc -> Contract? in
            do {
                var contract = try doc.data(as: Contract.self)
                contract.id = doc.documentID
                return contract
            } catch {
                print("Fehler beim Dekodieren des Vertrags \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (contracts, newLastDocument)
    }

    func createContract(contract: Contract) async throws {
        let data = try Firestore.Encoder().encode(contract)
        try await db.collection("contracts").addDocument(data: data)
    }

    func updateContract(contract: Contract) async throws {
        guard let id = contract.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Contract-ID nicht vorhanden"])
        }
        try await db.collection("contracts").document(id).setData(from: contract)
    }

    func deleteContract(contractID: String) async throws {
        try await db.collection("contracts").document(contractID).delete()
    }

    func getMatches(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Match], QueryDocumentSnapshot?) {
        var query = db.collection("matches")
            .order(by: "datum")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let matches = snapshot.documents.compactMap { doc -> Match? in
            do {
                var match = try doc.data(as: Match.self)
                match.id = doc.documentID
                return match
            } catch {
                print("Fehler beim Dekodieren des Spiels \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (matches, newLastDocument)
    }

    func createMatch(match: Match) async throws {
        let data = try Firestore.Encoder().encode(match)
        try await db.collection("matches").addDocument(data: data)
    }

    func updateMatch(match: Match) async throws {
        guard let id = match.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Match-ID nicht vorhanden"])
        }
        try await db.collection("matches").document(id).setData(from: match)
    }

    func deleteMatch(matchID: String) async throws {
        try await db.collection("matches").document(matchID).delete()
    }

    func getSponsors(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Sponsor], QueryDocumentSnapshot?) {
        var query = db.collection("sponsors")
            .order(by: "name")
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let sponsors = snapshot.documents.compactMap { doc -> Sponsor? in
            do {
                var sponsor = try doc.data(as: Sponsor.self)
                sponsor.id = doc.documentID
                return sponsor
            } catch {
                print("Fehler beim Dekodieren des Sponsors \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (sponsors, newLastDocument)
    }

    func createSponsor(sponsor: Sponsor) async throws {
        let data = try Firestore.Encoder().encode(sponsor)
        try await db.collection("sponsors").addDocument(data: data)
    }

    func updateSponsor(sponsor: Sponsor) async throws {
        guard let id = sponsor.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Sponsor-ID nicht vorhanden"])
        }
        try await db.collection("sponsors").document(id).setData(from: sponsor)
    }

    func deleteSponsor(sponsorID: String) async throws {
        try await db.collection("sponsors").document(sponsorID).delete()
    }

    func getActivities(lastDocument: DocumentSnapshot?, limit: Int) async throws -> ([Activity], QueryDocumentSnapshot?) {
        var query = db.collection("activities")
            .order(by: "timestamp", descending: true)
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let activities = snapshot.documents.compactMap { doc -> Activity? in
            do {
                var activity = try doc.data(as: Activity.self)
                activity.id = doc.documentID
                return activity
            } catch {
                print("Fehler beim Dekodieren der Aktivität \(doc.documentID): \(error)")
                return nil
            }
        }
        let newLastDocument = snapshot.documents.last
        return (activities, newLastDocument)
    }

    func getActivities(forClientID clientID: String, limit: Int = 1000) async throws -> [Activity] {
        let snapshot = try await db.collection("activities")
            .whereField("clientID", isEqualTo: clientID)
            .order(by: "timestamp", descending: true)
            .limit(to: limit)
            .getDocuments()
        return snapshot.documents.compactMap { doc -> Activity? in
            do {
                var activity = try doc.data(as: Activity.self)
                activity.id = doc.documentID
                return activity
            } catch {
                print("Fehler beim Dekodieren der Aktivität \(doc.documentID): \(error)")
                return nil
            }
        }
    }

    func createActivity(activity: Activity) async throws {
        let data = try Firestore.Encoder().encode(activity)
        try await db.collection("activities").addDocument(data: data)
    }

    func updateActivity(activity: Activity) async throws {
        guard let id = activity.id else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Activity-ID nicht vorhanden"])
        }
        try await db.collection("activities").document(id).setData(from: activity)
    }

    func deleteActivity(activityID: String) async throws {
        try await db.collection("activities").document(activityID).delete()
    }

    func uploadImage(documentID: String, image: UIImage, collection: String) async throws -> String {
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Fehler beim Konvertieren des Bildes"])
        }
        let storageRef = Storage.storage().reference().child("\(collection)/\(documentID).jpg")
        let metadata = StorageMetadata()
        metadata.contentType = "image/jpeg"
        let _ = try await storageRef.putDataAsync(imageData, metadata: metadata)
        let url = try await storageRef.downloadURL()
        return url.absoluteString
    }

    func getChats(forUserID userID: String) async throws -> [Chat] {
        print("Fetching chats for userID: \(userID)")
        let snapshot = try await db.collection("chats")
            .whereField("participantIDs", arrayContains: userID)
            .order(by: "lastMessageTimestamp", descending: true)
            .getDocuments()
        print("Fetched \(snapshot.documents.count) chat documents")
        let chats = snapshot.documents.compactMap { doc -> Chat? in
            do {
                var chat = try doc.data(as: Chat.self)
                chat.id = doc.documentID
                print("Decoded chat: \(chat)")
                return chat
            } catch {
                print("Fehler beim Dekodieren des Chats \(doc.documentID): \(error)")
                return nil
            }
        }
        print("Returning \(chats.count) chats")
        return chats
    }

    func createChat(participantIDs: [String], initialMessage: ChatMessage? = nil) async throws -> String {
        let chat = Chat(
            id: nil,
            participantIDs: participantIDs,
            lastMessage: initialMessage?.content,
            lastMessageTimestamp: initialMessage?.timestamp ?? Date()
        )
        let ref = db.collection("chats").document()
        try await ref.setData(from: chat)
        
        // Wenn eine initiale Nachricht angegeben ist, speichere sie
        if let message = initialMessage {
            try await ref.collection("messages").document(message.id ?? UUID().uuidString).setData(from: message)
        }
        
        return ref.documentID
    }

    func getMessages(forChatID chatID: String, limit: Int = 50) async throws -> [ChatMessage] {
        print("Fetching messages for chatID: \(chatID)")
        let snapshot = try await db.collection("chats").document(chatID)
            .collection("messages")
            .order(by: "timestamp", descending: true)
            .limit(to: limit)
            .getDocuments()
        print("Fetched \(snapshot.documents.count) message documents")
        let messages = snapshot.documents.compactMap { doc -> ChatMessage? in
            do {
                let message = try doc.data(as: ChatMessage.self)
                print("Decoded message: \(message)")
                return message
            } catch {
                print("Fehler beim Dekodieren der Nachricht \(doc.documentID): \(error)")
                return nil
            }
        }
        return messages
    }

    func sendMessage(_ message: ChatMessage, inChatID chatID: String) async throws {
        let data = try Firestore.Encoder().encode(message)
        try await db.collection("chats").document(chatID)
            .collection("messages")
            .document(message.id ?? UUID().uuidString) // Verwende die message.id
            .setData(data)
        try await db.collection("chats").document(chatID).updateData([
            "lastMessage": message.content ?? "",
            "lastMessageTimestamp": message.timestamp
        ])
    }

    func updateClientsWithUserID(userID: String) async throws {
        let snapshot = try await db.collection("clients")
            .whereField("userID", isEqualTo: NSNull())
            .getDocuments()
        let batch = db.batch()
        for document in snapshot.documents {
            let ref = db.collection("clients").document(document.documentID)
            batch.updateData(["userID": userID], forDocument: ref)
        }
        try await batch.commit()
    }

    func createTransferProcess(transferProcess: TransferProcess) async throws -> String {
        let ref = db.collection("transferProcesses").document()
        try await ref.setData(from: transferProcess)
        return ref.documentID
    }

    func getTransferProcesses(lastDocument: DocumentSnapshot? = nil, limit: Int) async throws -> ([TransferProcess], DocumentSnapshot?) {
        var query = db.collection("transferProcesses")
            .order(by: "startDatum", descending: true)
            .limit(to: limit)
        if let lastDoc = lastDocument {
            query = query.start(afterDocument: lastDoc)
        }
        let snapshot = try await query.getDocuments()
        let transferProcesses = snapshot.documents.compactMap { doc -> TransferProcess? in
            do {
                var process = try doc.data(as: TransferProcess.self)
                process.id = doc.documentID
                return process
            } catch {
                print("Fehler beim Dekodieren des Transferprozesses \(doc.documentID): \(error)")
                return nil
            }
        }
        let lastDoc = snapshot.documents.last
        return (transferProcesses, lastDoc)
    }

    func updateTransferProcess(transferProcess: TransferProcess) async throws {
        guard let id = transferProcess.id else { throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Keine ID vorhanden"]) }
        try await db.collection("transferProcesses").document(id).setData(from: transferProcess, merge: true)
    }

    func deleteTransferProcess(id: String) async throws {
        try await db.collection("transferProcesses").document(id).delete()
    }

    func uploadFile(documentID: String, data: Data, collection: String, fileName: String) async throws -> String {
        let storageRef = Storage.storage().reference().child("\(collection)/\(fileName)")
        let metadata = StorageMetadata()
        metadata.contentType = "application/octet-stream"
        let _ = try await storageRef.putDataAsync(data, metadata: metadata)
        let url = try await storageRef.downloadURL()
        return url.absoluteString
    }

    func migrateTransferProcesses() async throws {
        let snapshot = try await db.collection("transferProcesses").getDocuments()
        for doc in snapshot.documents {
            var process = try doc.data(as: TransferProcess.self)
            
            // Lade Client und Club für den Titel
            let clientSnapshot = try await db.collection("clients").document(process.clientID).getDocument()
            let client = try clientSnapshot.data(as: Client.self)
            let clubSnapshot = try await db.collection("clubs").document(process.vereinID).getDocument()
            let club = try clubSnapshot.data(as: Club.self)
            
            // Setze Titel und sponsorID
            let updatedData: [String: Any] = [
                "title": "\(client.vorname ?? "Unbekannt") -> \(club.name ?? "Unbekannt")",
                "sponsorID": NSNull()  // Setze auf null, da noch keine Sponsoren zugeordnet sind
            ]
            try await doc.reference.updateData(updatedData)
        }
    }
    
    // Gewichtungen für Kriterien (kann in Firestore angepasst werden)
    struct MatchingWeights: Codable {
        var position: Double
        var liga: Double
        var gehalt: Double
        var abteilung: Double
        var nationalitaet: Double
        var spielstil: Double
        var groesse: Double
        var tempo: Double
        var zweikampfstärke: Double
        var einsGegenEins: Double
    }

    func getMatchingWeights() async throws -> MatchingWeights {
        let doc = try await Firestore.firestore().collection("settings").document("matching_weights").getDocument()
        if let data = doc.data() {
            return MatchingWeights(
                position: data["position"] as? Double ?? 20.0,
                liga: data["liga"] as? Double ?? 15.0,
                gehalt: data["gehalt"] as? Double ?? 10.0,
                abteilung: data["abteilung"] as? Double ?? 10.0,
                nationalitaet: data["nationalitaet"] as? Double ?? 5.0,
                spielstil: data["spielstil"] as? Double ?? 15.0,
                groesse: data["groesse"] as? Double ?? 5.0,
                tempo: data["tempo"] as? Double ?? 10.0,
                zweikampfstärke: data["zweikampfstärke"] as? Double ?? 10.0,
                einsGegenEins: data["einsGegenEins"] as? Double ?? 10.0
            )
        }
        return MatchingWeights(
            position: 20.0, liga: 15.0, gehalt: 10.0, abteilung: 10.0, nationalitaet: 5.0,
            spielstil: 15.0, groesse: 5.0, tempo: 10.0, zweikampfstärke: 10.0, einsGegenEins: 10.0
        )
    }

    func calculateMatchScore(client: Client, club: Club, weights: MatchingWeights) -> Double {
        var score: Double = 0.0

        // Position
        if let clientPosition = client.positionFeld?.first,
           let clubPosition = club.mensDepartment?.clients?.contains(where: { $0 == clientPosition }) ?? false {
            score += weights.position
        }

        // Liga
        if let clientLiga = client.liga, let clubLiga = club.mensDepartment?.league, clientLiga == clubLiga {
            score += weights.liga
        }

        // Gehalt (angenommen, der Verein hat ein Budget von 100.000)
        if let clientGehalt = client.gehalt, clientGehalt <= 100000 {
            score += weights.gehalt
        }

        // Abteilung
        if let clientAbteilung = client.abteilung, clientAbteilung == club.abteilungForGender(client.geschlecht) {
            score += weights.abteilung
        }

        // Nationalität
        if let clientNationalitaet = client.nationalitaet, let clubLand = club.sharedInfo?.land,
           clientNationalitaet.contains(clubLand) {
            score += weights.nationalitaet
        }

        // Spielstil
        if let clientSpielstil = client.spielstil, clientSpielstil == "offensiv" { // Beispiel: Verein sucht offensiv
            score += weights.spielstil
        }

        // Größe (angenommen, Verein hat keine Präferenz)
        if client.groesse != nil {
            score += weights.groesse * 0.5 // Geringere Gewichtung, da nicht wichtig
        }

        // Tempo
        if let clientTempo = client.tempo, clientTempo >= 70 { // Beispiel: Verein sucht Tempo >= 70
            score += weights.tempo
        }

        // Zweikampfstärke
        if let clientZweikampfstärke = client.zweikampfstärke, clientZweikampfstärke >= 80 { // Beispiel: Verein sucht zweikampfstark
            score += weights.zweikampfstärke
        }

        // 1v1
        if let clientEinsGegenEins = client.einsGegenEins, clientEinsGegenEins >= 70 {
            score += weights.einsGegenEins
        }

        return min(score, 100.0) // Begrenze auf 100
    }

    func generateMatches() async throws -> [Match] {
        let weights = try await getMatchingWeights()
        let (clients, _) = try await getAllClients(lastDocument: nil, limit: 1000)
        let (clubs, _) = try await getClubs(lastDocument: nil, limit: 1000)
        var matches: [Match] = []

        for client in clients {
            for club in clubs {
                let score = calculateMatchScore(client: client, club: club, weights: weights)
                if score > 50.0 { // Nur Matches mit einem Score über 50%
                    let match = Match(
                        clientID: client.id ?? "",
                        vereinID: club.id ?? "",
                        matchScore: score,
                        status: "pending",
                        createdAt: Date()
                    )
                    matches.append(match)
                    // Speichere Match in Firestore
                    try await Firestore.firestore().collection("matches").document(match.id).setData(from: match)
                    // Benachrichtigung für Mitarbeiter
                    try await sendMatchNotification(match: match)
                }
            }
        }

        return matches.sorted { $0.matchScore > $1.matchScore }
    }

    func sendMatchNotification(match: Match) async throws {
        let notification = Notification(
            id: UUID().uuidString,
            userID: "all_mitarbeiter", // Beispiel: Benachrichtigung an alle Mitarbeiter
            title: "Neues Match gefunden",
            message: "Ein neues Match zwischen Klient \(match.clientID) und Verein \(match.vereinID) wurde gefunden (Score: \(match.matchScore))",
            timestamp: Date(),
            isRead: false
        )
        try await Firestore.firestore().collection("notifications").document(notification.id).setData(from: notification)
    }

    func saveMatchFeedback(feedback: MatchFeedback) async throws {
        try await Firestore.firestore().collection("match_feedback").document(feedback.id).setData(from: feedback)
        
        // Aktualisiere den Match-Status
        try await Firestore.firestore().collection("matches").document(feedback.matchID).updateData([
            "status": feedback.status
        ])
        
        // Algorithmus verbessern (einfaches Beispiel: Gewichtungen anpassen)
        if feedback.status == "rejected", let reason = feedback.reason {
            let weightsRef = Firestore.firestore().collection("settings").document("matching_weights")
            // Beispiel: Wenn der Grund "falsche Position" ist, reduzieren wir das Gewicht für Position
            if reason.contains("Position") {
                try await weightsRef.updateData(["position": FieldValue.increment(-1.0)])
            }
            // Weitere Logik für andere Gründe...
        }
    }
    func awardPoints(to userID: String, points: Int) async throws {
        let userRef = Firestore.firestore().collection("users").document(userID)
        try await userRef.updateData([
            "points": FieldValue.increment(Int64(points))
        ])
    }

    func awardBadge(to userID: String, badge: String) async throws {
        let userRef = Firestore.firestore().collection("users").document(userID)
        try await userRef.updateData([
            "badges": FieldValue.arrayUnion([badge])
        ])
    }

    func updateChallengeProgress(userID: String, challengeType: String, increment: Int) async throws {
        let userRef = Firestore.firestore().collection("users").document(userID)
        let snapshot = try await userRef.getDocument()
        guard var user = try snapshot.data(as: User.self) else { return }
        
        var challenges = user.challenges ?? []
        if let index = challenges.firstIndex(where: { $0.type == challengeType && !$0.completed }) {
            challenges[index].progress += increment
            if challenges[index].progress >= challenges[index].goal {
                challenges[index].completed = true
                try await awardPoints(to: userID, points: challenges[index].points)
                // Benachrichtigung für abgeschlossene Herausforderung
                let notification = Notification(
                    id: UUID().uuidString,
                    userID: userID,
                    title: "Herausforderung abgeschlossen",
                    message: "Du hast die Herausforderung '\(challenges[index].title)' abgeschlossen und \(challenges[index].points) Punkte erhalten!",
                    timestamp: Date(),
                    isRead: false
                )
                try await Firestore.firestore().collection("notifications").document(notification.id).setData(from: notification)
            }
        }
        try await userRef.updateData(["challenges": challenges.map { try! Firestore.Encoder().encode($0) }])
    }

    // Beispiel: Punkte für das Senden einer E-Mail
    func generateEmail(for process: TransferProcess, step: Step, language: String = "Deutsch") async throws -> String {
        let emailContent = """
        Betreff: \(step.typ) für \(process.clientID) - \(process.vereinID)
        Sehr geehrte Damen und Herren,
        ...
        """
        // Punkte vergeben
        if let userID = process.mitarbeiterID {
            try await awardPoints(to: userID, points: 10) // 10 Punkte für erste E-Mail
            try await updateChallengeProgress(userID: userID, challengeType: "send_emails", increment: 1)
            // Abzeichen "first_email"
            let snapshot = try await Firestore.firestore().collection("users").document(userID).getDocument()
            if let user = try snapshot.data(as: User.self), !(user.badges?.contains("first_email") ?? false) {
                try await awardBadge(to: userID, badge: "first_email")
            }
        }
        return emailContent
    }
    
    func initializeUserChallenges(userID: String) async throws {
        let challenges = [
            Challenge(
                title: "Versende 3 E-Mails an Vereine",
                description: "Versende 3 E-Mails, um 50 Punkte zu erhalten.",
                points: 50,
                progress: 0,
                goal: 3,
                type: "send_emails",
                completed: false
            ),
            Challenge(
                title: "Aquiriere 1 Klienten der Kategorie 2",
                description: "Aquiriere einen Klienten der Kategorie 2, um 100 Punkte zu erhalten.",
                points: 100,
                progress: 0,
                goal: 1,
                type: "acquire_client",
                completed: false
            )
        ]
        try await Firestore.firestore().collection("users").document(userID).updateData([
            "challenges": challenges.map { try! Firestore.Encoder().encode($0) }
        ])
    }
}



//
//  Models.swift

import Foundation
import FirebaseFirestore

struct Client: Identifiable, Codable, Equatable, Hashable {
    @DocumentID var id: String?
    var typ: String
    var name: String
    var vorname: String
    var geschlecht: String
    var abteilung: String? // "Männer" oder "Frauen"
    var vereinID: String?
    var nationalitaet: [String]?
    var geburtsdatum: Date?
    var alter: Int?
    var kontaktTelefon: String?
    var kontaktEmail: String?
    var adresse: String?
    var liga: String?
    var vertragBis: Date?
    var vertragsOptionen: String?
    var gehalt: Double?
    var schuhgroesse: Int?
    var schuhmarke: String?
    var starkerFuss: String?
    var groesse: Int?
    var gewicht: Int?
    var positionFeld: [String]?
    var sprachen: [String]?
    var lizenz: String?
    var nationalmannschaft: String?
    var profilbildURL: String?
    var transfermarktID: String?
    var userID: String?
    var createdBy: String?
    // Neue Felder aus Feedback
    var konditionen: String? // Gehalt und Vertragsdetails
    var art: String? // z. B. "Vereinswechsel", "Vertragsverlängerung"
    var spielerCV: String? // URL zu Spieler-CV
    var video: String? // URL zu Video
    var spielstil: String? // "offensiv" oder "defensiv"
    var tempo: Int? // 0-100 (Geschwindigkeit)
    var zweikampfstärke: Int? // 0-100
    var einsGegenEins: Int?

    // Expliziter Initialisierer
    init(
        id: String? = nil,
        typ: String,
        name: String,
        vorname: String,
        geschlecht: String,
        abteilung: String? = nil,
        vereinID: String? = nil,
        nationalitaet: [String]? = nil,
        geburtsdatum: Date? = nil,
        alter: Int? = nil,
        kontaktTelefon: String? = nil,
        kontaktEmail: String? = nil,
        adresse: String? = nil,
        liga: String? = nil,
        vertragBis: Date? = nil,
        vertragsOptionen: String? = nil,
        gehalt: Double? = nil,
        schuhgroesse: Int? = nil,
        schuhmarke: String? = nil,
        starkerFuss: String? = nil,
        groesse: Int? = nil,
        gewicht: Int? = nil,
        positionFeld: [String]? = nil,
        sprachen: [String]? = nil,
        lizenz: String? = nil,
        nationalmannschaft: String? = nil,
        profilbildURL: String? = nil,
        transfermarktID: String? = nil,
        userID: String? = nil,
        createdBy: String? = nil,
        konditionen: String? = nil,
        art: String? = nil,
        spielerCV: String? = nil,
        video: String? = nil,
        spielstil: String? = nil,
        tempo: Int? = nil,
        zweikampfstärke: Int? = nil,
        einsGegenEins: Int? = nil
    ) {
        self.id = id
        self.typ = typ
        self.name = name
        self.vorname = vorname
        self.geschlecht = geschlecht
        self.abteilung = abteilung
        self.vereinID = vereinID
        self.nationalitaet = nationalitaet
        self.geburtsdatum = geburtsdatum
        self.alter = alter
        self.kontaktTelefon = kontaktTelefon
        self.kontaktEmail = kontaktEmail
        self.adresse = adresse
        self.liga = liga
        self.vertragBis = vertragBis
        self.vertragsOptionen = vertragsOptionen
        self.gehalt = gehalt
        self.schuhgroesse = schuhgroesse
        self.schuhmarke = schuhmarke
        self.starkerFuss = starkerFuss
        self.groesse = groesse
        self.gewicht = gewicht
        self.positionFeld = positionFeld
        self.sprachen = sprachen
        self.lizenz = lizenz
        self.nationalmannschaft = nationalmannschaft
        self.profilbildURL = profilbildURL
        self.transfermarktID = transfermarktID
        self.userID = userID
        self.createdBy = createdBy
        self.konditionen = konditionen
        self.art = art
        self.spielerCV = spielerCV
        self.video = video
        self.spielstil = spielstil
        self.tempo = tempo
        self.zweikampfstärke = zweikampfstärke
        self.einsGegenEins = einsGegenEins
    }

    static func == (lhs: Client, rhs: Client) -> Bool {
        return lhs.id == rhs.id &&
               lhs.typ == rhs.typ &&
               lhs.name == rhs.name &&
               lhs.vorname == rhs.vorname &&
               lhs.geschlecht == rhs.geschlecht &&
               lhs.abteilung == rhs.abteilung &&
               lhs.vereinID == rhs.vereinID &&
               lhs.nationalitaet == rhs.nationalitaet &&
               lhs.geburtsdatum == rhs.geburtsdatum &&
               lhs.alter == rhs.alter &&
               lhs.kontaktTelefon == rhs.kontaktTelefon &&
               lhs.kontaktEmail == rhs.kontaktEmail &&
               lhs.adresse == rhs.adresse &&
               lhs.liga == rhs.liga &&
               lhs.vertragBis == rhs.vertragBis &&
               lhs.vertragsOptionen == rhs.vertragsOptionen &&
               lhs.gehalt == rhs.gehalt &&
               lhs.schuhgroesse == rhs.schuhgroesse &&
               lhs.schuhmarke == rhs.schuhmarke &&
               lhs.starkerFuss == rhs.starkerFuss &&
               lhs.groesse == rhs.groesse &&
               lhs.gewicht == rhs.gewicht &&
               lhs.positionFeld == rhs.positionFeld &&
               lhs.sprachen == rhs.sprachen &&
               lhs.lizenz == rhs.lizenz &&
               lhs.nationalmannschaft == rhs.nationalmannschaft &&
               lhs.profilbildURL == rhs.profilbildURL &&
               lhs.transfermarktID == rhs.transfermarktID &&
               lhs.userID == rhs.userID &&
               lhs.createdBy == rhs.createdBy &&
               lhs.konditionen == rhs.konditionen &&
               lhs.art == rhs.art &&
               lhs.spielerCV == rhs.spielerCV &&
               lhs.video == rhs.video
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(typ)
        hasher.combine(name)
        hasher.combine(vorname)
        hasher.combine(geschlecht)
        hasher.combine(abteilung)
        hasher.combine(vereinID)
        hasher.combine(nationalitaet)
        hasher.combine(geburtsdatum)
        hasher.combine(alter)
        hasher.combine(kontaktTelefon)
        hasher.combine(kontaktEmail)
        hasher.combine(adresse)
        hasher.combine(liga)
        hasher.combine(vertragBis)
        hasher.combine(vertragsOptionen)
        hasher.combine(gehalt)
        hasher.combine(schuhgroesse)
        hasher.combine(schuhmarke)
        hasher.combine(starkerFuss)
        hasher.combine(groesse)
        hasher.combine(gewicht)
        hasher.combine(positionFeld)
        hasher.combine(sprachen)
        hasher.combine(lizenz)
        hasher.combine(nationalmannschaft)
        hasher.combine(profilbildURL)
        hasher.combine(transfermarktID)
        hasher.combine(userID)
        hasher.combine(createdBy)
        hasher.combine(konditionen)
        hasher.combine(art)
        hasher.combine(spielerCV)
        hasher.combine(video)
    }
}

struct Funktionär: Identifiable, Codable, Hashable {
    @DocumentID var id: String?
    var name: String
    var vorname: String
    var abteilung: String?
    var vereinID: String?
    var kontaktTelefon: String?
    var kontaktEmail: String?
    var adresse: String?
    var clients: [String]?
    var profilbildURL: String?
    var geburtsdatum: Date?
    var positionImVerein: String?
    var mannschaft: String?
    var nationalitaet: [String]?
    var functionaryDocumentURL: String?

    init(
        id: String? = nil,
        name: String,
        vorname: String,
        abteilung: String? = nil,
        vereinID: String? = nil,
        kontaktTelefon: String? = nil,
        kontaktEmail: String? = nil,
        adresse: String? = nil,
        clients: [String]? = nil,
        profilbildURL: String? = nil,
        geburtsdatum: Date? = nil,
        positionImVerein: String? = nil,
        mannschaft: String? = nil,
        nationalitaet: [String]? = nil,
        functionaryDocumentURL: String? = nil // Hinzugefügt
    ) {
        self.id = id
        self.name = name
        self.vorname = vorname
        self.abteilung = abteilung
        self.vereinID = vereinID
        self.kontaktTelefon = kontaktTelefon
        self.kontaktEmail = kontaktEmail
        self.adresse = adresse
        self.clients = clients
        self.profilbildURL = profilbildURL
        self.geburtsdatum = geburtsdatum
        self.positionImVerein = positionImVerein
        self.mannschaft = mannschaft
        self.nationalitaet = nationalitaet
        self.functionaryDocumentURL = functionaryDocumentURL
    }

    enum CodingKeys: String, CodingKey {
        case id
        case name
        case vorname
        case abteilung
        case vereinID
        case kontaktTelefon
        case kontaktEmail
        case adresse
        case clients
        case profilbildURL
        case geburtsdatum
        case positionImVerein
        case mannschaft
        case nationalitaet
        case functionaryDocumentURL
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decodeIfPresent(String.self, forKey: .id)
        self.name = try container.decode(String.self, forKey: .name)
        self.vorname = try container.decode(String.self, forKey: .vorname)
        
        if let abteilungString = try? container.decodeIfPresent(String.self, forKey: .abteilung) {
            self.abteilung = abteilungString
        } else if let abteilungArray = try? container.decodeIfPresent([String].self, forKey: .abteilung) {
            self.abteilung = abteilungArray.first
        } else {
            self.abteilung = nil
        }

        self.vereinID = try container.decodeIfPresent(String.self, forKey: .vereinID)
        self.kontaktTelefon = try container.decodeIfPresent(String.self, forKey: .kontaktTelefon)
        self.kontaktEmail = try container.decodeIfPresent(String.self, forKey: .kontaktEmail)
        self.adresse = try container.decodeIfPresent(String.self, forKey: .adresse)
        self.clients = try container.decodeIfPresent([String].self, forKey: .clients)
        self.profilbildURL = try container.decodeIfPresent(String.self, forKey: .profilbildURL)
        self.geburtsdatum = try container.decodeIfPresent(Date.self, forKey: .geburtsdatum)
        self.positionImVerein = try container.decodeIfPresent(String.self, forKey: .positionImVerein)
        self.mannschaft = try container.decodeIfPresent(String.self, forKey: .mannschaft)
        self.nationalitaet = try container.decodeIfPresent([String].self, forKey: .nationalitaet)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(vorname, forKey: .vorname)
        try container.encodeIfPresent(abteilung, forKey: .abteilung)
        try container.encodeIfPresent(vereinID, forKey: .vereinID)
        try container.encodeIfPresent(kontaktTelefon, forKey: .kontaktTelefon)
        try container.encodeIfPresent(kontaktEmail, forKey: .kontaktEmail)
        try container.encodeIfPresent(adresse, forKey: .adresse)
        try container.encodeIfPresent(clients, forKey: .clients)
        try container.encodeIfPresent(profilbildURL, forKey: .profilbildURL)
        try container.encodeIfPresent(geburtsdatum, forKey: .geburtsdatum)
        try container.encodeIfPresent(positionImVerein, forKey: .positionImVerein)
        try container.encodeIfPresent(mannschaft, forKey: .mannschaft)
        try container.encodeIfPresent(nationalitaet, forKey: .nationalitaet)
    }

    static func == (lhs: Funktionär, rhs: Funktionär) -> Bool {
        return lhs.id == rhs.id &&
               lhs.name == rhs.name &&
               lhs.vorname == rhs.vorname &&
               lhs.abteilung == rhs.abteilung &&
               lhs.vereinID == rhs.vereinID &&
               lhs.kontaktTelefon == rhs.kontaktTelefon &&
               lhs.kontaktEmail == rhs.kontaktEmail &&
               lhs.adresse == rhs.adresse &&
               lhs.clients == rhs.clients &&
               lhs.profilbildURL == rhs.profilbildURL &&
               lhs.geburtsdatum == rhs.geburtsdatum &&
               lhs.positionImVerein == rhs.positionImVerein &&
               lhs.mannschaft == rhs.mannschaft &&
               lhs.nationalitaet == rhs.nationalitaet
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(vorname)
        hasher.combine(abteilung)
        hasher.combine(vereinID)
        hasher.combine(kontaktTelefon)
        hasher.combine(kontaktEmail)
        hasher.combine(adresse)
        hasher.combine(clients)
        hasher.combine(profilbildURL)
        hasher.combine(geburtsdatum)
        hasher.combine(positionImVerein)
        hasher.combine(mannschaft)
        hasher.combine(nationalitaet)
    }
}

struct Contract: Identifiable, Codable, Equatable {
    @DocumentID var id: String?
    var clientID: String?
    var vereinID: String?
    var startDatum: Date
    var endDatum: Date?
    var gehalt: Double?
    var vertragsdetails: String?

    static func == (lhs: Contract, rhs: Contract) -> Bool {
        return lhs.id == rhs.id &&
               lhs.clientID == rhs.clientID &&
               lhs.vereinID == rhs.vereinID &&
               lhs.startDatum == rhs.startDatum &&
               lhs.endDatum == rhs.endDatum &&
               lhs.gehalt == rhs.gehalt &&
               lhs.vertragsdetails == rhs.vertragsdetails
    }
}

struct TransferProcess: Identifiable, Codable {
    @DocumentID var id: String?
    var clientID: String
    var vereinID: String // Der Verein, mit dem der Prozess läuft
    var status: String // z. B. "in Bearbeitung", "abgeschlossen"
    var startDatum: Date
    var schritte: [Step] // Liste der Prozess-Schritte
    var erinnerungen: [Reminder]? // Optional: Erinnerungen
    var hinweise: [Note]? // Optional: Hinweise
    var transferDetails: TransferDetails? // Optional: Details des Transfers
    // Neue Felder aus Feedback
    var mitarbeiterID: String? // Verantwortlicher Mitarbeiter
    var priority: Int? // Priorität (1-5)
    var konditionen: String? // Neu: Gehalt/Vertragsdetails
    var art: String? // Neu: "Vereinswechsel", "Vertragsverlängerung"
    var title: String?
    var sponsorID: String?

    init(
        id: String? = nil,
        clientID: String,
        vereinID: String,
        status: String = "in Bearbeitung",
        startDatum: Date = Date(),
        schritte: [Step] = [],
        erinnerungen: [Reminder]? = nil,
        hinweise: [Note]? = nil,
        transferDetails: TransferDetails? = nil,
        mitarbeiterID: String? = nil,
        priority: Int? = nil,
        konditionen: String? = nil,
        art: String? = nil
    ) {
        self.id = id
        self.clientID = clientID
        self.vereinID = vereinID
        self.status = status
        self.startDatum = startDatum
        self.schritte = schritte
        self.erinnerungen = erinnerungen
        self.hinweise = hinweise
        self.transferDetails = transferDetails
        self.mitarbeiterID = mitarbeiterID
        self.priority = priority
        self.konditionen = konditionen
        self.art = art
    }
}

struct TransferDetails: Identifiable, Codable {
    var id: String? = UUID().uuidString
    var vonVereinID: String?
    var zuVereinID: String?
    var funktionärID: String?
    var datum: Date
    var ablösesumme: Double?
    var isAblösefrei: Bool
    var transferdetails: String?
}

struct Step: Identifiable, Codable {
    var id: String = UUID().uuidString
    var typ: String // z. B. "Kontaktaufnahme", "Verhandlung", "zweitKontakt", "klientInfo", "vertragVerhandeln"
    var status: String // z. B. "geplant", "abgeschlossen"
    var datum: Date
    var notizen: String?
    var erfolgschance: Int? // Erfolgschancen (0-100)
    var checkliste: [String]? // Neu: z. B. ["CV bereit", "Video hochgeladen"]
    var funktionär: String?
    var title: String?
}

struct Reminder: Identifiable, Codable {
    var id: String = UUID().uuidString
    var datum: Date
    var beschreibung: String
    // Neues Feld aus Feedback
    var kategorie: String? // z. B. "nachfrageErinnerung"
}

struct Note: Identifiable, Codable {
    var id: String = UUID().uuidString
    var beschreibung: String
    // Neues Feld aus Feedback
    var vereinsDokumente: [String]? // URLs zu Vereinsdokumenten
}

struct Club: Identifiable, Codable, Hashable {
    @DocumentID var id: String?
    var name: String
    var mensDepartment: Department?
    var womensDepartment: Department?
    var sharedInfo: SharedInfo?

    struct Department: Codable, Hashable {
        var league: String?
        var adresse: String?
        var kontaktTelefon: String?
        var kontaktEmail: String?
        var funktionäre: [FunktionärReference]?
        var clients: [String]?
    }

    struct SharedInfo: Codable, Hashable {
        var land: String?
        var memberCount: Int?
        var founded: String?
        var logoURL: String?
        var clubDocumentURL: String?
    }

    struct FunktionärReference: Codable, Hashable {
        var id: String
        var name: String
        var vorname: String
        var positionImVerein: String?
    }

    func abteilungForGender(_ geschlecht: String) -> String? {
        if geschlecht == "männlich" {
            return mensDepartment != nil ? "Männer" : nil
        } else if geschlecht == "weiblich" {
            return womensDepartment != nil ? "Frauen" : nil
        }
        return nil
    }

    static func == (lhs: Club, rhs: Club) -> Bool {
        return lhs.id == rhs.id &&
               lhs.name == rhs.name &&
               lhs.mensDepartment == rhs.mensDepartment &&
               lhs.womensDepartment == rhs.womensDepartment &&
               lhs.sharedInfo == rhs.sharedInfo
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(mensDepartment)
        hasher.combine(womensDepartment)
        hasher.combine(sharedInfo)
    }
}

struct Match: Identifiable, Codable, Equatable {
    @DocumentID var id: String?
    var heimVereinID: String?
    var gastVereinID: String?
    var datum: Date
    var ergebnis: String?
    var stadion: String?

    static func == (lhs: Match, rhs: Match) -> Bool {
        return lhs.id == rhs.id &&
               lhs.heimVereinID == rhs.heimVereinID &&
               lhs.gastVereinID == rhs.gastVereinID &&
               lhs.datum == rhs.datum &&
               lhs.ergebnis == rhs.ergebnis &&
               lhs.stadion == rhs.stadion
    }
}

struct Sponsor: Identifiable, Codable, Equatable {
    @DocumentID var id: String?
    var name: String
    var category: String?
    var contacts: [Contact]?
    var kontaktTelefon: String?
    var kontaktEmail: String?
    var adresse: String?
    var gesponsorteVereine: [String]?

    struct Contact: Codable, Identifiable, Equatable {
        var id: String = UUID().uuidString
        var name: String
        var region: String
        var telefon: String?
        var email: String?
    }

    static func == (lhs: Sponsor, rhs: Sponsor) -> Bool {
        return lhs.id == rhs.id &&
               lhs.name == rhs.name &&
               lhs.category == rhs.category &&
               lhs.contacts == rhs.contacts &&
               lhs.kontaktTelefon == rhs.kontaktTelefon &&
               lhs.kontaktEmail == rhs.kontaktEmail &&
               lhs.adresse == rhs.adresse &&
               lhs.gesponsorteVereine == rhs.gesponsorteVereine
    }
}

struct Activity: Identifiable, Codable {
    @DocumentID var id: String?
    var clientID: String
    var description: String
    var timestamp: Date
    var category: String?
    var comments: [String]?

    enum CodingKeys: String, CodingKey {
        case id
        case clientID
        case description
        case timestamp
        case category
        case comments
    }

    init(id: String? = nil, clientID: String, description: String, timestamp: Date, category: String? = nil, comments: [String]? = nil) {
        self.id = id
        self.clientID = clientID
        self.description = description
        self.timestamp = timestamp
        self.category = category
        self.comments = comments
    }
}

struct Message: Identifiable, Codable, Equatable {
    @DocumentID var id: String?
    var senderID: String
    var senderEmail: String
    var content: String?
    var fileURL: String?
    var fileType: String?
    var timestamp: Date
    var readBy: [String]

    static func == (lhs: Message, rhs: Message) -> Bool {
        return lhs.id == rhs.id
    }
}

struct Chat: Codable, Identifiable {
    @DocumentID var id: String?
    var participantIDs: [String]
    var lastMessage: String?
    var lastMessageTimestamp: Date?
    var isArchived: Bool?

    enum CodingKeys: String, CodingKey {
        case id
        case participantIDs
        case lastMessage
        case lastMessageTimestamp
        case isArchived
    }
}

struct ChatMessage: Codable, Identifiable {
    var id: String?
    var senderID: String
    var senderEmail: String
    var content: String?
    var fileURL: String?
    var fileType: String?
    var timestamp: Date
    var readBy: [String]

    enum CodingKeys: String, CodingKey {
        case id
        case senderID
        case senderEmail
        case content
        case fileURL
        case fileType
        case timestamp
        case readBy
    }
}

struct PlayerData: Codable {
    var name: String?
    var position: String?
    var nationalitaet: [String]?
    var geburtsdatum: Date?
    var vereinID: String?
    var contractEnd: Date?
}

struct Matching: Identifiable, Codable {
    var id: String = UUID().uuidString
    var clientID: String
    var vereinID: String
    var matchScore: Double // Übereinstimmungsrate (0-100)
    var status: String // "pending", "accepted", "rejected"
    var createdAt: Date
}

struct MatchingFeedback: Identifiable, Codable {
    var id: String = UUID().uuidString
    var matchID: String
    var userID: String // Mitarbeiter, der das Feedback gibt
    var status: String // "accepted" oder "rejected"
    var reason: String? // Grund für Ablehnung
    var timestamp: Date
}

struct User: Identifiable, Codable {
    @DocumentID var id: String?
    var email: String
    var rolle: String
    var points: Int? // Neue Eigenschaft
    var badges: [String]? // Neue Eigenschaft (z. B. ["first_email", "transfer_master"])
    var challenges: [Challenge]? // Neue Eigenschaft
}

struct Challenge: Identifiable, Codable {
    var id: String = UUID().uuidString
    var title: String // z. B. "Versende 3 E-Mails an Vereine"
    var description: String
    var points: Int // Belohnung
    var progress: Int // Fortschritt (z. B. 2/3 E-Mails versendet)
    var goal: Int // Ziel (z. B. 3 E-Mails)
    var type: String // z. B. "send_emails", "acquire_client"
    var completed: Bool
}



//
//  MultiPicker.swift

import SwiftUI

struct MultiPicker: View {
    let title: String
    @Binding var selection: [String]
    let options: [String]
    var isNationalityPicker: Bool = false // Optionaler Parameter für Nationalitäten-Modus
    @State private var searchText: String = ""

    private let priorityNationalities = ["Deutschland", "Schweiz", "Österreich"]

    private var filteredOptions: [String] {
        if isNationalityPicker {
            let nonPriorityOptions = options.filter { !priorityNationalities.contains($0) }
            if searchText.isEmpty {
                return nonPriorityOptions
            } else {
                return nonPriorityOptions.filter { $0.lowercased().contains(searchText.lowercased()) }
            }
        } else {
            if searchText.isEmpty {
                return options
            } else {
                return options.filter { $0.lowercased().contains(searchText.lowercased()) }
            }
        }
    }

    var body: some View {
        NavigationView {
            VStack(alignment: .leading) {
                if isNationalityPicker || options.count > 10 {
                    TextField("Suche", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .padding()
                }

                List {
                    if isNationalityPicker {
                        Section(header: Text("Häufig verwendet")) {
                            ForEach(priorityNationalities, id: \.self) { option in
                                MultipleSelectionRow(
                                    title: option,
                                    isSelected: selection.contains(option)
                                ) {
                                    toggleSelection(option)
                                }
                            }
                        }
                    }

                    Section(header: Text(isNationalityPicker ? "Alle Länder" : title)) {
                        ForEach(filteredOptions, id: \.self) { option in
                            MultipleSelectionRow(
                                title: option,
                                isSelected: selection.contains(option)
                            ) {
                                toggleSelection(option)
                            }
                        }
                    }
                }
            }
            .navigationTitle(title)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Fertig") {
                        // Die Auswahl wird automatisch über die Binding aktualisiert
                    }
                }
            }
        }
    }

    private func toggleSelection(_ option: String) {
        if selection.contains(option) {
            selection.removeAll { $0 == option }
        } else {
            selection.append(option)
        }
    }
}

// Eingebautes MultipleSelectionRow direkt in MultiPicker
struct MultipleSelectionRow: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                Spacer()
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
        }
    }
}

#Preview {
    MultiPicker(
        title: "Nationalitäten auswählen",
        selection: .constant(["Deutschland"]),
        options: ["Deutschland", "Schweiz", "Österreich", "Frankreich", "Italien", "Spanien"],
        isNationalityPicker: true
    )
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/2.1 Workflow
//
//  WorkflowOverviewView.swift

import SwiftUI
import FirebaseFirestore

struct WorkflowOverviewView: View {
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var transferProcessViewModel: TransferProcessViewModel
    @State private var filterMitarbeiter: String? = nil
    @State private var filterVerein: String? = nil
    @State private var filterPriority: Int? = nil
    @State private var searchText = ""
    @State private var showingNewProcess = false
    @State private var clients: [String: Client] = [:]  // Cache für Client-Namen
    @State private var clubs: [String: Club] = [:]      // Cache für Vereinsnamen
    @State private var mitarbeiter: [String: String] = [:]  // Cache für Mitarbeiter-IDs (vorläufig nur IDs)

    init() {
        // Globale Anpassung der Navigationsleiste
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = .black
        appearance.titleTextAttributes = [.foregroundColor: UIColor.white]
        appearance.largeTitleTextAttributes = [.foregroundColor: UIColor.white]
        
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        UINavigationBar.appearance().tintColor = .white
    }

    var filteredProcesses: [TransferProcess] {
        transferProcessViewModel.transferProcesses.filter { process in
            let matchesMitarbeiter = filterMitarbeiter == nil || process.mitarbeiterID == filterMitarbeiter
            let matchesVerein = filterVerein == nil || process.vereinID == filterVerein
            let matchesPriority = filterPriority == nil || process.priority == filterPriority
            let matchesSearch = searchText.isEmpty || (process.title?.lowercased().contains(searchText.lowercased()) ?? false)
            return matchesMitarbeiter && matchesVerein && matchesPriority && matchesSearch
        }
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 10) {
                // Überschrift "Workflow"
                Text("Workflow")
                    .font(.title)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.top, 10)
                    .padding(.bottom, 5)

                // Suchleiste
                TextField("Suche...", text: $searchText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .padding(.horizontal)
                    .foregroundColor(.white)
                    .background(Color.gray.opacity(0.2))
                    .frame(maxWidth: .infinity)

                // Filter
                HStack(spacing: 10) {
                    Picker("Mitarbeiter", selection: $filterMitarbeiter) {
                        Text("Alle").tag(String?.none)
                        ForEach(mitarbeiter.keys.sorted(), id: \.self) { id in
                            Text(mitarbeiter[id] ?? id).tag(String?.some(id))
                        }
                    }
                    Picker("Verein", selection: $filterVerein) {
                        Text("Alle").tag(String?.none)
                        ForEach(clubs.keys.sorted(), id: \.self) { id in
                            Text(clubs[id]?.name ?? "Unbekannt").tag(String?.some(id))
                        }
                    }
                    Picker("Priorität", selection: $filterPriority) {
                        Text("Alle").tag(Int?.none)
                        ForEach(1...5, id: \.self) { prio in
                            Text("\(prio)").tag(Int?.some(prio))
                        }
                    }
                }
                .pickerStyle(MenuPickerStyle())
                .foregroundColor(.white)
                .font(.subheadline)

                // Liste
                List(filteredProcesses) { process in
                    NavigationLink(destination: TransferProcessDetailView(transferProcess: process)) {
                        HStack {
                            Text(process.title ?? "Unbekannt")
                                .foregroundColor(.white)
                            Spacer()
                            Text(process.status)
                                .foregroundColor(.gray)
                        }
                    }
                    .listRowBackground(Color.gray.opacity(0.2))
                }
                .scrollContentBackground(.hidden)
                .background(Color.black)
            }
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { showingNewProcess = true }) {
                        Image(systemName: "plus")
                            .foregroundColor(.white)
                    }
                }
            }
            .sheet(isPresented: $showingNewProcess) {
                AddTransferProcessView()
                    .environmentObject(transferProcessViewModel)
            }
            .background(Color.black)
            .task {
                // Lade Transferprozesse
                await transferProcessViewModel.loadTransferProcesses()
                
                // Lade Clients für Namen
                do {
                    let (loadedClients, _) = try await FirestoreManager.shared.getAllClients(limit: 100)
                    for client in loadedClients {
                        if let id = client.id {
                            clients[id] = client
                        }
                    }
                } catch {
                    print("Fehler beim Laden der Klienten: \(error)")
                }
                
                // Lade Clubs für Namen
                // Lade Clubs für Namen
                do {
                    let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 100)
                    for club in loadedClubs {
                        if let id = club.id {
                            clubs[id] = club
                        }
                    }
                } catch {
                    print("Fehler beim Laden der Vereine: \(error)")
                }
                
                // Lade Mitarbeiter-IDs (da "vorname" nicht in "users" vorhanden ist, nutzen wir die userID)
                do {
                    let snapshot = try await Firestore.firestore().collection("users")
                        .whereField("rolle", isEqualTo: "Mitarbeiter")
                        .getDocuments()
                    for doc in snapshot.documents {
                        mitarbeiter[doc.documentID] = doc.data()["email"] as? String ?? doc.documentID
                    }
                } catch {
                    print("Fehler beim Laden der Mitarbeiter: \(error)")
                }
                
                // Setze Titel für Prozesse (falls nicht vorhanden) und speichere sie in Firestore
                for i in 0..<transferProcessViewModel.transferProcesses.count {
                    let process = transferProcessViewModel.transferProcesses[i]
                    if process.title == nil {
                        let clientName = clients[process.clientID]?.vorname ?? "Unbekannt"
                        let vereinName = clubs[process.vereinID]?.name ?? "Unbekannt"
                        transferProcessViewModel.transferProcesses[i].title = "\(clientName) -> \(vereinName)"
                        // Speichere den aktualisierten Prozess in Firestore
                        do {
                            try await FirestoreManager.shared.updateTransferProcess(transferProcess: transferProcessViewModel.transferProcesses[i])
                        } catch {
                            print("Fehler beim Aktualisieren des Prozesses: \(error)")
                        }
                    }
                }
            }
        }
    }
}

struct WorkflowDetailView: View {
    let process: TransferProcess
    var body: some View {
        VStack {
            Text("Detailansicht für \(process.title ?? "Unbekannt")")
            Text("Status: \(process.status)")
            Text("Priorität: \(process.priority ?? 0)")
        }
        .foregroundColor(.white)
        .background(Color.black)
    }
}

#Preview {
    WorkflowOverviewView()
        .environmentObject(AuthManager())
        .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/2.2 Matching
//
//  Matching.View.swift

import SwiftUI
import FirebaseFirestore

struct MatchingView: View {
    @EnvironmentObject var authManager: AuthManager
    @State private var matches: [Match] = []
    @State private var clients: [String: Client] = [:]
    @State private var clubs: [String: Club] = [:]
    @State private var errorMessage = ""
    @State private var showingFeedbackSheet = false
    @State private var selectedMatch: Match?
    @State private var rejectionReason = ""

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)
                VStack {
                    if matches.isEmpty {
                        Text("Keine Matches vorhanden.")
                            .foregroundColor(secondaryTextColor)
                            .padding()
                    } else {
                        List {
                            ForEach(matches) { match in
                                matchRow(for: match)
                                    .swipeActions {
                                        Button(action: {
                                            Task {
                                                await acceptMatch(match)
                                            }
                                        }) {
                                            Label("Akzeptieren", systemImage: "checkmark")
                                        }
                                        .tint(.green)
                                        Button(action: {
                                            selectedMatch = match
                                            showingFeedbackSheet = true
                                        }) {
                                            Label("Ablehnen", systemImage: "xmark")
                                        }
                                        .tint(.red)
                                    }
                                    .listRowBackground(cardBackgroundColor)
                            }
                        }
                        .scrollContentBackground(.hidden)
                        .background(backgroundColor)
                    }
                }
            }
            .navigationTitle("Matching")
            .foregroundColor(textColor)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        Task {
                            await generateMatches()
                        }
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .foregroundColor(accentColor)
                    }
                }
            }
            .sheet(isPresented: $showingFeedbackSheet) {
                feedbackSheet
            }
            .task {
                await loadMatches()
                await loadClientsAndClubs()
            }
            .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
                Alert(
                    title: Text("Fehler").foregroundColor(textColor),
                    message: Text(errorMessage).foregroundColor(secondaryTextColor),
                    dismissButton: .default(Text("OK").foregroundColor(accentColor))
                )
            }
        }
    }

    private func matchRow(for match: Match) -> some View {
        HStack {
            VStack(alignment: .leading, spacing: 5) {
                Text("\(clients[match.clientID]?.vorname ?? "Unbekannt") \(clients[match.clientID]?.name ?? "")")
                    .font(.headline)
                    .foregroundColor(textColor)
                Text("Verein: \(clubs[match.vereinID]?.name ?? "Unbekannt")")
                    .font(.subheadline)
                    .foregroundColor(secondaryTextColor)
                Text("Match-Score: \(String(format: "%.1f", match.matchScore))%")
                    .font(.caption)
                    .foregroundColor(match.matchScore > 75 ? .green : .yellow)
                Text("Status: \(match.status)")
                    .font(.caption)
                    .foregroundColor(match.status == "accepted" ? .green : match.status == "rejected" ? .red : .gray)
            }
            Spacer()
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 10))
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(accentColor, lineWidth: 1)
        )
    }

    private var feedbackSheet: some View {
        NavigationView {
            Form {
                Section(header: Text("Grund für Ablehnung").foregroundColor(.white)) {
                    TextField("Grund eingeben...", text: $rejectionReason)
                        .foregroundColor(.white)
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Match ablehnen")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") {
                        rejectionReason = ""
                        showingFeedbackSheet = false
                    }
                    .foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Ablehnen") {
                        Task {
                            await rejectMatch(selectedMatch!)
                        }
                        rejectionReason = ""
                        showingFeedbackSheet = false
                    }
                    .foregroundColor(.white)
                }
            }
        }
    }

    private func loadMatches() async {
        do {
            let snapshot = try await Firestore.firestore().collection("matches")
                .whereField("status", isEqualTo: "pending")
                .getDocuments()
            let loadedMatches = snapshot.documents.compactMap { doc -> Match? in
                try? doc.data(as: Match.self)
            }
            await MainActor.run {
                matches = loadedMatches
            }
        } catch {
            errorMessage = "Fehler beim Laden der Matches: \(error.localizedDescription)"
        }
    }

    private func loadClientsAndClubs() async {
        do {
            let (loadedClients, _) = try await FirestoreManager.shared.getAllClients(lastDocument: nil, limit: 1000)
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            var clientDict: [String: Client] = [:]
            var clubDict: [String: Club] = [:]
            for client in loadedClients {
                if let id = client.id { clientDict[id] = client }
            }
            for club in loadedClubs {
                if let id = club.id { clubDict[id] = club }
            }
            await MainActor.run {
                clients = clientDict
                clubs = clubDict
            }
        } catch {
            errorMessage = "Fehler beim Laden der Klienten/Vereine: \(error.localizedDescription)"
        }
    }

    private func generateMatches() async {
        do {
            let newMatches = try await FirestoreManager.shared.generateMatches()
            await MainActor.run {
                matches = newMatches
            }
        } catch {
            errorMessage = "Fehler beim Generieren der Matches: \(error.localizedDescription)"
        }
    }

    private func acceptMatch(_ match: Match) async {
        do {
            let feedback = MatchFeedback(
                matchID: match.id,
                userID: authManager.userID ?? "unknown",
                status: "accepted",
                reason: nil,
                timestamp: Date()
            )
            try await FirestoreManager.shared.saveMatchFeedback(feedback: feedback)
            await loadMatches()
        } catch {
            errorMessage = "Fehler beim Akzeptieren des Matches: \(error.localizedDescription)"
        }
    }

    private func rejectMatch(_ match: Match) async {
        do {
            let feedback = MatchFeedback(
                matchID: match.id,
                userID: authManager.userID ?? "unknown",
                status: "rejected",
                reason: rejectionReason,
                timestamp: Date()
            )
            try await FirestoreManager.shared.saveMatchFeedback(feedback: feedback)
            await loadMatches()
        } catch {
            errorMessage = "Fehler beim Ablehnen des Matches: \(error.localizedDescription)"
        }
    }
}

#Preview {
    MatchingView()
        .environmentObject(AuthManager())
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/3. HauptViews
//
//  ActivityDetailView.swift

import SwiftUI
import FirebaseFirestore

struct ActivityDetailView: View {
    @EnvironmentObject var authManager: AuthManager
    @Environment(\.dismiss) var dismiss
    let activity: Activity
    @State private var editedDescription = ""
    @State private var showingEditMode = false
    @State private var errorMessage = ""
    @State private var showingDeleteConfirmation = false
    @State private var comments: [String] = []
    @State private var newComment = ""
    @State private var category = "Sonstiges"

    var body: some View {
        NavigationView {
            mainContent
                .navigationTitle("Aktivität")
                .foregroundColor(.white)
                .toolbar { toolbarItems }
                .alert(isPresented: $showingDeleteConfirmation) { deleteConfirmationAlert }
                .alert(isPresented: .constant(!errorMessage.isEmpty)) { errorAlert }
                .onAppear {
                    editedDescription = activity.description
                    category = activity.category ?? "Sonstiges"
                    comments = activity.comments ?? []
                }
        }
    }

    // Hauptinhalt
    private var mainContent: some View {
        Form {
            detailsSection
            commentsSection
            if showingEditMode { editActionsSection }
            deleteSection
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    // Toolbar-Items
    private var toolbarItems: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            if !showingEditMode {
                Button(action: { enterEditMode() }) {
                    Image(systemName: "pencil")
                        .foregroundColor(.white)
                }
            }
        }
    }

    // Details-Sektion
    private var detailsSection: some View {
        Section(header: Text("Details").foregroundColor(.white)) {
            descriptionField
            dateField
            createdByField
            categoryField
        }
    }

    private var descriptionField: some View {
        Group {
            Text("Beschreibung").font(.subheadline).foregroundColor(.gray)
            if showingEditMode {
                TextField("Beschreibung", text: $editedDescription).foregroundColor(.white)
            } else {
                Text(activity.description).foregroundColor(.white)
            }
        }
    }

    private var dateField: some View {
        HStack {
            Text("Datum").font(.subheadline).foregroundColor(.gray)
            Spacer()
            Text(activity.timestamp, style: .date).foregroundColor(.white)
        }
    }

    private var createdByField: some View {
        HStack {
            Text("Erstellt von").font(.subheadline).foregroundColor(.gray)
            Spacer()
            Text(authManager.userEmail ?? "Unbekannt").foregroundColor(.white)
        }
    }

    private var categoryField: some View {
        Group {
            if showingEditMode {
                Picker("Kategorie", selection: $category) {
                    ForEach(Constants.activityCategories, id: \.self) { cat in
                        Text(cat).tag(cat)
                    }
                }
                .pickerStyle(MenuPickerStyle())
                .foregroundColor(.white)
                .accentColor(.white)
            } else {
                HStack {
                    Text("Kategorie").font(.subheadline).foregroundColor(.gray)
                    Spacer()
                    Text(category).foregroundColor(.white)
                }
            }
        }
    }

    // Kommentare-Sektion
    private var commentsSection: some View {
        Section(header: Text("Kommentare").foregroundColor(.white)) {
            if comments.isEmpty {
                Text("Keine Kommentare vorhanden.").foregroundColor(.gray)
            } else {
                ForEach(comments, id: \.self) { comment in
                    Text(comment).foregroundColor(.white)
                }
            }
            if showingEditMode { commentInputField }
        }
    }

    private var commentInputField: some View {
        HStack {
            TextField("Neuer Kommentar", text: $newComment).foregroundColor(.white)
            Button(action: {
                if !newComment.isEmpty {
                    comments.append("\(authManager.userEmail ?? "Unbekannt"): \(newComment)")
                    newComment = ""
                }
            }) {
                Image(systemName: "plus.circle").foregroundColor(.white)
            }
        }
    }

    // Edit-Aktionen-Sektion
    private var editActionsSection: some View {
        Section {
            Button("Speichern") {
                Task { await saveChanges() }
            }
            .foregroundColor(.white)
            Button("Abbrechen") {
                editedDescription = activity.description
                category = activity.category ?? "Sonstiges"
                comments = activity.comments ?? []
                showingEditMode = false
            }
            .foregroundColor(.gray)
        }
    }

    // Lösch-Sektion
    private var deleteSection: some View {
        Section {
            Button("Aktivität löschen") {
                showingDeleteConfirmation = true
            }
            .foregroundColor(.red)
        }
    }

    // Löschen-Bestätigungs-Alert
    private var deleteConfirmationAlert: Alert {
        Alert(
            title: Text("Aktivität löschen").foregroundColor(.white),
            message: Text("Möchtest du diese Aktivität wirklich löschen?").foregroundColor(.white),
            primaryButton: .destructive(Text("Löschen").foregroundColor(.red)) {
                Task { await deleteActivity() }
            },
            secondaryButton: .cancel(Text("Abbrechen").foregroundColor(.white))
        )
    }

    // Fehler-Alert
    private var errorAlert: Alert {
        Alert(
            title: Text("Fehler").foregroundColor(.white),
            message: Text(errorMessage).foregroundColor(.white),
            dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
        )
    }

    private func enterEditMode() {
        showingEditMode = true
    }

    private func saveChanges() async {
        guard let activityID = activity.id else {
            await MainActor.run { errorMessage = "Keine Aktivitäts-ID vorhanden" }
            return
        }
        let updatedActivity = Activity(
            id: activityID,
            clientID: activity.clientID,
            description: editedDescription,
            timestamp: activity.timestamp,
            category: category,
            comments: comments
        )
        do {
            try await FirestoreManager.shared.updateActivity(activity: updatedActivity)
            await MainActor.run { showingEditMode = false }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Speichern: \(error.localizedDescription)" }
        }
    }

    private func deleteActivity() async {
        guard let activityID = activity.id else {
            await MainActor.run { errorMessage = "Keine Aktivitäts-ID vorhanden" }
            return
        }
        do {
            try await FirestoreManager.shared.deleteActivity(activityID: activityID)
            await MainActor.run { dismiss() }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Löschen: \(error.localizedDescription)" }
        }
    }
}

#Preview("Activity Detail") {
    ActivityDetailView(activity: Activity(id: "1", clientID: "client1", description: "Besprechung mit Trainer", timestamp: Date()))
        .environmentObject(AuthManager())
}



//
//  ActivityViewModel.swift

import Foundation
import FirebaseFirestore

class ActivityViewModel: ObservableObject {
    @Published var activities: [Activity] = []
    @Published var errorMessage: String = ""
    @Published var isLoading: Bool = false
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    func loadActivities(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newActivities, newLastDoc) = try await FirestoreManager.shared.getActivities(lastDocument: loadMore ? lastDocument : nil, limit: pageSize)
            await MainActor.run {
                if loadMore { activities.append(contentsOf: newActivities) } else { activities = newActivities }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run { errorMessage = "Fehler: \(error.localizedDescription)"; isLoading = false }
        }
    }

    func recentActivities(days: Int) -> [Activity] {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date())!
        return activities
            .filter { $0.timestamp >= cutoffDate }
            .sorted { $0.timestamp > $1.timestamp }
    }
}



//
//  ClientHomeView.swift

import SwiftUI
import FirebaseFirestore

struct ClientHomeView: View {
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var transferProcessViewModel: TransferProcessViewModel
    @State private var showingNewChatSheet = false
    @State private var selectedPartner: String? = nil
    @State private var potentialChatPartners: [(id: String, name: String)] = []
    @State private var errorMessage: String = ""
    @State private var chats: [Chat] = []
    @State private var navigateToChat: Chat? = nil // Für die Navigation zum neuen Chat

    var body: some View {
        NavigationStack {
            TabView {
                Text("Client Home")
                    .font(.largeTitle)
                    .foregroundColor(.white)
                    .tabItem {
                        Label("Home", systemImage: "house")
                    }

                ChatListView(
                    showingNewChatSheet: $showingNewChatSheet,
                    selectedPartner: $selectedPartner,
                    potentialChatPartners: $potentialChatPartners,
                    errorMessage: $errorMessage,
                    chats: $chats,
                    onChatCreated: { newChat in
                        Task {
                            await loadChats()
                            // Setze den neuen Chat für die Navigation
                            await MainActor.run {
                                navigateToChat = newChat
                            }
                        }
                    }
                )
                    .tabItem {
                        Label("Chats", systemImage: "message")
                    }
                    .environmentObject(authManager)
            }
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        print("New Chat Button Tapped - Showing Sheet")
                        showingNewChatSheet = true
                    }) {
                        Image(systemName: "plus")
                            .foregroundColor(.white)
                    }
                }
            }
            .sheet(isPresented: $showingNewChatSheet) {
                NewChatView(
                    potentialChatPartners: potentialChatPartners,
                    selectedPartner: $selectedPartner,
                    onCreate: { partnerID in
                        guard let userID = authManager.userID else {
                            errorMessage = "Benutzer-ID nicht verfügbar."
                            return
                        }
                        Task {
                            do {
                                print("Creating Chat with Participants: \(userID), \(partnerID)")
                                let chatID = try await FirestoreManager.shared.createChat(participantIDs: [userID, partnerID])
                                print("Chat Created with ID: \(chatID)")
                                // Lade den neuen Chat
                                let newChat = Chat(
                                    id: chatID,
                                    participantIDs: [userID, partnerID],
                                    lastMessage: nil,
                                    lastMessageTimestamp: Date()
                                )
                                // Schließe die Sheet-Ansicht
                                showingNewChatSheet = false
                                // Navigiere direkt zum neuen Chat
                                await MainActor.run {
                                    navigateToChat = newChat
                                }
                            } catch {
                                errorMessage = "Fehler beim Erstellen des Chats: \(error.localizedDescription)"
                                print("Error Creating Chat: \(error)")
                            }
                        }
                    },
                    onCancel: {
                        showingNewChatSheet = false
                        selectedPartner = nil
                    }
                )
            }
            .navigationDestination(isPresented: Binding(
                get: { navigateToChat != nil },
                set: { if !$0 { navigateToChat = nil } }
            )) {
                if let chat = navigateToChat {
                    ChatDetailView(chat: chat, onChatUpdated: {
                        Task {
                            await loadChats()
                        }
                    })
                    .environmentObject(authManager)
                }
            }
            .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
                Alert(
                    title: Text("Fehler"),
                    message: Text(errorMessage),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onAppear {
                print("ClientHomeView - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                updateClientsWithUserID()
                loadPotentialChatPartners()
                Task {
                    await loadChats()
                }
            }
        }
    }

    private func updateClientsWithUserID() {
        guard let userID = authManager.userID else { return }
        Task {
            do {
                try await FirestoreManager.shared.updateClientsWithUserID(userID: userID)
            } catch {
                print("Fehler beim Aktualisieren der userID für Klienten: \(error)")
            }
        }
    }

    private func loadChats() async {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        do {
            let loadedChats = try await FirestoreManager.shared.getChats(forUserID: userID)
            await MainActor.run {
                chats = loadedChats
                print("Loaded Chats in ClientHomeView: \(loadedChats.count)")
            }
        } catch {
            errorMessage = "Fehler beim Laden der Chats: \(error.localizedDescription)"
        }
    }

    private func loadPotentialChatPartners() {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        Task {
            do {
                // Lade alle Benutzer aus der "users"-Collection
                let userSnapshot = try await Firestore.firestore().collection("users").getDocuments()
                let users = userSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("User: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Users: \(users)")

                // Lade alle Klienten aus der "clients"-Collection
                let clientSnapshot = try await Firestore.firestore().collection("clients").getDocuments()
                let clients = clientSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("Client: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Clients: \(clients)")

                // Lade alle Funktionäre aus der "funktionare"-Collection
                let funktionarSnapshot = try await Firestore.firestore().collection("funktionare").getDocuments()
                let funktionare = funktionarSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("Funktionär: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Funktionäre: \(funktionare)")

                // Kombiniere alle Entitäten in einer Liste
                var potentialPartners: [(id: String, name: String)] = []
                potentialPartners.append(contentsOf: users)
                potentialPartners.append(contentsOf: clients)
                potentialPartners.append(contentsOf: funktionare)

                // Entferne Duplikate basierend auf der globalID
                var seenIDs: Set<String> = []
                potentialPartners = potentialPartners.filter { partner in
                    if seenIDs.contains(partner.id) {
                        return false
                    }
                    seenIDs.insert(partner.id)
                    return true
                }
                print("Combined Potential Chat Partners: \(potentialPartners)")

                // Entferne den aktuellen Benutzer aus der Liste
                let filteredPartners = potentialPartners.filter { partner in
                    partner.id != userID
                }
                print("Filtered Potential Chat Partners: \(filteredPartners)")

                await MainActor.run {
                    potentialChatPartners = filteredPartners
                }
            } catch {
                errorMessage = "Fehler beim Laden der Chat-Partner: \(error.localizedDescription)"
            }
        }
    }
}

#Preview {
    ClientHomeView()
        .environmentObject(AuthManager())
        .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



//
//  EmployeeView.swift

import SwiftUI
import FirebaseFirestore

struct EmployeeView: View {
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var transferProcessViewModel: TransferProcessViewModel
    @State private var showingNewChatSheet = false
    @State private var selectedPartner: String? = nil
    @State private var potentialChatPartners: [(id: String, name: String)] = []
    @State private var errorMessage: String = ""
    @State private var chats: [Chat] = []
    @State private var navigateToChat: Chat? = nil // Für die Navigation zum neuen Chat

    var body: some View {
        NavigationStack {
            TabView {
                WorkflowOverviewView()
                    .tabItem {
                        Label("Workflow", systemImage: "list.bullet")
                    }
                    .environmentObject(authManager)
                    .environmentObject(transferProcessViewModel)

                ChatListView(
                    showingNewChatSheet: $showingNewChatSheet,
                    selectedPartner: $selectedPartner,
                    potentialChatPartners: $potentialChatPartners,
                    errorMessage: $errorMessage,
                    chats: $chats,
                    onChatCreated: { newChat in
                        Task {
                            await loadChats()
                            // Setze den neuen Chat für die Navigation
                            await MainActor.run {
                                navigateToChat = newChat
                            }
                        }
                    }
                )
                    .tabItem {
                        Label("Chats", systemImage: "message")
                    }
                    .environmentObject(authManager)
            }
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        print("New Chat Button Tapped - Showing Sheet")
                        showingNewChatSheet = true
                    }) {
                        Image(systemName: "plus")
                            .foregroundColor(.white)
                    }
                }
            }
            .sheet(isPresented: $showingNewChatSheet) {
                NewChatView(
                    potentialChatPartners: potentialChatPartners,
                    selectedPartner: $selectedPartner,
                    onCreate: { partnerID in
                        guard let userID = authManager.userID else {
                            errorMessage = "Benutzer-ID nicht verfügbar."
                            return
                        }
                        Task {
                            do {
                                print("Creating Chat with Participants: \(userID), \(partnerID)")
                                let chatID = try await FirestoreManager.shared.createChat(participantIDs: [userID, partnerID])
                                print("Chat Created with ID: \(chatID)")
                                // Lade den neuen Chat
                                let newChat = Chat(
                                    id: chatID,
                                    participantIDs: [userID, partnerID],
                                    lastMessage: nil,
                                    lastMessageTimestamp: Date()
                                )
                                // Schließe die Sheet-Ansicht
                                showingNewChatSheet = false
                                // Navigiere direkt zum neuen Chat
                                await MainActor.run {
                                    navigateToChat = newChat
                                }
                            } catch {
                                errorMessage = "Fehler beim Erstellen des Chats: \(error.localizedDescription)"
                                print("Error Creating Chat: \(error)")
                            }
                        }
                    },
                    onCancel: {
                        showingNewChatSheet = false
                        selectedPartner = nil
                    }
                )
            }
            .navigationDestination(isPresented: Binding(
                get: { navigateToChat != nil },
                set: { if !$0 { navigateToChat = nil } }
            )) {
                if let chat = navigateToChat {
                    ChatDetailView(chat: chat, onChatUpdated: {
                        Task {
                            await loadChats()
                        }
                    })
                    .environmentObject(authManager)
                }
            }
            .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
                Alert(
                    title: Text("Fehler"),
                    message: Text(errorMessage),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onAppear {
                print("EmployeeView - Authentifiziert: \(authManager.isLoggedIn), UserRole: \(String(describing: authManager.userRole)), UserEmail: \(String(describing: authManager.userEmail))")
                updateClientsWithUserID()
                loadPotentialChatPartners()
                Task {
                    await loadChats()
                }
            }
        }
    }

    private func updateClientsWithUserID() {
        guard let userID = authManager.userID else { return }
        Task {
            do {
                try await FirestoreManager.shared.updateClientsWithUserID(userID: userID)
            } catch {
                print("Fehler beim Aktualisieren der userID für Klienten: \(error)")
            }
        }
    }

    private func loadChats() async {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        do {
            let loadedChats = try await FirestoreManager.shared.getChats(forUserID: userID)
            await MainActor.run {
                chats = loadedChats
                print("Loaded Chats in EmployeeView: \(loadedChats.count)")
            }
        } catch {
            errorMessage = "Fehler beim Laden der Chats: \(error.localizedDescription)"
        }
    }

    private func loadPotentialChatPartners() {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        Task {
            do {
                // Lade alle Benutzer aus der "users"-Collection
                let userSnapshot = try await Firestore.firestore().collection("users").getDocuments()
                let users = userSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("User: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Users: \(users)")

                // Lade alle Klienten aus der "clients"-Collection
                let clientSnapshot = try await Firestore.firestore().collection("clients").getDocuments()
                let clients = clientSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("Client: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Clients: \(clients)")

                // Lade alle Funktionäre aus der "funktionare"-Collection
                let funktionarSnapshot = try await Firestore.firestore().collection("funktionare").getDocuments()
                let funktionare = funktionarSnapshot.documents.compactMap { doc -> (id: String, name: String)? in
                    let data = doc.data()
                    let vorname = data["vorname"] as? String ?? "Unbekannt"
                    let name = data["name"] as? String ?? "Unbekannt"
                    let globalID = data["globalID"] as? String ?? doc.documentID
                    print("Funktionär: \(globalID), Name: \(vorname) \(name)")
                    return (id: globalID, name: "\(vorname) \(name)")
                }
                print("Loaded Funktionäre: \(funktionare)")

                // Kombiniere alle Entitäten in einer Liste
                var potentialPartners: [(id: String, name: String)] = []
                potentialPartners.append(contentsOf: users)
                potentialPartners.append(contentsOf: clients)
                potentialPartners.append(contentsOf: funktionare)

                // Entferne Duplikate basierend auf der globalID
                var seenIDs: Set<String> = []
                potentialPartners = potentialPartners.filter { partner in
                    if seenIDs.contains(partner.id) {
                        return false
                    }
                    seenIDs.insert(partner.id)
                    return true
                }
                print("Combined Potential Chat Partners: \(potentialPartners)")

                // Entferne den aktuellen Benutzer aus der Liste
                let filteredPartners = potentialPartners.filter { partner in
                    partner.id != userID
                }
                print("Filtered Potential Chat Partners: \(filteredPartners)")

                await MainActor.run {
                    potentialChatPartners = filteredPartners
                }
            } catch {
                errorMessage = "Fehler beim Laden der Chat-Partner: \(error.localizedDescription)"
            }
        }
    }
}

#Preview {
    EmployeeView()
        .environmentObject(AuthManager())
        .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



//
//  GuestView.swift

import SwiftUI
import FirebaseFirestore

struct GuestView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var clientViewModel: ClientViewModel
    @StateObject private var contractViewModel = ContractViewModel()
    @StateObject private var transferProcessViewModel: TransferProcessViewModel
    @StateObject private var activityViewModel = ActivityViewModel()
    @State private var selectedTab = 0
    @State private var showingContactsSheet = false
    @State private var showingSearchSheet = false

    init() {
        _clientViewModel = StateObject(wrappedValue: ClientViewModel(authManager: AuthManager()))
        _transferProcessViewModel = StateObject(wrappedValue: TransferProcessViewModel(authManager: AuthManager()))
    }

    private var tabs: [(title: String, icon: String, view: AnyView)] {
        [
            ("Klienten", "person.2", AnyView(ClientListView())),
            ("Verträge", "doc.text", AnyView(ContractListView())),
            ("Vereine", "building.2", AnyView(ClubListView())),
            ("Transfers", "arrow.left.arrow.right", AnyView(TransferProcessListView(viewModel: transferProcessViewModel))), // Platzhalter ersetzt
            ("Spiele", "sportscourt", AnyView(MatchListView())),
            ("Sponsoren", "dollarsign.circle", AnyView(SponsorListView())),
            ("Funktionäre", "person.badge.key", AnyView(FunktionärListView())),
        ]
    }

    var body: some View {
        VStack(spacing: 0) {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 20) {
                    ForEach(tabs.indices, id: \.self) { index in
                        Button(action: {
                            withAnimation(.easeInOut(duration: 0.3)) {
                                selectedTab = index
                            }
                        }) {
                            Label(tabs[index].title, systemImage: tabs[index].icon)
                                .foregroundColor(selectedTab == index ? .white : .gray)
                                .padding(.vertical, 8)
                                .padding(.horizontal, 12)
                                .background(selectedTab == index ? Color.gray.opacity(0.2) : Color.clear)
                                .cornerRadius(8)
                        }
                    }
                }
                .padding(.horizontal)
            }
            .background(Color.black)

            ZStack {
                ForEach(tabs.indices, id: \.self) { index in
                    tabs[index].view
                        .environmentObject(authManager)
                        .environmentObject(clientViewModel)
                        .environmentObject(contractViewModel)
                        .environmentObject(transferProcessViewModel)
                        .environmentObject(activityViewModel)
                        .opacity(selectedTab == index ? 1 : 0)
                        .animation(.easeInOut(duration: 0.3), value: selectedTab)
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(Color.black)

            Spacer()
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: { authManager.signOut() }) {
                    Image(systemName: "rectangle.portrait.and.arrow.right")
                        .foregroundColor(.red)
                }
            }
        }
        .overlay(customBar, alignment: .bottom)
        .sheet(isPresented: $showingSearchSheet) {
            Text("Appübergreifende Suche (Platzhalter)")
                .foregroundColor(.white)
                .background(Color.black)
                .onDisappear { showingSearchSheet = false }
        }
        .sheet(isPresented: $showingContactsSheet) {
            ContactsView()
                .environmentObject(authManager)
                .onDisappear { showingContactsSheet = false }
        }
        .task {
            await contractViewModel.loadContracts()
            await transferProcessViewModel.loadTransferProcesses()
            await activityViewModel.loadActivities()
        }
    }

    private var customBar: some View {
        VStack {
            Spacer()
            HStack(spacing: 0) {
                Button(action: { withAnimation(.easeInOut(duration: 0.3)) { selectedTab = 0 } }) {
                    VStack {
                        Image(systemName: "house")
                            .font(.title2)
                        Text("Home")
                            .font(.caption)
                            .lineLimit(1)
                    }
                    .foregroundColor(selectedTab == 0 ? .white : .gray)
                    .frame(maxWidth: .infinity)
                }

                Button(action: { showingSearchSheet = true }) {
                    VStack {
                        Image(systemName: "magnifyingglass")
                            .font(.title2)
                        Text("Suche")
                            .font(.caption)
                            .lineLimit(1)
                    }
                    .foregroundColor(.gray)
                    .frame(maxWidth: .infinity)
                }

                Button(action: { withAnimation(.easeInOut(duration: 0.3)) { selectedTab = tabs.count - 1 } }) {
                    VStack {
                        Image(systemName: "bubble.left")
                            .font(.title2)
                        Text("Chat")
                            .font(.caption)
                            .lineLimit(1)
                    }
                    .foregroundColor(selectedTab == tabs.count - 1 ? .white : .gray)
                    .frame(maxWidth: .infinity)
                }

                Button(action: { showingContactsSheet = true }) {
                    VStack {
                        Image(systemName: "person.2.fill")
                            .font(.title2)
                        Text("Kontakte")
                            .font(.caption)
                            .lineLimit(1)
                    }
                    .foregroundColor(.gray)
                    .frame(maxWidth: .infinity)
                }
            }
            .frame(height: 70)
            .background(Color.black)
            .foregroundColor(.white)
        }
    }
}

#Preview {
    GuestView()
        .environmentObject(AuthManager())
}



//
//  HomeView.swift

import SwiftUI

struct HomeView: View {
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var transferProcessViewModel: TransferProcessViewModel

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                Text("Willkommen bei SportsTransfer")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding()

                Text("Bitte melde dich an, um fortzufahren.")
                    .font(.title3)
                    .foregroundColor(.gray)

                if !authManager.isLoggedIn {
                    NavigationLink(destination: LoginView()) {
                        Text("Zum Login")
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    }
                    .padding(.horizontal)
                }

                Spacer()
            }
            .background(Color.black)
            .navigationTitle("Home")
            .foregroundColor(.white)
        }
        .environmentObject(authManager)
        .environmentObject(transferProcessViewModel)
    }
}

#Preview {
    HomeView()
        .environmentObject(AuthManager())
        .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



//
//  UserSettingsView.swift

import SwiftUI
import FirebaseAuth
import FirebaseFirestore

struct UserSettingsView: View {
    @EnvironmentObject var authManager: AuthManager
    @Environment(\.colorScheme) var colorScheme
    @Binding var isPresented: Bool
    @State private var name: String = ""
    @State private var vorname: String = ""
    @State private var strasse: String = ""
    @State private var nr: String = ""
    @State private var plz: String = ""
    @State private var ort: String = ""
    @State private var land: String = ""
    @State private var telefonnummer: String = ""
    @State private var email: String = ""
    @State private var newPassword: String = ""
    @State private var currentPassword: String = "" // Für Re-Authentifizierung
    @State private var errorMessage: String = ""
    @State private var isLoading: Bool = false
    @State private var isEditing: Bool = false // Bearbeitungsmodus

    private let db = Firestore.firestore()

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Persönliche Daten")) {
                    TextField("Name", text: $name)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Vorname", text: $vorname)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Straße", text: $strasse)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Nr.", text: $nr)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("PLZ", text: $plz)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Ort", text: $ort)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Land", text: $land)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    TextField("Telefonnummer", text: $telefonnummer)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.done)
                }
                
                Section(header: Text("Kontoinformationen")) {
                    TextField("E-Mail", text: $email)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    SecureField("Neues Passwort", text: $newPassword)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.next)
                    SecureField("Aktuelles Passwort", text: $currentPassword)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .disabled(!isEditing)
                        .submitLabel(.done)
                    Button("Passwort und E-Mail ändern") {
                        updateCredentials()
                    }
                    .disabled(!isEditing || (email.isEmpty && newPassword.isEmpty) || isLoading)
                }
                
                Section {
                    Button(isEditing ? "Speichern" : "Bearbeiten") {
                        if isEditing {
                            saveUserData()
                        } else {
                            isEditing = true
                        }
                    }
                    .disabled(isLoading)
                    
                    Button("Abmelden") {
                        authManager.signOut()
                        isPresented = false
                    }
                    .foregroundColor(.red)
                }
            }
            .navigationTitle("Einstellungen")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Abbrechen") {
                        isPresented = false
                    }
                }
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler"),
                    message: Text(errorMessage),
                    dismissButton: .default(Text("OK")) { errorMessage = "" }
                )
            }
            .task {
                await loadUserData()
            }
            .overlay(
                isLoading ? ProgressView("Speichere...").progressViewStyle(CircularProgressViewStyle()) : nil
            )
        }
    }

    private func loadUserData() async {
        guard let userID = authManager.userID else { return }
        do {
            let document = try await db.collection("users").document(userID).getDocument()
            if let data = document.data() {
                await MainActor.run {
                    name = data["name"] as? String ?? ""
                    vorname = data["vorname"] as? String ?? ""
                    strasse = data["strasse"] as? String ?? ""
                    nr = data["nr"] as? String ?? ""
                    plz = data["plz"] as? String ?? ""
                    ort = data["ort"] as? String ?? ""
                    land = data["land"] as? String ?? ""
                    telefonnummer = data["telefonnummer"] as? String ?? ""
                    email = authManager.userEmail ?? ""
                }
            }
        } catch {
            errorMessage = "Fehler beim Laden der Daten: \(error.localizedDescription)"
        }
    }

    private func saveUserData() {
        guard let userID = authManager.userID else {
            errorMessage = "Kein Benutzer angemeldet"
            return
        }
        // Validierung
        if name.isEmpty || vorname.isEmpty {
            errorMessage = "Name und Vorname sind Pflichtfelder"
            return
        }
        if !email.isEmpty && !isValidEmail(email) {
            errorMessage = "Ungültiges E-Mail-Format"
            return
        }
        
        isLoading = true
        let userData: [String: Any] = [
            "name": name,
            "vorname": vorname,
            "strasse": strasse,
            "nr": nr,
            "plz": plz,
            "ort": ort,
            "land": land,
            "telefonnummer": telefonnummer,
            "email": email,
            "rolle": authManager.userRole?.rawValue ?? UserRole.gast.rawValue
        ]
        db.collection("users").document(userID).setData(userData, merge: true) { error in
            DispatchQueue.main.async {
                isLoading = false
                if let error = error {
                    self.errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                } else {
                    self.isEditing = false
                }
            }
        }
    }

    private func updateCredentials() {
        guard !currentPassword.isEmpty else {
            errorMessage = "Bitte gib dein aktuelles Passwort ein"
            return
        }
        if !email.isEmpty && !isValidEmail(email) {
            errorMessage = "Ungültiges E-Mail-Format"
            return
        }
        
        isLoading = true
        let credential = EmailAuthProvider.credential(withEmail: authManager.userEmail ?? "", password: currentPassword)
        Auth.auth().currentUser?.reauthenticate(with: credential) { result, error in
            if let error = error {
                DispatchQueue.main.async {
                    errorMessage = "Erneute Authentifizierung fehlgeschlagen: \(error.localizedDescription)"
                    isLoading = false
                }
                return
            }
            if !email.isEmpty, email != authManager.userEmail {
                authManager.updateEmail(newEmail: email) { result in
                    DispatchQueue.main.async {
                        switch result {
                        case .success:
                            if newPassword.isEmpty { isLoading = false; isEditing = false }
                        case .failure(let error):
                            errorMessage = error.localizedDescription
                            isLoading = false
                        }
                    }
                }
            }
            if !newPassword.isEmpty {
                authManager.updatePassword(newPassword: newPassword) { result in
                    DispatchQueue.main.async {
                        isLoading = false
                        switch result {
                        case .success:
                            newPassword = ""
                            currentPassword = ""
                            isEditing = false
                        case .failure(let error):
                            errorMessage = error.localizedDescription
                        }
                    }
                }
            }
        }
    }

    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let predicate = NSPredicate(format:"SELF MATCHES %@", emailRegEx)
        return predicate.evaluate(with: email)
    }
}

#Preview {
    UserSettingsView(isPresented: .constant(true))
        .environmentObject(AuthManager())
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/4. Client
//
//  AddClientView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers

struct AddClientView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var authManager: AuthManager
    @State private var typ = "Spieler"
    @State private var vorname: String = ""
    @State private var name: String = ""
    @State private var geschlecht = "männlich"
    @State private var vereinID: String? = nil
    @State private var vertragBis: Date = Date()
    @State private var vertragsOptionen: String = ""
    @State private var gehalt: String = ""
    @State private var groesse: String = ""
    @State private var nationalmannschaft: String = ""
    @State private var positionFeld: [String] = []
    @State private var schuhmarke: String = ""
    @State private var starkerFuss: String = ""
    @State private var kontaktTelefon: String = ""
    @State private var kontaktEmail: String = ""
    @State private var adresse: String = ""
    @State private var geburtsdatum: Date = Date()
    @State private var clubOptions: [Club] = []
    @State private var sponsorOptions: [Sponsor] = []
    @State private var transfermarktID: String = ""
    @State private var errorMessage: String = ""
    @State private var showingPositionPicker = false
    @State private var showingNationalityPicker = false
    @State private var selectedNationalities: [String] = []
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var profileImage: UIImage? = nil
    @State private var isUploadingImage = false
    @State private var isLoadingTransfermarkt = false
    @State private var transfermarktError = ""
    @State private var liga: String?
    @State private var konditionen: String = ""
    @State private var art: String = ""
    @State private var spielerCVData: Data? = nil
    @State private var spielerCVURL: String? = nil
    @State private var videoData: Data? = nil
    @State private var videoURL: String? = nil
    @State private var showingCVPicker = false
    @State private var showingVideoPicker = false

    var body: some View {
        NavigationView {
            Form {
                clientTypeSection
                clientDataSection
                if typ == "Spieler" || typ == "Spielerin" {
                    positionSection
                }
                contactInfoSection
                transfermarktSection
                additionalInfoSection
            }
            .navigationTitle("Neuer Klient")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        Task { await saveClient() }
                    }
                    .disabled(!isValidClient())
                }
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler"),
                    message: Text(errorMessage),
                    dismissButton: .default(Text("OK")) { errorMessage = "" }
                )
            }
            .onChange(of: selectedPhoto) { _ in
                Task { await loadSelectedImage() }
            }
            .sheet(isPresented: $showingCVPicker) {
                DocumentPicker(
                    allowedContentTypes: [.pdf, .text],
                    onPick: { url in
                        Task { await loadSpielerCV(from: url) }
                    }
                )
            }
            .sheet(isPresented: $showingVideoPicker) {
                DocumentPicker(
                    allowedContentTypes: [.movie],
                    onPick: { url in
                        Task { await loadVideo(from: url) }
                    }
                )
            }
            .task {
                await loadClubOptions()
                await loadSponsors()
            }
        }
    }

    private var clientTypeSection: some View {
        Section(header: Text("Kliententyp")) {
            Picker("Typ", selection: $typ) {
                Text("Spieler").tag("Spieler")
                Text("Spielerin").tag("Spielerin")
                Text("Trainer").tag("Trainer")
                Text("Sonstige").tag("Sonstige")
            }
            .pickerStyle(.segmented)
            Picker("Geschlecht", selection: $geschlecht) {
                Text("Männlich").tag("männlich")
                Text("Weiblich").tag("weiblich")
            }
            .pickerStyle(.segmented)
        }
    }

    private var clientDataSection: some View {
        Section(header: Text("Klientendaten")) {
            TextField("Vorname", text: $vorname)
            TextField("Name", text: $name)
            DatePicker("Geburtsdatum", selection: $geburtsdatum, displayedComponents: .date)
                .datePickerStyle(.compact)
            Picker("Verein", selection: $vereinID) {
                Text("Kein Verein").tag(String?.none)
                ForEach(clubOptions.filter { $0.abteilungForGender(geschlecht) != nil }) { club in
                    Text(club.name).tag(club.id as String?)
                }
            }
            .pickerStyle(.menu)
            .onChange(of: vereinID) { _ in updateLeagueAndAbteilung() }
            Text("Liga: \(liga ?? "Keine")")
                .foregroundColor(.gray)
            DatePicker("Vertragslaufzeit", selection: $vertragBis, displayedComponents: .date)
            TextField("Vertragsoptionen", text: $vertragsOptionen)
            TextField("Gehalt (€)", text: $gehalt)
                .keyboardType(.decimalPad)
            TextField("Größe (cm)", text: $groesse)
                .keyboardType(.numberPad)
            profileImagePicker
            nationalityPicker
            TextField("Nationalmannschaft", text: $nationalmannschaft)
        }
    }

    private var positionSection: some View {
        Section(header: Text("Positionen")) {
            Button(action: { showingPositionPicker = true }) {
                Text(positionFeld.isEmpty ? "Positionen auswählen" : positionFeld.joined(separator: ", "))
                    .foregroundColor(positionFeld.isEmpty ? .gray : .black)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .sheet(isPresented: $showingPositionPicker) {
                NavigationView {
                    MultiPicker(
                        title: "Positionen auswählen",
                        selection: $positionFeld,
                        options: Constants.positionOptions,
                        isNationalityPicker: false
                    )
                    .navigationTitle("Positionen")
                    .toolbar {
                        ToolbarItem(placement: .topBarTrailing) {
                            Button("Fertig") { showingPositionPicker = false }
                        }
                    }
                }
            }
            Picker("Schuhmarke", selection: $schuhmarke) {
                Text("Keine Marke").tag("")
                ForEach(sponsorOptions.filter { $0.category == "Sportartikelhersteller" }) { sponsor in
                    Text(sponsor.name).tag(sponsor.name)
                }
            }
            .pickerStyle(.menu)
            Picker("Starker Fuß", selection: $starkerFuss) {
                Text("Nicht angegeben").tag("")
                ForEach(Constants.strongFootOptions, id: \.self) { foot in
                    Text(foot).tag(foot)
                }
            }
            .pickerStyle(.menu)
        }
    }

    private var contactInfoSection: some View {
        Section(header: Text("Kontaktinformationen")) {
            TextField("Telefon", text: $kontaktTelefon)
            TextField("E-Mail", text: $kontaktEmail)
            TextField("Adresse", text: $adresse)
        }
    }

    private var transfermarktSection: some View {
        Section(header: Text(geschlecht == "männlich" ? "Transfermarkt" : "Soccerdonna")) {
            TextField(geschlecht == "männlich" ? "Transfermarkt-ID" : "Soccerdonna-ID", text: $transfermarktID)
                .keyboardType(.numberPad)
                .customPlaceholder(when: transfermarktID.isEmpty) {
                    Text(geschlecht == "männlich" ? "z. B. 690425" : "z. B. 31388")
                        .foregroundColor(.gray)
                }
                .onChange(of: transfermarktID) { newID in
                    if !newID.isEmpty {
                        Task {
                            await MainActor.run { isLoadingTransfermarkt = true }
                            do {
                                let playerData: PlayerData
                                if geschlecht == "männlich" {
                                    playerData = try await TransfermarktService.shared.fetchPlayerData(forPlayerID: newID)
                                } else {
                                    playerData = try await SoccerdonnaService.shared.fetchPlayerData(forPlayerID: newID)
                                }
                                await MainActor.run {
                                    isLoadingTransfermarkt = false
                                    transfermarktError = ""
                                    if vorname.isEmpty, let fullName = playerData.name {
                                        let parts = fullName.split(separator: " ")
                                        if parts.count >= 2 {
                                            vorname = String(parts[0])
                                            name = String(parts.dropFirst().joined(separator: " "))
                                        } else {
                                            name = fullName
                                        }
                                    }
                                    if positionFeld.isEmpty, let position = playerData.position {
                                        positionFeld = [position]
                                    }
                                    if selectedNationalities.isEmpty, let nationalities = playerData.nationalitaet {
                                        selectedNationalities = nationalities
                                    }
                                    if geburtsdatum == Date(), let birthdate = playerData.geburtsdatum {
                                        geburtsdatum = birthdate
                                    }
                                    if vereinID == nil, let clubID = playerData.vereinID,
                                       let club = clubOptions.first(where: { $0.name == clubID }) {
                                        vereinID = club.id
                                        updateLeagueAndAbteilung()
                                    }
                                    if vertragBis == Date(), let contractEnd = playerData.contractEnd {
                                        vertragBis = contractEnd
                                    }
                                }
                            } catch {
                                await MainActor.run {
                                    isLoadingTransfermarkt = false
                                    transfermarktError = "Fehler beim Abrufen der Daten: \(error.localizedDescription)"
                                }
                            }
                        }
                    }
                }
            if isLoadingTransfermarkt {
                ProgressView("Lade Daten...")
            }
            if !transfermarktError.isEmpty {
                Text(transfermarktError)
                    .foregroundColor(.red)
                    .font(.caption)
            }
        }
    }

    private var profileImagePicker: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Profilbild")
                .font(.subheadline)
            PhotosPicker(
                selection: $selectedPhoto,
                matching: .images,
                photoLibrary: .shared()
            ) {
                Label("Bild auswählen", systemImage: "photo")
                    .foregroundColor(.blue)
            }
            if isUploadingImage {
                ProgressView("Bild wird hochgeladen...")
            } else if let image = profileImage {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            }
        }
    }

    private var nationalityPicker: some View {
        Button(action: { showingNationalityPicker = true }) {
            Text(selectedNationalities.isEmpty ? "Nationalitäten auswählen" : selectedNationalities.joined(separator: ", "))
                .foregroundColor(selectedNationalities.isEmpty ? .gray : .black)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .sheet(isPresented: $showingNationalityPicker) {
            NavigationView {
                MultiPicker(
                    title: "Nationalitäten auswählen",
                    selection: $selectedNationalities,
                    options: Constants.nationalities,
                    isNationalityPicker: true
                )
                .navigationTitle("Nationalitäten")
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button("Fertig") { showingNationalityPicker = false }
                    }
                }
            }
        }
    }

    private var additionalInfoSection: some View {
        Section(header: Text("Zusätzliche Informationen")) {
            TextField("Konditionen", text: $konditionen)
            Picker("Art", selection: $art) {
                Text("Nicht angegeben").tag("")
                Text("Vereinswechsel").tag("Vereinswechsel")
                Text("Vertragsverlängerung").tag("Vertragsverlängerung")
            }
            .pickerStyle(.menu)
            VStack(alignment: .leading, spacing: 10) {
                Text("Spieler-CV")
                    .font(.subheadline)
                Button(action: { showingCVPicker = true }) {
                    Label("CV auswählen", systemImage: "doc")
                        .foregroundColor(.blue)
                }
                if let spielerCVURL = spielerCVURL {
                    Text("Hochgeladen: \(spielerCVURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            VStack(alignment: .leading, spacing: 10) {
                Text("Video")
                    .font(.subheadline)
                Button(action: { showingVideoPicker = true }) {
                    Label("Video auswählen", systemImage: "video")
                        .foregroundColor(.blue)
                }
                if let videoURL = videoURL {
                    Text("Hochgeladen: \(videoURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
        }
    }

    private func loadClubOptions() async {
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil as DocumentSnapshot?, limit: 1000)
            await MainActor.run {
                self.clubOptions = clubs
                updateLeagueAndAbteilung()
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)"
            }
        }
    }

    private func loadSponsors() async {
        do {
            let (sponsors, _) = try await FirestoreManager.shared.getSponsors(lastDocument: nil as DocumentSnapshot?, limit: 1000)
            await MainActor.run {
                self.sponsorOptions = sponsors
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden der Sponsoren: \(error.localizedDescription)"
                self.sponsorOptions = []
            }
        }
    }

    private func updateLeagueAndAbteilung() {
        if let vereinID = vereinID,
           let selectedClub = clubOptions.first(where: { $0.id == vereinID }) {
            let abteilung = selectedClub.abteilungForGender(geschlecht)
            if geschlecht == "männlich" {
                liga = selectedClub.mensDepartment?.league
            } else if geschlecht == "weiblich" {
                liga = selectedClub.womensDepartment?.league
            }
        } else {
            liga = nil
        }
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else { return }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.profileImage = image
                }
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)"
            }
        }
    }

    private func loadSpielerCV(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.spielerCVData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des CVs: \(error.localizedDescription)"
            }
        }
    }

    private func loadVideo(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.videoData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Videos: \(error.localizedDescription)"
            }
        }
    }

    private func saveClient() async {
        do {
            var newClient = Client(
                id: nil,
                typ: typ,
                name: name,
                vorname: vorname,
                geschlecht: geschlecht,
                abteilung: nil,
                vereinID: vereinID,
                nationalitaet: selectedNationalities.isEmpty ? nil : selectedNationalities,
                geburtsdatum: geburtsdatum,
                alter: nil,
                kontaktTelefon: kontaktTelefon.isEmpty ? nil : kontaktTelefon,
                kontaktEmail: kontaktEmail.isEmpty ? nil : kontaktEmail,
                adresse: adresse.isEmpty ? nil : adresse,
                liga: liga,
                vertragBis: vertragBis,
                vertragsOptionen: vertragsOptionen.isEmpty ? nil : vertragsOptionen,
                gehalt: Double(gehalt) ?? nil,
                schuhgroesse: nil,
                schuhmarke: schuhmarke.isEmpty ? nil : schuhmarke,
                starkerFuss: starkerFuss.isEmpty ? nil : starkerFuss,
                groesse: Int(groesse) ?? nil,
                gewicht: nil,
                positionFeld: positionFeld.isEmpty ? nil : positionFeld,
                sprachen: nil,
                lizenz: nil,
                nationalmannschaft: nationalmannschaft.isEmpty ? nil : nationalmannschaft,
                profilbildURL: nil,
                transfermarktID: transfermarktID.isEmpty ? nil : transfermarktID,
                userID: authManager.userID ?? UUID().uuidString,
                createdBy: authManager.currentUser?.email,
                konditionen: konditionen.isEmpty ? nil : konditionen,
                art: art.isEmpty ? nil : art,
                spielerCV: nil,
                video: nil
            )
            let clientID = try await FirestoreManager.shared.createClient(client: newClient)
            newClient.id = clientID
            if let image = profileImage {
                await MainActor.run { isUploadingImage = true }
                let url = try await FirestoreManager.shared.uploadImage(
                    documentID: clientID,
                    image: image,
                    collection: "profile_images"
                )
                newClient.profilbildURL = url
            }
            if let cvData = spielerCVData {
                let url = try await FirestoreManager.shared.uploadFile(
                    documentID: clientID,
                    data: cvData,
                    collection: "player_cvs",
                    fileName: "cv_\(clientID)"
                )
                newClient.spielerCV = url
            }
            if let videoData = videoData {
                let url = try await FirestoreManager.shared.uploadFile(
                    documentID: clientID,
                    data: videoData,
                    collection: "player_videos",
                    fileName: "video_\(clientID)"
                )
                newClient.video = url
            }
            try await FirestoreManager.shared.updateClient(client: newClient)
            await MainActor.run { isUploadingImage = false }
            dismiss()
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                isUploadingImage = false
            }
        }
    }

    private func isValidClient() -> Bool {
        if vorname.isEmpty || name.isEmpty {
            errorMessage = "Vorname und Name sind Pflichtfelder."
            return false
        }
        if !kontaktEmail.isEmpty && !isValidEmail(kontaktEmail) {
            errorMessage = "Ungültiges E-Mail-Format."
            return false
        }
        return true
    }

    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPred = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }
}

#Preview {
    AddClientView()
        .environmentObject(AuthManager())
}



//
//  ClientContactView.swift

import SwiftUI
import FirebaseFirestore

struct ClientContactView: View {
    @ObservedObject var authManager: AuthManager
    @Binding var isPresented: Bool
    @State private var clients: [Client] = []
    @State private var selectedClient: Client?
    @State private var searchText: String = ""
    @State private var contactType: String = "Telefon"
    @State private var contactTopic: String = "Besuch"
    @State private var notes: String = ""
    @State private var errorMessage: String = ""
    @State private var errorQueue: [String] = []
    @State private var isShowingError = false
    @Environment(\.dismiss) var dismiss

    var filteredClients: [Client] {
        if searchText.isEmpty {
            return clients
        } else {
            return clients.filter { client in
                "\(client.vorname) \(client.name)".lowercased().contains(searchText.lowercased())
            }
        }
    }

    var body: some View {
        NavigationView {
            Form {
                clientSelectionSection
                contactDetailsSection
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Klienten Kontakt")
            .foregroundColor(.white)
            .toolbar { toolbarContent }
            .task {
                await loadClients()
            }
            .alert(isPresented: $isShowingError) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        if !errorQueue.isEmpty {
                            errorMessage = errorQueue.removeFirst()
                            isShowingError = true
                        } else {
                            isShowingError = false
                        }
                    }
                )
            }
        }
    }

    // Sub-Views

    private var clientSelectionSection: some View {
        Section(header: Text("Klient auswählen").foregroundColor(.white)) {
            TextField("Suche nach Name", text: $searchText)
                .foregroundColor(.white)
            Picker("Klient", selection: $selectedClient) {
                Text("Kein Klient ausgewählt").tag(Client?.none)
                ForEach(filteredClients, id: \.self) { client in
                    Text("\(client.vorname) \(client.name)")
                        .tag(client as Client?)
                }
            }
            .pickerStyle(MenuPickerStyle())
            .foregroundColor(.white)
            .accentColor(.white)
        }
    }

    private var contactDetailsSection: some View {
        Section(header: Text("Kontaktdetails").foregroundColor(.white)) {
            Picker("Art des Kontakts", selection: $contactType) {
                ForEach(Constants.contactTypes, id: \.self) { type in
                    Text(type).tag(type)
                }
            }
            .pickerStyle(MenuPickerStyle())
            .foregroundColor(.white)
            .accentColor(.white)

            Picker("Thema", selection: $contactTopic) {
                ForEach(Constants.contactTopics, id: \.self) { topic in
                    Text(topic).tag(topic)
                }
            }
            .pickerStyle(MenuPickerStyle())
            .foregroundColor(.white)
            .accentColor(.white)

            TextField("Notizen", text: $notes, axis: .vertical)
                .lineLimit(5)
                .foregroundColor(.white)
        }
    }

    private var toolbarContent: some ToolbarContent {
        Group {
            ToolbarItem(placement: .cancellationAction) {
                Button("Abbrechen") {
                    isPresented = false
                }
                .foregroundColor(.white)
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Speichern") {
                    Task {
                        await saveContact()
                        isPresented = false
                    }
                }
                .disabled(selectedClient == nil)
                .foregroundColor(.white)
            }
        }
    }

    private func loadClients() async {
        do {
            let (loadedClients, _) = try await FirestoreManager.shared.getClients(limit: 1000)
            await MainActor.run {
                self.clients = loadedClients
                print("Geladene Klienten in ClientContactView: \(loadedClients.count), IDs: \(loadedClients.map { $0.id ?? "unbekannt" })")
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Klienten: \(error.localizedDescription)")
            }
        }
    }

    private func saveContact() async {
        guard let selectedClient = selectedClient, let employeeName = authManager.userEmail else {
            await MainActor.run {
                addErrorToQueue("Klient oder Mitarbeitername nicht verfügbar")
            }
            return
        }
        let activity = Activity(
            id: nil,
            clientID: selectedClient.id ?? UUID().uuidString,
            description: "\(contactType) - \(contactTopic): \(notes) (von \(employeeName))",
            timestamp: Date()
        )
        do {
            try await FirestoreManager.shared.createActivity(activity: activity)
            print("Kontakt erfolgreich gespeichert")
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern des Kontakts: \(error.localizedDescription)")
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }
}

#Preview {
    ClientContactView(
        authManager: AuthManager(),
        isPresented: .constant(true)
    )
}



//
//  ClientListView.swift

import SwiftUI
import FirebaseFirestore

struct ClientListView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var viewModel: ClientViewModel
    @State private var showingAddClientSheet = false
    @State private var showingFilterSheet = false
    @State private var showingEditClientSheet = false
    @State private var selectedClient: Client?
    @State private var newClient = Client(
        typ: "Spieler",
        name: "",
        vorname: "",
        geschlecht: "männlich"
    )
    @State private var clubs: [Club] = []
    @State private var errorMessage = ""
    @State private var rowOpacities: [String: CGFloat] = [:]

    init() {
        _viewModel = StateObject(wrappedValue: ClientViewModel(authManager: AuthManager()))
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                clientList
            }
            .navigationTitle("Klienten verwalten")
            .foregroundColor(.white)
            .toolbar { toolbarContent }
            .sheet(isPresented: $showingAddClientSheet) {
                AddClientView()
                    .environmentObject(authManager)
            }
            .sheet(isPresented: $showingEditClientSheet) {
                if let selectedClient = selectedClient {
                    EditClientView(
                        client: Binding(
                            get: { selectedClient },
                            set: { newValue in
                                self.selectedClient = newValue
                                viewModel.updateClientLocally(newValue)
                            }
                        ),
                        onSave: { updatedClient in
                            viewModel.updateClientLocally(updatedClient)
                            showingEditClientSheet = false
                        },
                        onCancel: {
                            showingEditClientSheet = false
                        }
                    )
                }
            }
            .sheet(isPresented: $showingFilterSheet) {
                FilterSheet(viewModel: viewModel, clubs: clubs)
                    .presentationDetents([.medium])
                    .presentationDragIndicator(.visible)
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
            .task {
                await loadClubs()
                await MainActor.run {
                    viewModel.applyFiltersAndSorting()
                }
            }
            .background(Color.black)
        }
        .environmentObject(viewModel)
    }

    private var clientList: some View {
        List {
            ForEach(viewModel.filteredClients) { client in
                NavigationLink(destination: ClientView(client: .constant(client))) {
                    clientRow(for: client)
                }
                .swipeActions {
                    Button(role: .destructive) {
                        Task {
                            await viewModel.deleteClient(client)
                        }
                    } label: {
                        Label("Löschen", systemImage: "trash")
                            .foregroundColor(.white)
                    }
                    Button(action: {
                        selectedClient = client
                        showingEditClientSheet = true
                    }) {
                        Label("Bearbeiten", systemImage: "pencil")
                            .foregroundColor(.white)
                    }
                    .tint(.blue)
                }
                .listRowBackground(
                    RoundedRectangle(cornerRadius: 10)
                        .fill(Color.black)
                        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                        .padding(.vertical, 0)
                )
                .listRowSeparator(.hidden)
                .listRowInsets(EdgeInsets(top: 3, leading: 13, bottom: 3, trailing: 13))
                .opacity(rowOpacities[client.id ?? ""] ?? 0)
                .onAppear {
                    withAnimation(.easeInOut(duration: 0.5).delay(Double(viewModel.filteredClients.firstIndex(where: { $0.id == client.id }) ?? 0) * 0.1)) {
                        rowOpacities[client.id ?? ""] = 1.0
                    }
                }
            }
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .tint(.white)
                    .listRowBackground(Color.black)
                    .listRowInsets(EdgeInsets(top: 0, leading: 10, bottom: 0, trailing: 10))
            }
        }
        .listStyle(PlainListStyle())
        .scrollContentBackground(.hidden)
        .background(Color.black)
        .padding(.horizontal)
    }

    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            HStack(spacing: 15) {
                Button(action: { showingFilterSheet = true }) {
                    Image(systemName: "line.3.horizontal.decrease.circle")
                        .foregroundColor(.white)
                }
                Button(action: { showingAddClientSheet = true }) {
                    Image(systemName: "plus")
                        .foregroundColor(.white)
                }
            }
        }
    }

    @ViewBuilder
    private func clientRow(for client: Client) -> some View {
        VStack(spacing: 0) {
            Rectangle()
                .fill(Color.white.opacity(0.5))
                .frame(height: 0.5)
                .padding(.bottom, 5)

            HStack(spacing: 12) {
                clubLogoView(for: client)
                clientProfileView(for: client)
                VStack(alignment: .leading, spacing: 2) {
                    Text("\(client.vorname) \(client.name)")
                        .font(.system(size: 14, weight: .bold, design: .rounded))
                        .foregroundColor(.white)

                    VStack(alignment: .leading, spacing: 1) {
                        if let geburtsdatum = client.geburtsdatum {
                            let age = Calendar.current.dateComponents([.year], from: geburtsdatum, to: Date()).year ?? 0
                            Text("\(dateFormatter.string(from: geburtsdatum)) (\(age))")
                                .font(.caption)
                                .foregroundColor(.white)
                        } else {
                            Text("Geburtsdatum unbekannt")
                                .font(.caption)
                                .foregroundColor(.gray.opacity(0.5))
                        }

                        if let liga = client.liga {
                            Text(liga)
                                .font(.caption)
                                .foregroundColor(.white)
                        }
                    }
                }

                Spacer()

                Text(client.typ == "Spieler" ? "♂" : "♀")
                    .font(.system(size: 16))
                    .foregroundColor(client.typ == "Spieler" ? .blue : .pink)
            }
            .padding(.vertical, 0)
            .padding(.horizontal, 12)
        }
    }

    @ViewBuilder
    private func clubLogoView(for client: Client) -> some View {
        if let vereinID = client.vereinID,
           let club = clubs.first(where: { $0.id == vereinID }),
           let logoURL = club.sharedInfo?.logoURL,
           let url = URL(string: logoURL) {
            AsyncImage(url: url) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .scaledToFit()
                        .frame(width: 40, height: 40)
                        .clipShape(Circle())
                case .failure, .empty:
                    Image(systemName: "building.fill")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 40, height: 40)
                        .foregroundColor(.gray)
                        .clipShape(Circle())
                @unknown default:
                    Image(systemName: "building.fill")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 40, height: 40)
                        .foregroundColor(.gray)
                        .clipShape(Circle())
                }
            }
        } else {
            Image(systemName: "building.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 40, height: 40)
                .foregroundColor(.gray)
                .clipShape(Circle())
        }
    }

    @ViewBuilder
    private func clientProfileView(for client: Client) -> some View {
        if let profilbildURL = client.profilbildURL,
           let url = URL(string: profilbildURL) {
            AsyncImage(url: url) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .scaledToFill()
                        .frame(width: 60, height: 60)
                        .clipShape(Circle())
                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                case .failure, .empty:
                    Image(systemName: "person.circle.fill")
                        .resizable()
                        .scaledToFill()
                        .frame(width: 60, height: 60)
                        .foregroundColor(.gray)
                        .clipShape(Circle())
                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                @unknown default:
                    Image(systemName: "person.circle.fill")
                        .resizable()
                        .scaledToFill()
                        .frame(width: 60, height: 60)
                        .foregroundColor(.gray)
                        .clipShape(Circle())
                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                }
            }
        } else {
            Image(systemName: "person.circle.fill")
                .resizable()
                .scaledToFill()
                .frame(width: 60, height: 60)
                .foregroundColor(.gray)
                .clipShape(Circle())
                .overlay(Circle().stroke(Color.gray, lineWidth: 1))
        }
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    private func loadClubs() async {
        do {
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                clubs = loadedClubs
            }
        } catch {
            errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)"
        }
    }

    private func resetNewClient() {
        newClient = Client(
            typ: "Spieler",
            name: "",
            vorname: "",
            geschlecht: "männlich"
        )
    }
}

struct FilterSheet: View {
    @ObservedObject var viewModel: ClientViewModel
    let clubs: [Club]
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationStack {
            Form {
                Section(header: Text("Filter").font(.headline).foregroundColor(.white)) {
                    Picker("Verein", selection: $viewModel.filterClub) {
                        Text("Alle").tag(String?.none)
                        ForEach(clubs.map { $0.name }.sorted(), id: \.self) { club in
                            Text(club).tag(String?.some(club))
                        }
                    }
                    .foregroundColor(.white)
                    .accentColor(.white)
                    Picker("Geschlecht", selection: $viewModel.filterGender) {
                        Text("Alle").tag(String?.none)
                        Text("Männlich").tag(String?.some("männlich"))
                        Text("Weiblich").tag(String?.some("weiblich"))
                    }
                    .foregroundColor(.white)
                    .accentColor(.white)
                    Picker("Typ", selection: $viewModel.filterType) {
                        Text("Alle").tag(String?.none)
                        Text("Spieler").tag(String?.some("Spieler"))
                        Text("Spielerin").tag(String?.some("Spielerin"))
                        Text("Trainer").tag(String?.some("Trainer"))
                        Text("Co-Trainer").tag(String?.some("Co-Trainer"))
                    }
                    .foregroundColor(.white)
                    .accentColor(.white)
                }
                Section(header: Text("Sortierung").font(.headline).foregroundColor(.white)) {
                    Picker("Sortieren nach", selection: $viewModel.sortOption) {
                        ForEach(Constants.SortOption.allCases, id: \.self) { option in
                            Text(option.rawValue).tag(option)
                        }
                    }
                    .foregroundColor(.white)
                    .accentColor(.white)
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Filter")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Fertig") {
                        viewModel.applyFiltersAndSorting()
                        dismiss()
                    }
                    .foregroundColor(.white)
                }
            }
        }
    }
}

#Preview {
    ClientListView()
        .environmentObject(AuthManager())
}



//
//  ClientView.swift

import SwiftUI
import FirebaseAuth
import FirebaseFirestore
import FirebaseStorage
import UIKit

struct ClientView: View {
    @EnvironmentObject var authManager: AuthManager
    @Binding var client: Client
    @StateObject private var viewModel: ClientViewModel
    @StateObject private var contractViewModel = ContractViewModel()
    @State private var showingImagePicker = false
    @State private var showingEditSheet = false
    @State private var showingCreateLoginSheet = false
    @State private var loginEmail = ""
    @State private var loginPassword = ""
    @State private var selectedTab: Int = 0
    @State private var activities: [Activity] = []
    @State private var isLoadingContracts = true
    @State private var errorMessage: String = ""
    @State private var errorQueue: [String] = []
    @State private var isShowingError = false
    @State private var clubName: String? = nil
    @State private var clubLogoURL: String? = nil

    var previousClientAction: (() -> Void)?
    var nextClientAction: (() -> Void)?

    init(client: Binding<Client>) {
        self._client = client
        self._viewModel = StateObject(wrappedValue: ClientViewModel(authManager: AuthManager()))
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    private var detailsTab: some View {
        Form {
            Section(header: Text("Spieldaten").foregroundColor(.white)) {
                labeledField(label: "Positionen", value: client.positionFeld?.joined(separator: ", "))
                labeledField(label: "Nationalmannschaft", value: client.nationalmannschaft)
                labeledField(label: "Größe", value: client.groesse.map { "\($0) cm" })
                labeledField(label: "Starker Fuß", value: client.starkerFuss)
            }
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    private var contractTab: some View {
        VStack(spacing: 20) {
            Section(header: Text("Vertragsübersicht")
                .font(.headline)
                .foregroundColor(.white)
                .padding(.top)) {
                if isLoadingContracts {
                    ProgressView("Lade Verträge...")
                        .tint(.white)
                } else if let contract = contractViewModel.contracts.first(where: { $0.clientID == client.id }) {
                    NavigationLink(destination: ContractDetailView(contract: contract)) {
                        VStack(alignment: .leading, spacing: 5) {
                            Text("Verein: \(contract.vereinID ?? "Kein Verein")")
                                .font(.subheadline)
                                .foregroundColor(.white)
                            Text("Start: \(dateFormatter.string(from: contract.startDatum))")
                                .font(.subheadline)
                                .foregroundColor(.white)
                            if let endDatum = contract.endDatum {
                                Text("Ende: \(dateFormatter.string(from: endDatum))")
                                    .font(.caption)
                                    .foregroundColor(.red)
                            }
                            if let gehalt = contract.gehalt {
                                Text("Gehalt: \(gehalt) €")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            labeledField(label: "Vertragsoptionen", value: contract.vertragsdetails)
                        }
                        .padding()
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(10)
                    }
                } else {
                    Text("Kein Vertrag vorhanden.")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding()
        .background(Color.black)
    }

    private var contactTab: some View {
        Form {
            Section(header: Text("Kontaktdaten").foregroundColor(.white)) {
                if let phone = client.kontaktTelefon {
                    HStack {
                        labeledField(label: "Telefon", value: phone)
                        Spacer()
                        Button(action: { openURL("tel:\(phone)") }) {
                            Image(systemName: "phone.fill")
                                .foregroundColor(.white)
                        }
                    }
                }
                if let email = client.kontaktEmail {
                    HStack {
                        labeledField(label: "E-Mail", value: email)
                        Spacer()
                        Button(action: { openURL("mailto:\(email)") }) {
                            Image(systemName: "envelope.fill")
                                .foregroundColor(.white)
                        }
                    }
                }
                labeledField(label: "Adresse", value: client.adresse)
            }
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    private var activitiesTab: some View {
        VStack(spacing: 20) {
            Section(header: Text("Aktivitäten")
                .font(.headline)
                .foregroundColor(.white)
                .padding(.top)) {
                if activities.isEmpty {
                    Text("Keine Aktivitäten vorhanden.")
                        .foregroundColor(.gray)
                } else {
                    ForEach(activities) { activity in
                        NavigationLink(destination: ActivityDetailView(activity: activity)) {
                            VStack(alignment: .leading, spacing: 5) {
                                Text(activity.description)
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                                    .lineLimit(1)
                                Text(dateFormatter.string(from: activity.timestamp))
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            .padding()
                            .background(Color.gray.opacity(0.2))
                            .cornerRadius(10)
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color.black)
    }

    private func labeledField(label: String, value: String?) -> some View {
        HStack {
            Text(label)
                .font(.subheadline)
                .foregroundColor(.gray)
            Spacer()
            Text(value ?? "Nicht angegeben")
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(value != nil ? Color.gray.opacity(0.2) : Color.clear)
                .cornerRadius(4)
                .foregroundColor(.white)
        }
    }

    private var genderSymbol: String {
        switch client.typ {
        case "Spieler": return "♂"
        case "Spielerin": return "♀"
        default: return ""
        }
    }

    private func calculateAge() -> Int? {
        guard let birthDate = client.geburtsdatum else { return nil }
        let calendar = Calendar.current
        let now = Date()
        let ageComponents = calendar.dateComponents([.year], from: birthDate, to: now)
        return ageComponents.year
    }

    private func openURL(_ urlString: String) {
        if let url = URL(string: urlString), UIApplication.shared.canOpenURL(url) {
            UIApplication.shared.open(url, options: [:], completionHandler: nil)
        }
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 15) {
                    VStack(spacing: 10) {
                        if let urlString = client.profilbildURL, let url = URL(string: urlString) {
                            AsyncImage(url: url) { phase in
                                switch phase {
                                case .success(let image):
                                    image
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 100, height: 100)
                                        .clipShape(Circle())
                                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                                case .failure, .empty:
                                    Image(systemName: "person.circle.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 100, height: 100)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                                @unknown default:
                                    Image(systemName: "person.circle.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 100, height: 100)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                        .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                                }
                            }
                        } else {
                            Image(systemName: "person.circle.fill")
                                .resizable()
                                .scaledToFit()
                                .frame(width: 100, height: 100)
                                .foregroundColor(.gray)
                                .clipShape(Circle())
                                .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                        }

                        Button(action: { showingImagePicker = true }) {
                            Image(systemName: "arrow.up.circle")
                                .font(.system(size: 24))
                                .foregroundColor(.white)
                                .opacity(0.6)
                        }
                        .sheet(isPresented: $showingImagePicker) {
                            ImagePicker(selectedImage: .constant(nil), isPresented: $showingImagePicker) { selectedImage in
                                Task {
                                    if let clientID = client.id {
                                        do {
                                            let url = try await FirestoreManager.shared.uploadImage(
                                                documentID: clientID,
                                                image: selectedImage,
                                                collection: "profile_images"
                                            )
                                            client.profilbildURL = url
                                            await viewModel.saveClient(client)
                                        } catch {
                                            addErrorToQueue("Fehler beim Hochladen des Bildes: \(error.localizedDescription)")
                                        }
                                    }
                                }
                            }
                        }

                        Text("\(client.vorname) \(client.name)\(calculateAge().map { ", \($0) Jahre" } ?? "")")
                            .font(.title2)
                            .bold()
                            .multilineTextAlignment(.center)
                            .foregroundColor(.white)

                        HStack(spacing: 10) {
                            if let logoURL = clubLogoURL, let url = URL(string: logoURL) {
                                AsyncImage(url: url) { phase in
                                    switch phase {
                                    case .success(let image):
                                        image
                                            .resizable()
                                            .scaledToFit()
                                            .frame(width: 20, height: 20)
                                            .clipShape(Circle())
                                    case .failure, .empty:
                                        Image(systemName: "building.fill")
                                            .resizable()
                                            .scaledToFit()
                                            .frame(width: 20, height: 20)
                                            .foregroundColor(.gray)
                                            .clipShape(Circle())
                                    @unknown default:
                                        Image(systemName: "building.fill")
                                            .resizable()
                                            .scaledToFit()
                                            .frame(width: 20, height: 20)
                                            .foregroundColor(.gray)
                                            .clipShape(Circle())
                                    }
                                }
                            } else {
                                Image(systemName: "building.fill")
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 20, height: 20)
                                    .foregroundColor(.gray)
                                    .clipShape(Circle())
                            }
                            Text(clubName ?? "Kein Verein")
                                .font(.headline)
                                .foregroundColor(.white)
                        }

                        if let abteilung = client.abteilung {
                            Text("Abteilung: \(abteilung)")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }

                        if let vertragBis = client.vertragBis {
                            Text("Vertragslaufzeit: \(dateFormatter.string(from: vertragBis))")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        if let vertragsOptionen = client.vertragsOptionen {
                            Text("Vertragsoptionen: \(vertragsOptionen)")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                    }
                    .padding()

                    TabView(selection: $selectedTab) {
                        detailsTab.tag(0)
                        contractTab.tag(1)
                        contactTab.tag(2)
                        activitiesTab.tag(3)
                    }
                    .frame(height: 300)
                    .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))

                    Picker("Abschnitt", selection: $selectedTab) {
                        Text("Details").tag(0)
                        Text("Vertrag").tag(1)
                        Text("Kontaktdaten").tag(2)
                        Text("Aktivitäten").tag(3)
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    .foregroundColor(.white)
                    .accentColor(.white)
                    .padding()

                    if client.userID == nil {
                        Button(action: { showingCreateLoginSheet = true }) {
                            Text("Klienten-Login erstellen")
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.blue)
                                .foregroundColor(.white)
                                .cornerRadius(10)
                        }
                        .padding()
                    } else {
                        Text("Klienten-Login bereits erstellt (UserID: \(client.userID!))")
                            .foregroundColor(.green)
                            .padding()
                    }
                }
                .background(Color.black)
                .navigationTitle("\(client.vorname) \(client.name)")
                .navigationBarTitleDisplayMode(.inline)
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .navigationBarLeading) {
                        HStack {
                            if let previous = previousClientAction {
                                Button(action: previous) {
                                    Image(systemName: "chevron.left")
                                        .foregroundColor(.white)
                                }
                            }
                            if let next = nextClientAction {
                                Button(action: next) {
                                    Image(systemName: "chevron.right")
                                        .foregroundColor(.white)
                                }
                            }
                        }
                    }
                    ToolbarItem(placement: .navigationBarTrailing) {
                        HStack {
                            Text(genderSymbol)
                                .font(.system(size: 14))
                                .foregroundColor(client.typ == "Spieler" ? .blue : .pink)
                            Button(action: { showingEditSheet = true }) {
                                Image(systemName: "pencil")
                                    .foregroundColor(.white)
                            }
                        }
                    }
                }
                .sheet(isPresented: $showingEditSheet) {
                    EditClientView(
                        client: $client,
                        onSave: { updatedClient in
                            Task {
                                print("ClientView - Client zum Speichern: \(updatedClient)")
                                await viewModel.saveClient(updatedClient)
                                await MainActor.run {
                                    client = updatedClient
                                    print("ClientView - Client nach Update: \(client)")
                                    showingEditSheet = false
                                }
                                await loadContracts()
                                await loadClubDetails()
                            }
                        },
                        onCancel: { showingEditSheet = false }
                    )
                }
                .sheet(isPresented: $showingCreateLoginSheet) {
                    CreateClientLoginView(
                        email: $loginEmail,
                        password: $loginPassword,
                        onSave: {
                            guard !loginEmail.isEmpty, !loginPassword.isEmpty else {
                                addErrorToQueue("E-Mail und Passwort dürfen nicht leer sein.")
                                return
                            }
                            guard let clientID = client.id else {
                                addErrorToQueue("Klienten-ID nicht verfügbar.")
                                return
                            }
                            Task { await createClientLogin(email: loginEmail, password: loginPassword, clientID: clientID) }
                        },
                        onCancel: {
                            showingCreateLoginSheet = false
                            loginEmail = ""
                            loginPassword = ""
                        }
                    )
                }
                .alert(isPresented: $isShowingError) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) {
                            if !errorQueue.isEmpty {
                                errorMessage = errorQueue.removeFirst()
                                isShowingError = true
                            } else {
                                isShowingError = false
                            }
                        }
                    )
                }
                .task {
                    await loadContracts()
                    await loadActivities()
                    await loadClubDetails()
                }
            }
        }
    }

    private func loadContracts() async {
        guard let clientID = client.id else { return }
        do {
            let (loadedContracts, _) = try await FirestoreManager.shared.getContracts(lastDocument: nil, limit: 1000)
            await MainActor.run {
                contractViewModel.contracts = loadedContracts.filter { $0.clientID == clientID }
                if let contract = contractViewModel.contracts.first {
                    client.vertragBis = contract.endDatum
                    client.vertragsOptionen = contract.vertragsdetails
                } else {
                    client.vertragBis = nil
                    client.vertragsOptionen = nil
                }
                isLoadingContracts = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Verträge: \(error.localizedDescription)")
            }
        }
    }

    private func loadActivities() async {
        guard let clientID = client.id else {
            addErrorToQueue("Klienten-ID nicht verfügbar.")
            return
        }
        do {
            let loadedActivities = try await FirestoreManager.shared.getActivities(forClientID: clientID)
            await MainActor.run {
                activities = loadedActivities
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Aktivitäten: \(error.localizedDescription)")
            }
        }
    }

    private func loadClubDetails() async {
        guard let vereinID = client.vereinID else {
            await MainActor.run {
                clubName = nil
                clubLogoURL = nil
            }
            return
        }
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            if let club = clubs.first(where: { $0.id == vereinID }) {
                await MainActor.run {
                    clubName = club.name
                    clubLogoURL = club.sharedInfo?.logoURL
                }
            } else {
                await MainActor.run {
                    clubName = nil
                    clubLogoURL = nil
                }
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Vereinsdetails: \(error.localizedDescription)")
                clubName = nil
                clubLogoURL = nil
            }
        }
    }

    private func createClientLogin(email: String, password: String, clientID: String) async {
        print("Erstelle Klienten-Login für ClientID: \(clientID) mit E-Mail: \(email)")
        guard let userID = client.userID else {
            await MainActor.run {
                addErrorToQueue("Keine userID für den Klienten vorhanden.")
            }
            return
        }
        authManager.createClientLogin(email: email, password: password, clientID: clientID, userID: userID) { result in
            Task {
                switch result {
                case .success:
                    print("Klienten-Login erfolgreich erstellt. UserID: \(userID)")
                    await MainActor.run {
                        showingCreateLoginSheet = false
                        loginEmail = ""
                        loginPassword = ""
                    }
                case .failure(let error):
                    print("Fehler beim Erstellen des Klienten-Logins: \(error.localizedDescription)")
                    await MainActor.run {
                        addErrorToQueue("Fehler beim Erstellen des Logins: \(error.localizedDescription)")
                    }
                }
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    struct CreateClientLoginView: View {
        @Binding var email: String
        @Binding var password: String
        let onSave: () -> Void
        let onCancel: () -> Void

        var body: some View {
            NavigationView {
                Form {
                    Section(header: Text("Klienten-Login erstellen").foregroundColor(.white)) {
                        TextField("E-Mail", text: $email)
                            .autocapitalization(.none)
                            .keyboardType(.emailAddress)
                            .foregroundColor(.white)
                        SecureField("Passwort", text: $password)
                            .autocapitalization(.none)
                            .foregroundColor(.white)
                    }
                }
                .scrollContentBackground(.hidden)
                .background(Color.black)
                .navigationTitle("Login erstellen")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("Abbrechen") { onCancel() }
                            .foregroundColor(.white)
                    }
                    ToolbarItem(placement: .confirmationAction) {
                        Button("Erstellen") { onSave() }
                            .foregroundColor(.white)
                    }
                }
            }
        }
    }

    struct ImagePicker: UIViewControllerRepresentable {
        @Binding var selectedImage: UIImage?
        @Binding var isPresented: Bool
        var onImageSelected: (UIImage) -> Void

        func makeUIViewController(context: Context) -> UIImagePickerController {
            let picker = UIImagePickerController()
            picker.delegate = context.coordinator
            picker.sourceType = .photoLibrary
            return picker
        }

        func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}

        func makeCoordinator() -> Coordinator {
            Coordinator(self)
        }

        class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
            let parent: ImagePicker

            init(_ parent: ImagePicker) {
                self.parent = parent
            }

            func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
                if let uiImage = info[.originalImage] as? UIImage {
                    parent.selectedImage = uiImage
                    parent.onImageSelected(uiImage)
                }
                parent.isPresented = false
            }

            func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
                parent.isPresented = false
            }
        }
    }
}

#Preview {
    ClientView(client: .constant(Client(
        id: "1",
        typ: "Spieler",
        name: "Müller",
        vorname: "Thomas",
        geschlecht: "männlich",
        abteilung: "Männer",
        vereinID: "Bayern Munich",
        nationalitaet: ["Deutschland"],
        geburtsdatum: Date().addingTimeInterval(-25 * 365 * 24 * 60 * 60)
    )))
    .environmentObject(AuthManager())
}



//
//  ClientViewModel.swift

import SwiftUI
import FirebaseFirestore

class ClientViewModel: ObservableObject {
    @Published var clients: [Client] = []
    @Published var filteredClients: [Client] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = []
    @Published var isShowingError = false
    @Published var isLoading: Bool = false

    @Published var filterClub: String? = nil
    @Published var filterGender: String? = nil
    @Published var filterType: String? = nil
    @Published var sortOption: Constants.SortOption = .nameAscending

    private var listener: ListenerRegistration?
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20
    private let authManager: AuthManager

    init(authManager: AuthManager) {
        self.authManager = authManager
        setupRealtimeListener()
    }

    deinit {
        listener?.remove()
    }

    private func setupRealtimeListener() {
        var query: Query = Firestore.firestore().collection("clients").order(by: "name")

        if authManager.userRole == .klient, let userID = authManager.userID {
            query = query.whereField("userID", isEqualTo: userID)
        }

        listener = query.addSnapshotListener { [weak self] snapshot, error in
            guard let self = self else { return }
            if let error = error {
                self.addErrorToQueue("Fehler beim Listener: \(error.localizedDescription)")
                print("Listener-Fehler: \(error.localizedDescription)")
                return
            }
            guard let documents = snapshot?.documents else {
                print("Keine Dokumente gefunden")
                return
            }
            print("Anzahl der Dokumente: \(documents.count)")
            let updatedClients = documents.compactMap { doc -> Client? in
                do {
                    var client = try doc.data(as: Client.self)
                    client.id = doc.documentID
                    print("Geladener Klient - ID: \(client.id ?? "nil"), Name: \(client.vorname) \(client.name)")
                    return client
                } catch {
                    print("Fehler beim Dekodieren des Klienten \(doc.documentID): \(error)")
                    print("Rohdaten des Dokuments: \(doc.data())")
                    return nil
                }
            }
            DispatchQueue.main.async {
                let uniqueClients = Dictionary(uniqueKeysWithValues: updatedClients.map { ($0.id ?? UUID().uuidString, $0) }).values
                print("Aktualisierte Klienten: \(updatedClients.map { "\($0.id ?? "nil"): \($0.vorname) \($0.name)" })")
                self.clients = Array(uniqueClients)
                self.applyFiltersAndSorting()
                self.isLoading = false
            }
        }
    }

    func loadClients(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newClients, newLastDoc): ([Client], QueryDocumentSnapshot?)
            if authManager.userRole == .mitarbeiter {
                (newClients, newLastDoc) = try await FirestoreManager.shared.getAllClients(
                    lastDocument: loadMore ? lastDocument : nil,
                    limit: pageSize
                )
            } else if let userID = authManager.userID {
                (newClients, newLastDoc) = try await FirestoreManager.shared.getClients(
                    forUserID: userID,
                    lastDocument: loadMore ? lastDocument : nil,
                    limit: pageSize
                )
            } else {
                throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Benutzer-ID nicht verfügbar"])
            }
            await MainActor.run {
                if loadMore {
                    clients.append(contentsOf: newClients)
                } else {
                    clients = newClients
                }
                lastDocument = newLastDoc
                isLoading = false
                applyFiltersAndSorting()
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }
    }

    func loadClients(userID: String, loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (loadedClients, newLastDoc) = try await FirestoreManager.shared.getClients(
                forUserID: userID,
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore {
                    clients.append(contentsOf: loadedClients)
                } else {
                    clients = loadedClients
                }
                lastDocument = newLastDoc
                isLoading = false
                applyFiltersAndSorting()
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }

    func saveClient(_ client: Client) async {
        do {
            print("ClientViewModel - Client zum Speichern: \(client)")
            if client.id != nil {
                try await FirestoreManager.shared.updateClient(client: client)
                print("ClientViewModel - Client erfolgreich aktualisiert in Firestore")
            } else {
                let newClientID = try await FirestoreManager.shared.createClient(client: client)
                var updatedClient = client
                updatedClient.id = newClientID
                print("ClientViewModel - Neuer Client erstellt in Firestore mit ID: \(newClientID)")
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
                print("ClientViewModel - Fehler beim Speichern: \(error)")
            }
        }
    }

    func deleteClient(_ client: Client) async {
        guard let id = client.id else {
            await MainActor.run {
                addErrorToQueue("Keine Klienten-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteClient(clientID: id)
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    func updateClientLocally(_ updatedClient: Client) {
        if let index = clients.firstIndex(where: { $0.id == updatedClient.id }) {
            DispatchQueue.main.async {
                self.clients[index] = updatedClient
                self.applyFiltersAndSorting()
                print("ClientViewModel - Client lokal aktualisiert: \(updatedClient)")
            }
            Task {
                do {
                    try await FirestoreManager.shared.updateClient(client: updatedClient)
                    print("ClientViewModel - Client erfolgreich aktualisiert in Firestore")
                } catch {
                    self.addErrorToQueue("Fehler beim Aktualisieren in Firestore: \(error.localizedDescription)")
                }
            }
        }
    }

    func activeClientsByClub() -> [String: Int] {
        var clientsByClub: [String: Int] = [:]
        for client in clients {
            if let vereinID = client.vereinID {
                clientsByClub[vereinID, default: 0] += 1
            }
        }
        return clientsByClub
    }

    func applyFiltersAndSorting() {
        var result = clients

        if let club = filterClub {
            result = result.filter { $0.vereinID == club }
        }
        if let gender = filterGender {
            result = result.filter { $0.geschlecht == gender }
        }
        if let type = filterType {
            result = result.filter { $0.typ == type }
        }

        switch sortOption {
        case .nameAscending:
            result.sort { ($0.vorname + $0.name) < ($1.vorname + $1.name) }
        case .nameDescending:
            result.sort { ($0.vorname + $0.name) > ($1.vorname + $1.name) }
        case .birthDateAscending:
            result.sort {
                guard let date1 = $0.geburtsdatum, let date2 = $1.geburtsdatum else { return false }
                return date1 < date2
            }
        case .birthDateDescending:
            result.sort {
                guard let date1 = $0.geburtsdatum, let date2 = $1.geburtsdatum else { return false }
                return date1 > date2
            }
        default:
            result.sort { ($0.vorname + $0.name) < ($1.vorname + $1.name) }
        }

        filteredClients = result
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



//
//  EditClientView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers

struct EditClientView: View {
    @Binding var client: Client
    var onSave: (Client) -> Void
    var onCancel: () -> Void
    @EnvironmentObject var authManager: AuthManager

    @State private var showingPositionPicker = false
    @State private var showingNationalityPicker = false
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var profileImage: UIImage? = nil
    @State private var isUploadingImage = false
    @State private var isLoadingTransfermarkt = false
    @State private var transfermarktError = ""
    @State private var clubOptions: [Club] = []
    @State private var sponsorOptions: [Sponsor] = []
    @State private var errorMessage: String = ""
    @StateObject private var contractViewModel = ContractViewModel()
    @State private var isLoadingClubs = true

    @State private var name: String
    @State private var vorname: String
    @State private var vereinID: String?
    @State private var abteilung: String?
    @State private var geburtsdatum: Date?
    @State private var vertragBis: Date?
    @State private var vertragsOptionen: String?
    @State private var gehalt: Double?
    @State private var groesse: Int?
    @State private var selectedNationalities: [String]
    @State private var nationalmannschaft: String?
    @State private var selectedPositions: [String]
    @State private var schuhmarke: String?
    @State private var starkerFuss: String?
    @State private var kontaktTelefon: String?
    @State private var kontaktEmail: String?
    @State private var adresse: String?
    @State private var transfermarktID: String?
    @State private var liga: String?
    @State private var imageURL: String = ""
    @State private var konditionen: String?
    @State private var art: String?
    @State private var spielerCVData: Data? = nil
    @State private var spielerCVURL: String?
    @State private var videoData: Data? = nil
    @State private var videoURL: String?
    @State private var showingCVPicker = false
    @State private var showingVideoPicker = false

    init(client: Binding<Client>, onSave: @escaping (Client) -> Void, onCancel: @escaping () -> Void) {
        self._client = client
        self.onSave = onSave
        self.onCancel = onCancel
        
        let wrappedClient = client.wrappedValue
        _name = State(initialValue: wrappedClient.name)
        _vorname = State(initialValue: wrappedClient.vorname)
        _vereinID = State(initialValue: wrappedClient.vereinID)
        _abteilung = State(initialValue: wrappedClient.abteilung)
        _geburtsdatum = State(initialValue: wrappedClient.geburtsdatum)
        _vertragBis = State(initialValue: wrappedClient.vertragBis)
        _vertragsOptionen = State(initialValue: wrappedClient.vertragsOptionen)
        _gehalt = State(initialValue: wrappedClient.gehalt)
        _groesse = State(initialValue: wrappedClient.groesse)
        _selectedNationalities = State(initialValue: wrappedClient.nationalitaet ?? [])
        _nationalmannschaft = State(initialValue: wrappedClient.nationalmannschaft)
        _selectedPositions = State(initialValue: wrappedClient.positionFeld ?? [])
        _schuhmarke = State(initialValue: wrappedClient.schuhmarke)
        _starkerFuss = State(initialValue: wrappedClient.starkerFuss)
        _kontaktTelefon = State(initialValue: wrappedClient.kontaktTelefon)
        _kontaktEmail = State(initialValue: wrappedClient.kontaktEmail)
        _adresse = State(initialValue: wrappedClient.adresse)
        _transfermarktID = State(initialValue: wrappedClient.transfermarktID)
        _liga = State(initialValue: wrappedClient.liga)
        _konditionen = State(initialValue: wrappedClient.konditionen)
        _art = State(initialValue: wrappedClient.art)
        _spielerCVURL = State(initialValue: wrappedClient.spielerCV)
        _videoURL = State(initialValue: wrappedClient.video)
    }

    var body: some View {
        NavigationView {
            Form {
                clientDataSection
                if client.typ == "Spieler" || client.typ == "Spielerin" {
                    positionSection
                }
                contactInfoSection
                transfermarktSection
                additionalInfoSection
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Profil bearbeiten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { onCancel() }
                        .foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        let updatedClient = createUpdatedClient()
                        print("EditClientView - Client vor dem Speichern: \(updatedClient)")
                        print("EditClientView - ProfileImage vor dem Speichern: \(profileImage != nil ? "Bild vorhanden" : "Kein Bild")")
                        print("EditClientView - ImageURL vor dem Speichern: \(imageURL)")
                        Task { await saveClient(updatedClient: updatedClient) }
                    }
                    .disabled(!isValidClient())
                    .foregroundColor(.white)
                }
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
                )
            }
            .onChange(of: selectedPhoto) { newValue in
                print("EditClientView - SelectedPhoto geändert: \(newValue != nil ? "Foto ausgewählt" : "Kein Foto")")
                Task { await loadSelectedImage() }
            }
            .onChange(of: vereinID) { _ in
                Task { await updateLeagueAndAbteilung() }
            }
            .sheet(isPresented: $showingCVPicker) {
                DocumentPicker(
                    allowedContentTypes: [.pdf, .text],
                    onPick: { url in
                        Task { await loadSpielerCV(from: url) }
                    }
                )
            }
            .sheet(isPresented: $showingVideoPicker) {
                DocumentPicker(
                    allowedContentTypes: [.movie],
                    onPick: { url in
                        Task { await loadVideo(from: url) }
                    }
                )
            }
            .task {
                await loadClubOptions()
                await loadSponsors()
                await loadContractData()
            }
        }
    }

    private func createUpdatedClient() -> Client {
        Client(
            id: client.id,
            typ: client.typ,
            name: name,
            vorname: vorname,
            geschlecht: client.geschlecht,
            abteilung: abteilung,
            vereinID: vereinID,
            nationalitaet: selectedNationalities.isEmpty ? nil : selectedNationalities,
            geburtsdatum: geburtsdatum,
            kontaktTelefon: kontaktTelefon,
            kontaktEmail: kontaktEmail,
            adresse: adresse,
            liga: liga,
            vertragBis: vertragBis,
            vertragsOptionen: vertragsOptionen,
            gehalt: gehalt,
            schuhgroesse: client.schuhgroesse,
            schuhmarke: schuhmarke,
            starkerFuss: starkerFuss,
            groesse: groesse,
            gewicht: client.gewicht,
            positionFeld: selectedPositions.isEmpty ? nil : selectedPositions,
            sprachen: client.sprachen,
            lizenz: client.lizenz,
            nationalmannschaft: nationalmannschaft,
            profilbildURL: client.profilbildURL,
            transfermarktID: transfermarktID,
            userID: client.userID,
            createdBy: client.createdBy,
            konditionen: konditionen,
            art: art,
            spielerCV: spielerCVURL,
            video: videoURL
        )
    }

    private var clientDataSection: some View {
        Section(header: Text("Klientendaten").foregroundColor(.white)) {
            TextField("Vorname", text: $vorname)
                .foregroundColor(.white)
            TextField("Name", text: $name)
                .foregroundColor(.white)
            DatePicker("Geburtsdatum", selection: Binding(
                get: { geburtsdatum ?? Date() },
                set: { geburtsdatum = $0 }
            ), displayedComponents: .date)
                .datePickerStyle(.compact)
                .foregroundColor(.white)
                .accentColor(.white)
            if isLoadingClubs {
                ProgressView("Lade Vereine...")
                    .tint(.white)
            } else {
                Picker("Verein", selection: $vereinID) {
                    Text("Kein Verein").tag(String?.none)
                    ForEach(clubOptions.filter { $0.abteilungForGender(client.geschlecht) != nil }) { club in
                        Text(club.name).tag(club.id as String?)
                    }
                }
                .pickerStyle(.menu)
                .foregroundColor(.white)
                .accentColor(.white)
            }
            Text("Liga: \(liga ?? "Keine")")
                .foregroundColor(.gray)
            DatePicker("Vertragslaufzeit", selection: Binding(
                get: { vertragBis ?? Date() },
                set: { vertragBis = $0 }
            ), displayedComponents: .date)
                .foregroundColor(.white)
                .accentColor(.white)
            TextField("Vertragsoptionen", text: Binding(
                get: { vertragsOptionen ?? "" },
                set: { vertragsOptionen = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("Gehalt (€)", text: Binding(
                get: { gehalt != nil ? String(gehalt!) : "" },
                set: { gehalt = Double($0) }
            ))
                .keyboardType(.decimalPad)
                .foregroundColor(.white)
            TextField("Größe (cm)", text: Binding(
                get: { groesse != nil ? String(groesse!) : "" },
                set: { groesse = Int($0) }
            ))
                .keyboardType(.numberPad)
                .foregroundColor(.white)
            profileImagePicker
            nationalityPicker
            TextField("Nationalmannschaft", text: Binding(
                get: { nationalmannschaft ?? "" },
                set: { nationalmannschaft = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
        }
    }

    private var positionSection: some View {
        Section(header: Text("Positionen").foregroundColor(.white)) {
            Button(action: {
                print("EditClientView - PositionPicker geöffnet")
                showingPositionPicker = true
            }) {
                Text(selectedPositions.isEmpty ? "Positionen auswählen" : selectedPositions.joined(separator: ", "))
                    .foregroundColor(selectedPositions.isEmpty ? .gray : .white)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .sheet(isPresented: $showingPositionPicker) {
                NavigationView {
                    MultiPicker(
                        title: "Positionen auswählen",
                        selection: $selectedPositions,
                        options: Constants.positionOptions,
                        isNationalityPicker: false
                    )
                    .navigationTitle("Positionen")
                    .foregroundColor(.white)
                    .toolbar {
                        ToolbarItem(placement: .topBarTrailing) {
                            Button("Fertig") {
                                showingPositionPicker = false
                            }
                            .foregroundColor(.white)
                        }
                    }
                    .background(Color.black)
                }
            }
            Picker("Schuhmarke", selection: Binding(
                get: { schuhmarke ?? "" },
                set: { schuhmarke = $0.isEmpty ? nil : $0 }
            )) {
                Text("Keine Marke").tag("")
                ForEach(sponsorOptions.filter { $0.category == "Sportartikelhersteller" }) { sponsor in
                    Text(sponsor.name).tag(sponsor.name)
                }
            }
            .pickerStyle(.menu)
            .foregroundColor(.white)
            .accentColor(.white)
            Picker("Starker Fuß", selection: Binding(
                get: { starkerFuss ?? "" },
                set: { starkerFuss = $0.isEmpty ? nil : $0 }
            )) {
                Text("Nicht angegeben").tag("")
                ForEach(Constants.strongFootOptions, id: \.self) { foot in
                    Text(foot).tag(foot)
                }
            }
            .pickerStyle(.menu)
            .foregroundColor(.white)
            .accentColor(.white)
        }
    }

    private var contactInfoSection: some View {
        Section(header: Text("Kontaktinformationen").foregroundColor(.white)) {
            TextField("Telefon", text: Binding(
                get: { kontaktTelefon ?? "" },
                set: { kontaktTelefon = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("E-Mail", text: Binding(
                get: { kontaktEmail ?? "" },
                set: { kontaktEmail = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("Adresse", text: Binding(
                get: { adresse ?? "" },
                set: { adresse = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
        }
    }

    private var transfermarktSection: some View {
        Section(header: Text(client.geschlecht == "männlich" ? "Transfermarkt" : "Soccerdonna").foregroundColor(.white)) {
            TextField(client.geschlecht == "männlich" ? "Transfermarkt-ID" : "Soccerdonna-ID", text: Binding(
                get: { transfermarktID ?? "" },
                set: { transfermarktID = $0.isEmpty ? nil : $0 }
            ))
                .keyboardType(.numberPad)
                .foregroundColor(.white)
                .customPlaceholder(when: (transfermarktID ?? "").isEmpty) {
                    Text(client.geschlecht == "männlich" ? "z. B. 690425" : "z. B. 31388")
                        .foregroundColor(.gray)
                }
                .onChange(of: transfermarktID) { newID in
                    if let newID = newID, !newID.isEmpty {
                        Task {
                            await MainActor.run { isLoadingTransfermarkt = true }
                            do {
                                let playerData: PlayerData
                                if client.geschlecht == "männlich" {
                                    playerData = try await TransfermarktService.shared.fetchPlayerData(forPlayerID: newID)
                                } else {
                                    playerData = try await SoccerdonnaService.shared.fetchPlayerData(forPlayerID: newID)
                                }
                                await MainActor.run {
                                    isLoadingTransfermarkt = false
                                    transfermarktError = ""
                                    if vorname.isEmpty, let fullName = playerData.name {
                                        let parts = fullName.split(separator: " ")
                                        if parts.count >= 2 {
                                            vorname = String(parts[0])
                                            name = String(parts.dropFirst().joined(separator: " "))
                                        } else {
                                            name = fullName
                                        }
                                    }
                                    if selectedPositions.isEmpty, let position = playerData.position {
                                        selectedPositions = [position]
                                    }
                                    if selectedNationalities.isEmpty, let nationalities = playerData.nationalitaet {
                                        selectedNationalities = nationalities
                                    }
                                    if geburtsdatum == nil, let birthdate = playerData.geburtsdatum {
                                        geburtsdatum = birthdate
                                    }
                                    if vereinID == nil, let clubID = playerData.vereinID,
                                       let club = clubOptions.first(where: { $0.name == clubID }) {
                                        vereinID = club.id
                                        Task { await updateLeagueAndAbteilung() }
                                    }
                                    if vertragBis == nil, let contractEnd = playerData.contractEnd {
                                        vertragBis = contractEnd
                                    }
                                }
                            } catch {
                                await MainActor.run {
                                    isLoadingTransfermarkt = false
                                    transfermarktError = "Fehler beim Abrufen der Daten: \(error.localizedDescription)"
                                }
                            }
                        }
                    }
                }
            if isLoadingTransfermarkt {
                ProgressView("Lade Daten...")
                    .tint(.white)
            }
            if !transfermarktError.isEmpty {
                Text(transfermarktError)
                    .foregroundColor(.red)
                    .font(.caption)
            }
        }
    }

    private var additionalInfoSection: some View {
        Section(header: Text("Zusätzliche Informationen").foregroundColor(.white)) {
            TextField("Konditionen", text: Binding(
                get: { konditionen ?? "" },
                set: { konditionen = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            Picker("Art", selection: Binding(
                get: { art ?? "" },
                set: { art = $0.isEmpty ? nil : $0 }
            )) {
                Text("Nicht angegeben").tag("")
                Text("Vereinswechsel").tag("Vereinswechsel")
                Text("Vertragsverlängerung").tag("Vertragsverlängerung")
            }
            .pickerStyle(.menu)
            .foregroundColor(.white)
            .accentColor(.white)
            VStack(alignment: .leading, spacing: 10) {
                Text("Spieler-CV")
                    .font(.subheadline)
                    .foregroundColor(.white)
                Button(action: { showingCVPicker = true }) {
                    Label("CV auswählen", systemImage: "doc")
                        .foregroundColor(.white)
                }
                if let spielerCVURL = spielerCVURL {
                    Text("Aktuell: \(spielerCVURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            VStack(alignment: .leading, spacing: 10) {
                Text("Video")
                    .font(.subheadline)
                    .foregroundColor(.white)
                Button(action: { showingVideoPicker = true }) {
                    Label("Video auswählen", systemImage: "video")
                        .foregroundColor(.white)
                }
                if let videoURL = videoURL {
                    Text("Aktuell: \(videoURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
        }
    }

    private var profileImagePicker: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Profilbild")
                .font(.subheadline)
                .foregroundColor(.white)
            
            PhotosPicker(
                selection: $selectedPhoto,
                matching: .images,
                photoLibrary: .shared()
            ) {
                Label("Bild aus Fotogalerie auswählen", systemImage: "photo")
                    .foregroundColor(.white)
            }
            
            TextField("Oder Bild-URL eingeben", text: $imageURL)
                .autocapitalization(.none)
                .keyboardType(.URL)
                .foregroundColor(.white)
            
            if isUploadingImage {
                ProgressView("Bild wird hochgeladen...")
                    .tint(.white)
            } else if let image = profileImage {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            } else if let urlString = client.profilbildURL, !urlString.isEmpty, let url = URL(string: urlString) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .scaledToFit()
                            .frame(height: 100)
                            .clipShape(RoundedRectangle(cornerRadius: 10))
                    case .failure, .empty:
                        Image(systemName: "photo")
                            .resizable()
                            .scaledToFit()
                            .frame(height: 100)
                            .foregroundColor(.gray)
                    @unknown default:
                        Image(systemName: "photo")
                            .resizable()
                            .scaledToFit()
                            .frame(height: 100)
                            .foregroundColor(.gray)
                    }
                }
            } else {
                Image(systemName: "photo")
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .foregroundColor(.gray)
            }
        }
    }

    private var nationalityPicker: some View {
        Button(action: {
            print("EditClientView - NationalityPicker geöffnet")
            showingNationalityPicker = true
        }) {
            Text(selectedNationalities.isEmpty ? "Nationalitäten auswählen" : selectedNationalities.joined(separator: ", "))
                .foregroundColor(selectedNationalities.isEmpty ? .gray : .white)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .sheet(isPresented: $showingNationalityPicker) {
            NavigationView {
                MultiPicker(
                    title: "Nationalitäten auswählen",
                    selection: $selectedNationalities,
                    options: Constants.nationalities,
                    isNationalityPicker: true
                )
                .navigationTitle("Nationalitäten")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button("Fertig") {
                            showingNationalityPicker = false
                        }
                        .foregroundColor(.white)
                    }
                }
                .background(Color.black)
            }
        }
    }

    private func loadClubOptions() async {
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil as DocumentSnapshot?, limit: 1000)
            await MainActor.run {
                self.clubOptions = clubs
                self.isLoadingClubs = false
                updateLeagueAndAbteilungSync()
            }
        } catch {
            await MainActor.run {
                self.isLoadingClubs = false
                errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)"
            }
        }
    }

    private func loadSponsors() async {
        do {
            let (sponsors, _) = try await FirestoreManager.shared.getSponsors(lastDocument: nil as DocumentSnapshot?, limit: 1000)
            await MainActor.run {
                self.sponsorOptions = sponsors
            }
        } catch {
            await MainActor.run {
                self.sponsorOptions = []
                self.errorMessage = "Fehler beim Laden der Sponsoren: \(error.localizedDescription)"
            }
        }
    }

    private func loadContractData() async {
        guard let clientID = client.id else { return }
        do {
            let (contracts, _) = try await FirestoreManager.shared.getContracts(lastDocument: nil as DocumentSnapshot?, limit: 1000)
            await MainActor.run {
                contractViewModel.contracts = contracts.filter { $0.clientID == clientID }
                if let contract = contractViewModel.contracts.first {
                    if vertragBis == nil {
                        vertragBis = contract.endDatum
                    }
                    if vertragsOptionen == nil {
                        vertragsOptionen = contract.vertragsdetails
                    }
                }
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden der Vertragsdaten: \(error.localizedDescription)"
            }
        }
    }

    private func updateLeagueAndAbteilung() async {
        await MainActor.run {
            updateLeagueAndAbteilungSync()
        }
    }

    private func updateLeagueAndAbteilungSync() {
        if let vereinID = vereinID,
           let selectedClub = clubOptions.first(where: { $0.id == vereinID }) {
            abteilung = selectedClub.abteilungForGender(client.geschlecht)
            if client.geschlecht == "männlich" {
                liga = selectedClub.mensDepartment?.league
                print("Liga für Männer gesetzt: \(liga ?? "Keine")")
            } else if client.geschlecht == "weiblich" {
                liga = selectedClub.womensDepartment?.league
                print("Liga für Frauen gesetzt: \(liga ?? "Keine")")
            }
        } else {
            abteilung = nil
            liga = nil
            print("Kein Verein ausgewählt, Liga zurückgesetzt")
        }
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else {
            print("EditClientView - Kein Foto zum Laden ausgewählt")
            await MainActor.run {
                self.profileImage = nil
            }
            return
        }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.profileImage = image
                    self.imageURL = ""
                    self.client.profilbildURL = nil
                    print("EditClientView - Bild erfolgreich geladen: \(image)")
                }
            } else {
                await MainActor.run {
                    self.profileImage = nil
                    errorMessage = "Fehler beim Laden des Bildes: Keine Bilddaten"
                }
            }
        } catch {
            await MainActor.run {
                self.profileImage = nil
                errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)"
            }
        }
    }

    private func loadSpielerCV(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.spielerCVData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des CVs: \(error.localizedDescription)"
            }
        }
    }

    private func loadVideo(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.videoData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Videos: \(error.localizedDescription)"
            }
        }
    }

    private func downloadImage(from urlString: String) async throws -> UIImage {
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
        guard let image = UIImage(data: data) else {
            throw URLError(.cannotDecodeContentData)
        }
        return image
    }

    private func saveClient(updatedClient: Client) async {
        do {
            var clientToSave = updatedClient
            if let clientID = clientToSave.id {
                await MainActor.run { isUploadingImage = true }
                
                if let image = profileImage {
                    let url = try await FirestoreManager.shared.uploadImage(
                        documentID: clientID,
                        image: image,
                        collection: "profile_images"
                    )
                    clientToSave.profilbildURL = url
                } else if !imageURL.isEmpty {
                    let downloadedImage = try await downloadImage(from: imageURL)
                    let url = try await FirestoreManager.shared.uploadImage(
                        documentID: clientID,
                        image: downloadedImage,
                        collection: "profile_images"
                    )
                    clientToSave.profilbildURL = url
                }

                if let cvData = spielerCVData {
                    let url = try await FirestoreManager.shared.uploadFile(
                        documentID: clientID,
                        data: cvData,
                        collection: "player_cvs",
                        fileName: "cv_\(clientID)"
                    )
                    clientToSave.spielerCV = url
                }

                if let videoData = videoData {
                    let url = try await FirestoreManager.shared.uploadFile(
                        documentID: clientID,
                        data: videoData,
                        collection: "player_videos",
                        fileName: "video_\(clientID)"
                    )
                    clientToSave.video = url
                }

                try await FirestoreManager.shared.updateClient(client: clientToSave)
                await MainActor.run { isUploadingImage = false }
                onSave(clientToSave)
            } else {
                try await FirestoreManager.shared.updateClient(client: clientToSave)
                onSave(clientToSave)
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                print("Fehler beim Speichern: \(error)")
                isUploadingImage = false
            }
        }
    }

    private func isValidClient() -> Bool {
        if vorname.isEmpty || name.isEmpty {
            errorMessage = "Vorname und Name sind Pflichtfelder."
            return false
        }
        if let email = kontaktEmail, !email.isEmpty && !isValidEmail(email) {
            errorMessage = "Ungültiges E-Mail-Format."
            return false
        }
        return true
    }

    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPred = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }
}

#Preview {
    EditClientView(
        client: .constant(Client(
            id: "1",
            typ: "Spieler",
            name: "Müller",
            vorname: "Thomas",
            geschlecht: "männlich",
            abteilung: "Männer",
            vereinID: "Bayern Munich",
            nationalitaet: ["Deutschland"],
            geburtsdatum: Date().addingTimeInterval(-25 * 365 * 24 * 60 * 60),
            konditionen: "Gehalt: 10M€, Bonus: 2M€",
            art: "Vereinswechsel",
            spielerCV: "https://example.com/cv.pdf",
            video: "https://example.com/video.mp4"
        )),
        onSave: { _ in },
        onCancel: {}
    )
    .environmentObject(AuthManager())
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/5. Club
//
//  AddClubView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers

struct AddClubView: View {
    @Binding var club: Club
    var onSave: (Club) -> Void
    var onCancel: () -> Void

    @State private var name: String
    @State private var mensLeague: String?
    @State private var womensLeague: String?
    @State private var mensAdresse: String = ""
    @State private var womensAdresse: String = ""
    @State private var mensKontaktTelefon: String = ""
    @State private var womensKontaktTelefon: String = ""
    @State private var mensKontaktEmail: String = ""
    @State private var womensKontaktEmail: String = ""
    @State private var land: String?
    @State private var memberCount: String = ""
    @State private var founded: String = ""
    @State private var logoURL: String = ""
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var logoImage: UIImage? = nil
    @State private var clubDocumentData: Data? = nil
    @State private var clubDocumentURL: String? = nil
    @State private var isUploadingImage = false
    @State private var errorMessage: String = ""
    @State private var showingCountryPicker = false
    @State private var showingDocumentPicker = false

    init(club: Binding<Club>, onSave: @escaping (Club) -> Void, onCancel: @escaping () -> Void) {
        self._club = club
        self.onSave = onSave
        self.onCancel = onCancel
        self._name = State(initialValue: club.wrappedValue.name)
        self._mensLeague = State(initialValue: club.wrappedValue.mensDepartment?.league)
        self._womensLeague = State(initialValue: club.wrappedValue.womensDepartment?.league)
        self._mensAdresse = State(initialValue: club.wrappedValue.mensDepartment?.adresse ?? "")
        self._womensAdresse = State(initialValue: club.wrappedValue.womensDepartment?.adresse ?? "")
        self._mensKontaktTelefon = State(initialValue: club.wrappedValue.mensDepartment?.kontaktTelefon ?? "")
        self._womensKontaktTelefon = State(initialValue: club.wrappedValue.womensDepartment?.kontaktTelefon ?? "")
        self._mensKontaktEmail = State(initialValue: club.wrappedValue.mensDepartment?.kontaktEmail ?? "")
        self._womensKontaktEmail = State(initialValue: club.wrappedValue.womensDepartment?.kontaktEmail ?? "")
        self._land = State(initialValue: club.wrappedValue.sharedInfo?.land)
        self._memberCount = State(initialValue: club.wrappedValue.sharedInfo?.memberCount.map(String.init) ?? "")
        self._founded = State(initialValue: club.wrappedValue.sharedInfo?.founded ?? "")
        self._logoURL = State(initialValue: club.wrappedValue.sharedInfo?.logoURL ?? "")
        self._clubDocumentURL = State(initialValue: club.wrappedValue.sharedInfo?.clubDocumentURL)
    }

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Vereinsdaten").foregroundColor(.white)) {
                    TextField("Name", text: $name)
                        .foregroundColor(.white)
                    countryPicker
                    TextField("Mitgliederzahl", text: $memberCount)
                        .keyboardType(.numberPad)
                        .foregroundColor(.white)
                    TextField("Gegründet", text: $founded)
                        .foregroundColor(.white)

                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .images,
                        photoLibrary: .shared()
                    ) {
                        Label("Logo auswählen", systemImage: "photo")
                            .foregroundColor(.white)
                    }
                    TextField("Oder Logo-URL eingeben", text: $logoURL)
                        .autocapitalization(.none)
                        .keyboardType(.URL)
                        .foregroundColor(.white)
                    if isUploadingImage {
                        ProgressView("Logo wird hochgeladen...")
                            .tint(.white)
                    } else if let image = logoImage {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .frame(height: 100)
                            .clipShape(RoundedRectangle(cornerRadius: 10))
                    } else if !logoURL.isEmpty {
                        AsyncImage(url: URL(string: logoURL)) { phase in
                            switch phase {
                            case .success(let image):
                                image.resizable().scaledToFit().frame(height: 100).clipShape(RoundedRectangle(cornerRadius: 10))
                            case .failure:
                                Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                            case .empty:
                                ProgressView().tint(.white)
                            @unknown default:
                                Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                            }
                        }
                    }
                }
                Section(header: Text("Männerabteilung").foregroundColor(.white)) {
                    Picker("Liga", selection: $mensLeague) {
                        Text("Keine Liga").tag(String?.none)
                        ForEach(Constants.leaguesMale, id: \.self) { league in
                            Text(league).tag(String?.some(league))
                        }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Adresse", text: $mensAdresse)
                        .foregroundColor(.white)
                    TextField("Telefon", text: $mensKontaktTelefon)
                        .foregroundColor(.white)
                    TextField("E-Mail", text: $mensKontaktEmail)
                        .foregroundColor(.white)
                }
                Section(header: Text("Frauenabteilung").foregroundColor(.white)) {
                    Picker("Liga", selection: $womensLeague) {
                        Text("Keine Liga").tag(String?.none)
                        ForEach(Constants.leaguesFemale, id: \.self) { league in
                            Text(league).tag(String?.some(league))
                        }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Adresse", text: $womensAdresse)
                        .foregroundColor(.white)
                    TextField("Telefon", text: $womensKontaktTelefon)
                        .foregroundColor(.white)
                    TextField("E-Mail", text: $womensKontaktEmail)
                        .foregroundColor(.white)
                }
                Section(header: Text("Dokumente").foregroundColor(.white)) {
                    VStack(alignment: .leading, spacing: 10) {
                        Text("Vereinsdokument")
                            .font(.subheadline)
                            .foregroundColor(.white)
                        Button(action: { showingDocumentPicker = true }) {
                            Label("Dokument auswählen", systemImage: "doc")
                                .foregroundColor(.white)
                        }
                        if let clubDocumentURL = clubDocumentURL {
                            Text("Hochgeladen: \(clubDocumentURL.split(separator: "/").last ?? "")")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle(club.id == nil ? "Verein anlegen" : "Verein bearbeiten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { onCancel() }
                        .foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        if validateInputs() {
                            Task { await saveClub() }
                        }
                    }
                    .disabled(name.isEmpty || (mensLeague == nil && womensLeague == nil))
                    .foregroundColor(.white)
                }
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
                )
            }
            .onChange(of: selectedPhoto) { _ in Task { await loadSelectedImage() } }
            .sheet(isPresented: $showingDocumentPicker) {
                DocumentPicker(
                    allowedContentTypes: [.pdf, .text],
                    onPick: { url in
                        Task { await loadClubDocument(from: url) }
                    }
                )
            }
        }
    }

    private var countryPicker: some View {
        Button(action: { showingCountryPicker = true }) {
            Text(land ?? "Land auswählen")
                .foregroundColor(land == nil ? .gray : .white)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .sheet(isPresented: $showingCountryPicker) {
            NavigationView {
                MultiPicker(
                    title: "Land auswählen",
                    selection: Binding(
                        get: { [land].compactMap { $0 } },
                        set: { newValue in land = newValue.first }
                    ),
                    options: Constants.nationalities,
                    isNationalityPicker: false
                )
                .navigationTitle("Land")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button("Fertig") { showingCountryPicker = false }
                            .foregroundColor(.white)
                    }
                }
                .background(Color.black)
            }
        }
    }

    private func validateInputs() -> Bool {
        if name.isEmpty {
            errorMessage = "Der Vereinsname darf nicht leer sein."
            return false
        }
        if let memberCountInt = Int(memberCount), memberCountInt < 0 {
            errorMessage = "Die Mitgliederzahl darf nicht negativ sein."
            return false
        }
        return true
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else { return }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.logoImage = image
                    self.logoURL = ""
                }
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)"
            }
        }
    }

    private func loadClubDocument(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.clubDocumentData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Dokuments: \(error.localizedDescription)"
            }
        }
    }

    private func downloadImage(from urlString: String) async throws -> UIImage {
        guard let url = URL(string: urlString) else { throw URLError(.badURL) }
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else { throw URLError(.badServerResponse) }
        guard let image = UIImage(data: data) else { throw URLError(.cannotDecodeContentData) }
        return image
    }

    private func saveClub() async {
        do {
            var finalLogoURL = logoURL
            if let image = logoImage {
                await MainActor.run { isUploadingImage = true }
                let documentID = club.id ?? UUID().uuidString
                finalLogoURL = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: image,
                    collection: "club_logos"
                )
            } else if !logoURL.isEmpty {
                let downloadedImage = try await downloadImage(from: logoURL)
                let documentID = club.id ?? UUID().uuidString
                finalLogoURL = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: downloadedImage,
                    collection: "club_logos"
                )
            }

            let mensDepartment = Club.Department(
                league: mensLeague,
                adresse: mensAdresse.isEmpty ? nil : mensAdresse,
                kontaktTelefon: mensKontaktTelefon.isEmpty ? nil : mensKontaktTelefon,
                kontaktEmail: mensKontaktEmail.isEmpty ? nil : mensKontaktEmail,
                funktionäre: club.mensDepartment?.funktionäre ?? [],
                clients: club.mensDepartment?.clients ?? []
            )
            let womensDepartment = Club.Department(
                league: womensLeague,
                adresse: womensAdresse.isEmpty ? nil : womensAdresse,
                kontaktTelefon: womensKontaktTelefon.isEmpty ? nil : womensKontaktTelefon,
                kontaktEmail: womensKontaktEmail.isEmpty ? nil : womensKontaktEmail,
                funktionäre: club.womensDepartment?.funktionäre ?? [],
                clients: club.womensDepartment?.clients ?? []
            )
            var sharedInfo = Club.SharedInfo(
                land: land,
                memberCount: Int(memberCount) ?? nil,
                founded: founded.isEmpty ? nil : founded,
                logoURL: finalLogoURL.isEmpty ? nil : finalLogoURL,
                clubDocumentURL: clubDocumentURL
            )

            let documentID = club.id ?? UUID().uuidString
            if let docData = clubDocumentData {
                let url = try await FirestoreManager.shared.uploadFile(
                    documentID: documentID,
                    data: docData,
                    collection: "club_documents",
                    fileName: "doc_\(documentID)"
                )
                sharedInfo.clubDocumentURL = url
            }

            let updatedClub = Club(
                id: club.id,
                name: name,
                mensDepartment: mensLeague == nil && mensAdresse.isEmpty && mensKontaktTelefon.isEmpty && mensKontaktEmail.isEmpty ? nil : mensDepartment,
                womensDepartment: womensLeague == nil && womensAdresse.isEmpty && womensKontaktTelefon.isEmpty && womensKontaktEmail.isEmpty ? nil : womensDepartment,
                sharedInfo: sharedInfo
            )
            onSave(updatedClub)
            await MainActor.run { isUploadingImage = false }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                isUploadingImage = false
            }
        }
    }
}

#Preview {
    AddClubView(
        club: .constant(Club(name: "Bayern München", mensDepartment: nil, womensDepartment: nil, sharedInfo: nil)),
        onSave: { _ in },
        onCancel: {}
    )
}



//
//  ClubListView.swift

import SwiftUI
import FirebaseFirestore

struct ClubListView: View {
    @EnvironmentObject var authManager: AuthManager
    @State private var clubs: [Club] = []
    @State private var showingAddClubSheet = false
    @State private var newClub: Club = Club(id: nil, name: "", mensDepartment: nil, womensDepartment: nil, sharedInfo: nil)
    @State private var errorMessage = ""
    @State private var listener: ListenerRegistration?

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                if clubs.isEmpty {
                    Text("Keine Vereine vorhanden.")
                        .foregroundColor(.gray)
                        .padding()
                } else {
                    List {
                        ForEach(clubs) { club in
                            NavigationLink(destination: ClubView(clubID: club.id ?? "")) {
                                clubRow(for: club)
                            }
                            .swipeActions {
                                Button(role: .destructive) {
                                    Task {
                                        await deleteClub(club)
                                    }
                                } label: {
                                    Label("Löschen", systemImage: "trash")
                                        .foregroundColor(.white)
                                }
                            }
                            .listRowBackground(Color.gray.opacity(0.2))
                        }
                    }
                    .scrollContentBackground(.hidden)
                    .background(Color.black)
                }
            }
            .navigationTitle("Vereine verwalten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { showingAddClubSheet = true }) {
                        Image(systemName: "plus")
                            .foregroundColor(.white)
                    }
                }
            }
            .sheet(isPresented: $showingAddClubSheet) {
                AddClubView(
                    club: $newClub,
                    onSave: { updatedClub in
                        Task {
                            do {
                                if updatedClub.id != nil {
                                    try await FirestoreManager.shared.updateClub(club: updatedClub)
                                } else {
                                    try await FirestoreManager.shared.createClub(club: updatedClub)
                                }
                                await MainActor.run {
                                    resetNewClub()
                                    showingAddClubSheet = false
                                }
                            } catch {
                                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                            }
                        }
                    },
                    onCancel: {
                        resetNewClub()
                        showingAddClubSheet = false
                    }
                )
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
            .task {
                await loadClubsOnce()
                await setupRealtimeListener()
            }
            .onDisappear {
                listener?.remove()
            }
            .background(Color.black)
        }
    }

    @ViewBuilder
    private func clubRow(for club: Club) -> some View {
        HStack(spacing: 10) {
            if let logoURL = club.sharedInfo?.logoURL, let url = URL(string: logoURL) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                            .frame(width: 40, height: 40)
                            .tint(.white)
                    case .success(let image):
                        image
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40, height: 40)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    case .failure:
                        Image(systemName: "building.fill")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    @unknown default:
                        Image(systemName: "building.fill")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    }
                }
            } else {
                Image(systemName: "building.fill")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 40, height: 40)
                    .foregroundColor(.gray)
                    .clipShape(Circle())
                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
            }

            VStack(alignment: .leading, spacing: 2) {
                Text(club.name)
                    .font(.headline)
                    .foregroundColor(.white)
                if let mensLeague = club.mensDepartment?.league {
                    Text("Männer: \(mensLeague)")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                if let womensLeague = club.womensDepartment?.league {
                    Text("Frauen: \(womensLeague)")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                if let memberCount = club.sharedInfo?.memberCount {
                    Text("Mitglieder: \(memberCount)")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                if let founded = club.sharedInfo?.founded {
                    Text("Gegründet: \(founded)")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding(.vertical, 5)
    }

    private func resetNewClub() {
        newClub = Club(id: nil, name: "", mensDepartment: nil, womensDepartment: nil, sharedInfo: nil)
    }

    private func loadClubsOnce() async {
        do {
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            print("Einmalige Abfrage - Geladene Vereine: \(loadedClubs.count), IDs: \(loadedClubs.map { $0.id ?? "unbekannt" })")
            await MainActor.run {
                self.clubs = loadedClubs
            }
        } catch {
            errorMessage = "Fehler beim einmaligen Laden der Vereine: \(error.localizedDescription)"
            print("Fehler beim einmaligen Laden der Vereine: \(error.localizedDescription)")
        }
    }

    private func setupRealtimeListener() async {
        let newListener = Firestore.firestore().collection("clubs")
            .addSnapshotListener { snapshot, error in
                if let error = error {
                    self.errorMessage = "Fehler beim Listener (Vereine): \(error.localizedDescription)"
                    print("Fehler beim Listener (Vereine): \(error.localizedDescription)")
                    return
                }
                guard let documents = snapshot?.documents else {
                    print("Keine Dokumente in der Sammlung 'clubs' gefunden (Realtime).")
                    return
                }
                let updatedClubs = documents.compactMap { doc -> Club? in
                    do {
                        let club = try doc.data(as: Club.self)
                        return club
                    } catch {
                        print("Fehler beim Dekodieren des Vereins \(doc.documentID): \(error.localizedDescription)")
                        return nil
                    }
                }
                print("Geladene Vereine (Realtime): \(updatedClubs.count), IDs: \(updatedClubs.map { $0.id ?? "unbekannt" })")
                DispatchQueue.main.async {
                    self.clubs = updatedClubs
                }
            }
        await MainActor.run {
            self.listener = newListener
        }
    }

    private func deleteClub(_ club: Club) async {
        guard let id = club.id else {
            errorMessage = "Keine Vereins-ID vorhanden"
            return
        }
        do {
            try await FirestoreManager.shared.deleteClub(clubID: id)
        } catch {
            errorMessage = "Fehler beim Löschen: \(error.localizedDescription)"
        }
    }
}

#Preview {
    ClubListView()
        .environmentObject(AuthManager())
}



//
//  ClubView.swift

import SwiftUI
import FirebaseFirestore

struct ClubView: View {
    let clubID: String
    @State private var club: Club?
    @State private var logoImage: UIImage? = nil
    @State private var isLoadingImage = false
    @State private var funktionäre: [Funktionär] = []
    @State private var errorMessage: String = ""
    @State private var showingEditSheet = false

    init(clubID: String) {
        self.clubID = clubID
    }

    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                if let club = club {
                    if isLoadingImage {
                        ProgressView("Lade Logo...")
                            .frame(width: 100, height: 100)
                            .tint(.white)
                    } else if let image = logoImage {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100, height: 100)
                            .clipShape(Circle())
                    } else {
                        Image(systemName: "building.fill")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100, height: 100)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                    }

                    Text(club.name)
                        .font(.title)
                        .bold()
                        .foregroundColor(.white)

                    Section(header: Text("Allgemeine Informationen").font(.headline).foregroundColor(.white)) {
                        if let land = club.sharedInfo?.land {
                            Label(land, systemImage: "globe")
                                .font(.subheadline)
                                .foregroundColor(.white)
                        }
                        if let memberCount = club.sharedInfo?.memberCount {
                            Label("Mitglieder: \(memberCount)", systemImage: "person.2")
                                .font(.subheadline)
                                .foregroundColor(.white)
                        }
                        if let founded = club.sharedInfo?.founded {
                            Label("Gegründet: \(founded)", systemImage: "calendar")
                                .font(.subheadline)
                                .foregroundColor(.white)
                        }
                        if let clubDocumentURL = club.sharedInfo?.clubDocumentURL {
                            Label("Dokument: \(clubDocumentURL.split(separator: "/").last ?? "")", systemImage: "doc")
                                .font(.subheadline)
                                .foregroundColor(.white)
                        }
                    }

                    if let mensDepartment = club.mensDepartment {
                        Section(header: Text("Männerabteilung").font(.headline).foregroundColor(.white)) {
                            if let league = mensDepartment.league {
                                Label("Liga: \(league)", systemImage: "sportscourt")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let adresse = mensDepartment.adresse {
                                Label("Adresse: \(adresse)", systemImage: "mappin.and.ellipse")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let kontaktTelefon = mensDepartment.kontaktTelefon {
                                Label("Telefon: \(kontaktTelefon)", systemImage: "phone")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let kontaktEmail = mensDepartment.kontaktEmail {
                                Label("E-Mail: \(kontaktEmail)", systemImage: "envelope")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                        }
                    }

                    if let womensDepartment = club.womensDepartment {
                        Section(header: Text("Frauenabteilung").font(.headline).foregroundColor(.white)) {
                            if let league = womensDepartment.league {
                                Label("Liga: \(league)", systemImage: "sportscourt")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let adresse = womensDepartment.adresse {
                                Label("Adresse: \(adresse)", systemImage: "mappin.and.ellipse")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let kontaktTelefon = womensDepartment.kontaktTelefon {
                                Label("Telefon: \(kontaktTelefon)", systemImage: "phone")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                            if let kontaktEmail = womensDepartment.kontaktEmail {
                                Label("E-Mail: \(kontaktEmail)", systemImage: "envelope")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                            }
                        }
                    }

                    Section(header: Text("Funktionäre").font(.headline).foregroundColor(.white)) {
                        if funktionäre.isEmpty {
                            Text("Keine Funktionäre vorhanden.")
                                .foregroundColor(.gray)
                        } else {
                            ForEach(funktionäre) { funktionär in
                                VStack(alignment: .leading) {
                                    Text("\(funktionär.vorname) \(funktionär.name)")
                                        .foregroundColor(.white)
                                    if let abteilung = funktionär.abteilung {
                                        Text("Abteilung: \(abteilung)")
                                            .foregroundColor(.white)
                                    }
                                    if let position = funktionär.positionImVerein {
                                        Text("Position: \(position)")
                                            .foregroundColor(.white)
                                    }
                                }
                                .padding(.vertical, 5)
                            }
                        }
                    }

                    Button(action: { showingEditSheet = true }) {
                        Text("Bearbeiten")
                            .padding()
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                    .sheet(isPresented: $showingEditSheet) {
                        AddClubView(club: Binding(
                            get: { club },
                            set: { newClub in self.club = newClub }
                        ), onSave: { updatedClub in
                            Task {
                                do {
                                    try await FirestoreManager.shared.updateClub(club: updatedClub)
                                    await MainActor.run {
                                        self.club = updatedClub
                                        print("Verein erfolgreich aktualisiert")
                                    }
                                } catch {
                                    await MainActor.run {
                                        errorMessage = "Fehler beim Aktualisieren des Vereins: \(error.localizedDescription)"
                                    }
                                }
                                await MainActor.run {
                                    showingEditSheet = false
                                }
                            }
                        }, onCancel: {
                            showingEditSheet = false
                        })
                    }
                } else {
                    Text("Lade Verein...")
                        .foregroundColor(.gray)
                }
            }
            .padding()
            .background(Color.black)
        }
        .navigationTitle(club?.name ?? "Verein")
        .foregroundColor(.white)
        .alert(isPresented: .constant(!errorMessage.isEmpty)) {
            Alert(
                title: Text("Fehler").foregroundColor(.white),
                message: Text(errorMessage).foregroundColor(.white),
                dismissButton: .default(Text("OK").foregroundColor(.white)) {
                    errorMessage = ""
                }
            )
        }
        .task {
            await loadClub()
            await loadFunktionäre()
        }
    }

    private func loadClub() async {
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.club = clubs.first { $0.id == clubID }
            }
            await loadLogoImage()
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Vereins: \(error.localizedDescription)"
            }
        }
    }

    private func loadLogoImage() async {
        guard let club = club else { return }
        await MainActor.run { isLoadingImage = true }
        if let logoURL = club.sharedInfo?.logoURL, let url = URL(string: logoURL) {
            do {
                let (data, _) = try await URLSession.shared.data(from: url)
                if let image = UIImage(data: data) {
                    await MainActor.run {
                        self.logoImage = image
                        self.isLoadingImage = false
                    }
                } else {
                    await MainActor.run {
                        self.logoImage = nil
                        self.isLoadingImage = false
                        self.errorMessage = "Kein gültiges Bild gefunden."
                    }
                }
            } catch {
                await MainActor.run {
                    self.logoImage = nil
                    self.isLoadingImage = false
                    self.errorMessage = "Fehler beim Laden des Logos: \(error.localizedDescription)"
                }
            }
        } else {
            await MainActor.run {
                self.logoImage = nil
                self.isLoadingImage = false
            }
        }
    }

    private func loadFunktionäre() async {
        do {
            let (loadedFunktionäre, _) = try await FirestoreManager.shared.getFunktionäre(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.funktionäre = loadedFunktionäre.filter { $0.vereinID == clubID }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Fehler beim Laden der Funktionäre: \(error.localizedDescription)"
            }
        }
    }
}

#Preview {
    ClubView(clubID: "exampleClubID")
}



//
//  ClubViewModel.swift

import SwiftUI
import FirebaseFirestore

class ClubViewModel: ObservableObject {
    @Published var clubs: [Club] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = []
    @Published var isShowingError = false
    @Published var isLoading: Bool = false
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    func loadClubs(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newClubs, newLastDoc) = try await FirestoreManager.shared.getClubs(
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore { clubs.append(contentsOf: newClubs) } else { clubs = newClubs }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }
    }

    func saveClub(_ club: Club) async {
        do {
            if club.id != nil {
                try await FirestoreManager.shared.updateClub(club: club)
            } else {
                try await FirestoreManager.shared.createClub(club: club)
            }
            await loadClubs()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
            }
        }
    }

    func deleteClub(_ club: Club) async {
        guard let id = club.id else {
            await MainActor.run {
                addErrorToQueue("Keine Club-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteClub(clubID: id)
            await loadClubs()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



//
//  EditClubView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers

struct EditClubView: View {
    @Binding var club: Club
    var onSave: (Club) -> Void
    var onCancel: () -> Void

    @State private var name: String
    @State private var mensLeague: String?
    @State private var womensLeague: String?
    @State private var mensAdresse: String = ""
    @State private var womensAdresse: String = ""
    @State private var mensKontaktTelefon: String = ""
    @State private var womensKontaktTelefon: String = ""
    @State private var mensKontaktEmail: String = ""
    @State private var womensKontaktEmail: String = ""
    @State private var mensClients: String = ""
    @State private var womensClients: String = ""
    @State private var land: String?
    @State private var memberCount: String = ""
    @State private var founded: String = ""
    @State private var logoURL: String = ""
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var logoImage: UIImage? = nil
    @State private var clubDocumentData: Data? = nil
    @State private var clubDocumentURL: String? = nil
    @State private var isUploadingImage = false
    @State private var errorMessage: String = ""
    @State private var showingCountryPicker = false
    @State private var showingDocumentPicker = false

    init(club: Binding<Club>, onSave: @escaping (Club) -> Void, onCancel: @escaping () -> Void) {
        self._club = club
        self.onSave = onSave
        self.onCancel = onCancel
        let wrappedClub = club.wrappedValue
        self._name = State(initialValue: wrappedClub.name)
        self._mensLeague = State(initialValue: wrappedClub.mensDepartment?.league)
        self._womensLeague = State(initialValue: wrappedClub.womensDepartment?.league)
        self._mensAdresse = State(initialValue: wrappedClub.mensDepartment?.adresse ?? "")
        self._womensAdresse = State(initialValue: wrappedClub.womensDepartment?.adresse ?? "")
        self._mensKontaktTelefon = State(initialValue: wrappedClub.mensDepartment?.kontaktTelefon ?? "")
        self._womensKontaktTelefon = State(initialValue: wrappedClub.womensDepartment?.kontaktTelefon ?? "")
        self._mensKontaktEmail = State(initialValue: wrappedClub.mensDepartment?.kontaktEmail ?? "")
        self._womensKontaktEmail = State(initialValue: wrappedClub.womensDepartment?.kontaktEmail ?? "")
        self._mensClients = State(initialValue: wrappedClub.mensDepartment?.clients?.joined(separator: ", ") ?? "")
        self._womensClients = State(initialValue: wrappedClub.womensDepartment?.clients?.joined(separator: ", ") ?? "")
        self._land = State(initialValue: wrappedClub.sharedInfo?.land)
        self._memberCount = State(initialValue: wrappedClub.sharedInfo?.memberCount.map(String.init) ?? "")
        self._founded = State(initialValue: wrappedClub.sharedInfo?.founded ?? "")
        self._logoURL = State(initialValue: wrappedClub.sharedInfo?.logoURL ?? "")
        self._clubDocumentURL = State(initialValue: wrappedClub.sharedInfo?.clubDocumentURL ?? nil)
    }

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Vereinsdaten").foregroundColor(.white)) {
                    TextField("Name", text: $name)
                        .foregroundColor(.white)
                    countryPicker
                    TextField("Mitgliederzahl", text: $memberCount)
                        .keyboardType(.numberPad)
                        .foregroundColor(.white)
                    TextField("Gegründet", text: $founded)
                        .foregroundColor(.white)

                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .images,
                        photoLibrary: .shared()
                    ) {
                        Label("Logo auswählen", systemImage: "photo")
                            .foregroundColor(.white)
                    }
                    TextField("Oder Logo-URL eingeben", text: $logoURL)
                        .autocapitalization(.none)
                        .keyboardType(.URL)
                        .foregroundColor(.white)
                    if isUploadingImage {
                        ProgressView("Logo wird hochgeladen...")
                            .tint(.white)
                    } else if let image = logoImage {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .frame(height: 100)
                            .clipShape(RoundedRectangle(cornerRadius: 10))
                    } else if !logoURL.isEmpty {
                        AsyncImage(url: URL(string: logoURL)) { phase in
                            switch phase {
                            case .success(let image):
                                image.resizable().scaledToFit().frame(height: 100).clipShape(RoundedRectangle(cornerRadius: 10))
                            case .failure:
                                Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                            case .empty:
                                ProgressView().tint(.white)
                            @unknown default:
                                Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                            }
                        }
                    }
                }
                Section(header: Text("Männerabteilung").foregroundColor(.white)) {
                    Picker("Liga", selection: $mensLeague) {
                        Text("Keine Liga").tag(String?.none)
                        ForEach(Constants.leaguesMale, id: \.self) { league in
                            Text(league).tag(String?.some(league))
                        }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Adresse", text: $mensAdresse)
                        .foregroundColor(.white)
                    TextField("Telefon", text: $mensKontaktTelefon)
                        .foregroundColor(.white)
                    TextField("E-Mail", text: $mensKontaktEmail)
                        .foregroundColor(.white)
                    TextField("Klienten (durch Komma getrennt)", text: $mensClients)
                        .foregroundColor(.white)
                }
                Section(header: Text("Frauenabteilung").foregroundColor(.white)) {
                    Picker("Liga", selection: $womensLeague) {
                        Text("Keine Liga").tag(String?.none)
                        ForEach(Constants.leaguesFemale, id: \.self) { league in
                            Text(league).tag(String?.some(league))
                        }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Adresse", text: $womensAdresse)
                        .foregroundColor(.white)
                    TextField("Telefon", text: $womensKontaktTelefon)
                        .foregroundColor(.white)
                    TextField("E-Mail", text: $womensKontaktEmail)
                        .foregroundColor(.white)
                    TextField("Klienten (durch Komma getrennt)", text: $womensClients)
                        .foregroundColor(.white)
                }
                Section(header: Text("Dokumente").foregroundColor(.white)) {
                    VStack(alignment: .leading, spacing: 10) {
                        Text("Vereinsdokument")
                            .font(.subheadline)
                            .foregroundColor(.white)
                        Button(action: { showingDocumentPicker = true }) {
                            Label("Dokument auswählen", systemImage: "doc")
                                .foregroundColor(.white)
                        }
                        if let clubDocumentURL = clubDocumentURL {
                            Text("Aktuell: \(clubDocumentURL.split(separator: "/").last ?? "")")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Verein bearbeiten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { onCancel() }
                        .foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        Task { await saveClub() }
                    }
                    .disabled(name.isEmpty || (mensLeague == nil && womensLeague == nil))
                    .foregroundColor(.white)
                }
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
                )
            }
            .onChange(of: selectedPhoto) { _ in Task { await loadSelectedImage() } }
            .sheet(isPresented: $showingDocumentPicker) {
                DocumentPicker(
                    allowedContentTypes: [.pdf, .text],
                    onPick: { url in
                        Task { await loadClubDocument(from: url) }
                    }
                )
            }
        }
    }

    private var countryPicker: some View {
        Button(action: { showingCountryPicker = true }) {
            Text(land ?? "Land auswählen")
                .foregroundColor(land == nil ? .gray : .white)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .sheet(isPresented: $showingCountryPicker) {
            NavigationView {
                MultiPicker(
                    title: "Land auswählen",
                    selection: Binding(
                        get: { [land].compactMap { $0 } },
                        set: { newValue in land = newValue.first }
                    ),
                    options: Constants.nationalities,
                    isNationalityPicker: false
                )
                .navigationTitle("Land")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button("Fertig") { showingCountryPicker = false }
                            .foregroundColor(.white)
                    }
                }
                .background(Color.black)
            }
        }
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else { return }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.logoImage = image
                    self.logoURL = ""
                }
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)"
            }
        }
    }

    private func loadClubDocument(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run {
                self.clubDocumentData = data
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden des Dokuments: \(error.localizedDescription)"
            }
        }
    }

    private func downloadImage(from urlString: String) async throws -> UIImage {
        guard let url = URL(string: urlString) else { throw URLError(.badURL) }
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else { throw URLError(.badServerResponse) }
        guard let image = UIImage(data: data) else { throw URLError(.cannotDecodeContentData) }
        return image
    }

    private func saveClub() async {
        do {
            var finalLogoURL = logoURL
            if let image = logoImage {
                await MainActor.run { isUploadingImage = true }
                guard let documentID = club.id else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Keine Club-ID verfügbar"])
                }
                finalLogoURL = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: image,
                    collection: "club_logos"
                )
            } else if !logoURL.isEmpty {
                let downloadedImage = try await downloadImage(from: logoURL)
                guard let documentID = club.id else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Keine Club-ID verfügbar"])
                }
                finalLogoURL = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: downloadedImage,
                    collection: "club_logos"
                )
            }

            let mensDepartment = Club.Department(
                league: mensLeague,
                adresse: mensAdresse.isEmpty ? nil : mensAdresse,
                kontaktTelefon: mensKontaktTelefon.isEmpty ? nil : mensKontaktTelefon,
                kontaktEmail: mensKontaktEmail.isEmpty ? nil : mensKontaktEmail,
                funktionäre: club.mensDepartment?.funktionäre ?? [],
                clients: mensClients.isEmpty ? nil : mensClients.split(separator: ",").map { $0.trimmingCharacters(in: .whitespaces) }
            )
            let womensDepartment = Club.Department(
                league: womensLeague,
                adresse: womensAdresse.isEmpty ? nil : womensAdresse,
                kontaktTelefon: womensKontaktTelefon.isEmpty ? nil : womensKontaktTelefon,
                kontaktEmail: womensKontaktEmail.isEmpty ? nil : womensKontaktEmail,
                funktionäre: club.womensDepartment?.funktionäre ?? [],
                clients: womensClients.isEmpty ? nil : womensClients.split(separator: ",").map { $0.trimmingCharacters(in: .whitespaces) }
            )
            var sharedInfo = Club.SharedInfo(
                land: land,
                memberCount: Int(memberCount) ?? nil,
                founded: founded.isEmpty ? nil : founded,
                logoURL: finalLogoURL.isEmpty ? nil : finalLogoURL,
                clubDocumentURL: clubDocumentURL // Jetzt korrekt definiert
            )

            if let docData = clubDocumentData {
                guard let documentID = club.id else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Keine Club-ID verfügbar"])
                }
                let url = try await FirestoreManager.shared.uploadFile(
                    documentID: documentID,
                    data: docData,
                    collection: "club_documents",
                    fileName: "doc_\(documentID)"
                )
                sharedInfo.clubDocumentURL = url
            }

            let updatedClub = Club(
                id: club.id,
                name: name,
                mensDepartment: mensLeague == nil && mensAdresse.isEmpty && mensKontaktTelefon.isEmpty && mensKontaktEmail.isEmpty && mensClients.isEmpty ? nil : mensDepartment,
                womensDepartment: womensLeague == nil && womensAdresse.isEmpty && womensKontaktTelefon.isEmpty && womensKontaktEmail.isEmpty && womensClients.isEmpty ? nil : womensDepartment,
                sharedInfo: sharedInfo
            )
            onSave(updatedClub)
            await MainActor.run { isUploadingImage = false }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                isUploadingImage = false
            }
        }
    }
}

#Preview {
    EditClubView(
        club: .constant(Club(
            name: "Bayern München",
            mensDepartment: nil,
            womensDepartment: nil,
            sharedInfo: nil
        )),
        onSave: { _ in },
        onCancel: {}
    )
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/6. Funktionär
//
//  AddFunktionärView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers
import UIKit

struct AddFunktionärView: View {
    @Binding var funktionär: Funktionär
    let onSave: (Funktionär) -> Void
    let onCancel: () -> Void

    @State private var name: String
    @State private var vorname: String
    @State private var vereinID: String?
    @State private var abteilung: String?
    @State private var positionImVerein: String?
    @State private var kontaktTelefon: String?
    @State private var kontaktEmail: String?
    @State private var adresse: String?
    @State private var geburtsdatum: Date?
    @State private var mannschaft: String?
    @State private var clubOptions: [Club] = []
    @State private var showingNationalityPicker = false
    @State private var selectedNationalities: [String]
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var profileImage: UIImage? = nil
    @State private var isUploadingImage = false
    @State private var imageURL: String = ""
    @State private var funktionärDocumentData: Data? = nil
    @State private var funktionärDocumentURL: String? = nil
    @State private var showingDocumentPicker = false
    @State private var errorMessage: String = ""

    init(funktionär: Binding<Funktionär>, onSave: @escaping (Funktionär) -> Void, onCancel: @escaping () -> Void) {
        self._funktionär = funktionär
        self.onSave = onSave
        self.onCancel = onCancel
        self._name = State(initialValue: funktionär.wrappedValue.name)
        self._vorname = State(initialValue: funktionär.wrappedValue.vorname)
        self._vereinID = State(initialValue: funktionär.wrappedValue.vereinID)
        self._abteilung = State(initialValue: funktionär.wrappedValue.abteilung)
        self._positionImVerein = State(initialValue: funktionär.wrappedValue.positionImVerein)
        self._kontaktTelefon = State(initialValue: funktionär.wrappedValue.kontaktTelefon)
        self._kontaktEmail = State(initialValue: funktionär.wrappedValue.kontaktEmail)
        self._adresse = State(initialValue: funktionär.wrappedValue.adresse)
        self._geburtsdatum = State(initialValue: funktionär.wrappedValue.geburtsdatum)
        self._mannschaft = State(initialValue: funktionär.wrappedValue.mannschaft)
        self._selectedNationalities = State(initialValue: funktionär.wrappedValue.nationalitaet ?? [])
        self._funktionärDocumentURL = State(initialValue: funktionär.wrappedValue.functionaryDocumentURL ?? nil)
    }

    var body: some View {
        NavigationView {
            mainFormContent
                .navigationTitle("Funktionär hinzufügen/bearbeiten")
                .foregroundColor(.white)
                .toolbar { toolbarItems }
                .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
                    )
                }
        }
    }

    private var mainFormContent: some View {
        Form {
            funktionärDataSection
            profileImageSection
            documentsSection
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
        .onChange(of: selectedPhoto) { _ in Task { await loadSelectedImage() } }
        .sheet(isPresented: $showingDocumentPicker) { documentPickerSheet }
        .sheet(isPresented: $showingNationalityPicker) { nationalityPickerSheet }
        .task { await loadClubOptions() }
    }

    private var toolbarItems: some ToolbarContent {
        Group {
            ToolbarItem(placement: .cancellationAction) {
                Button("Abbrechen") { onCancel() }
                    .foregroundColor(.white)
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Speichern") {
                    let updatedFunktionär = Funktionär(
                        id: funktionär.id,
                        name: name,
                        vorname: vorname,
                        abteilung: abteilung,
                        vereinID: vereinID,
                        kontaktTelefon: kontaktTelefon,
                        kontaktEmail: kontaktEmail,
                        adresse: adresse,
                        clients: funktionär.clients,
                        profilbildURL: funktionär.profilbildURL,
                        geburtsdatum: geburtsdatum,
                        positionImVerein: positionImVerein,
                        mannschaft: mannschaft,
                        nationalitaet: selectedNationalities.isEmpty ? nil : selectedNationalities,
                        functionaryDocumentURL: funktionärDocumentURL
                    )
                    Task { await saveFunktionär(updatedFunktionär: updatedFunktionär) }
                }
                .disabled(name.isEmpty || vorname.isEmpty || (vereinID != nil && abteilung == nil))
                .foregroundColor(.white)
            }
        }
    }

    private var funktionärDataSection: some View {
        Section(header: Text("Funktionär-Daten").foregroundColor(.white)) {
            TextField("Name", text: $name).foregroundColor(.white)
            TextField("Vorname", text: $vorname).foregroundColor(.white)
            vereinPicker
            abteilungPicker
            positionPicker
            nationalityButton
            contactFields
            datePicker
            TextField("Mannschaft", text: Binding(
                get: { mannschaft ?? "" },
                set: { mannschaft = $0.isEmpty ? nil : $0 }
            )).foregroundColor(.white)
        }
    }

    private var vereinPicker: some View {
        Picker("Verein", selection: $vereinID) {
            Text("Kein Verein").tag(String?.none)
            ForEach(clubOptions) { club in
                Text(club.name).tag(club.id as String?)
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(.white)
        .accentColor(.white)
        .onChange(of: vereinID) { _ in abteilung = nil }
    }

    private var abteilungPicker: some View {
        Group {
            if let selectedVereinID = vereinID,
               let selectedClub = clubOptions.first(where: { $0.id == selectedVereinID }) {
                Picker("Abteilung", selection: $abteilung) {
                    Text("Keine Abteilung").tag(String?.none)
                    if selectedClub.mensDepartment != nil {
                        Text("Männer").tag("Männer" as String?)
                    }
                    if selectedClub.womensDepartment != nil {
                        Text("Frauen").tag("Frauen" as String?)
                    }
                }
                .pickerStyle(.menu)
                .foregroundColor(.white)
                .accentColor(.white)
            }
        }
    }

    private var positionPicker: some View {
        Picker("Position im Verein", selection: $positionImVerein) {
            Text("Keine Position").tag(String?.none)
            ForEach(Constants.functionaryPositionOptions, id: \.self) { position in
                Text(position).tag(String?.some(position))
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(.white)
        .accentColor(.white)
    }

    private var nationalityButton: some View {
        Button(action: { showingNationalityPicker = true }) {
            Text(selectedNationalities.isEmpty ? "Nationalitäten auswählen" : selectedNationalities.joined(separator: ", "))
                .foregroundColor(selectedNationalities.isEmpty ? .gray : .white)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
    }

    private var contactFields: some View {
        Group {
            TextField("Telefon", text: Binding(
                get: { kontaktTelefon ?? "" },
                set: { kontaktTelefon = $0.isEmpty ? nil : $0 }
            )).foregroundColor(.white)
            TextField("E-Mail", text: Binding(
                get: { kontaktEmail ?? "" },
                set: { kontaktEmail = $0.isEmpty ? nil : $0 }
            )).foregroundColor(.white)
            TextField("Adresse", text: Binding(
                get: { adresse ?? "" },
                set: { adresse = $0.isEmpty ? nil : $0 }
            )).foregroundColor(.white)
        }
    }

    private var datePicker: some View {
        DatePicker("Geburtsdatum", selection: Binding(
            get: { geburtsdatum ?? Date() },
            set: { geburtsdatum = $0 }
        ), displayedComponents: .date)
            .foregroundColor(.white)
            .accentColor(.white)
    }

    private var profileImageSection: some View {
        Section(header: Text("Profilbild").foregroundColor(.white)) {
            PhotosPicker(selection: $selectedPhoto, matching: .images, photoLibrary: .shared()) {
                Label("Bild auswählen", systemImage: "photo").foregroundColor(.white)
            }
            TextField("Oder Bild-URL eingeben", text: $imageURL)
                .autocapitalization(.none)
                .keyboardType(.URL)
                .foregroundColor(.white)
            imagePreview
        }
    }

    private var imagePreview: some View {
        Group {
            if isUploadingImage {
                ProgressView("Bild wird hochgeladen...").tint(.white)
            } else if let image = profileImage {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            } else if let urlString = funktionär.profilbildURL, !urlString.isEmpty, let url = URL(string: urlString) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image.resizable().scaledToFit().frame(height: 100).clipShape(RoundedRectangle(cornerRadius: 10))
                    case .failure, .empty:
                        Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                    @unknown default:
                        Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                    }
                }
            } else {
                Image(systemName: "photo")
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .foregroundColor(.gray)
            }
        }
    }

    private var documentsSection: some View {
        Section(header: Text("Dokumente").foregroundColor(.white)) {
            VStack(alignment: .leading, spacing: 10) {
                Text("Funktionär-Dokument").font(.subheadline).foregroundColor(.white)
                Button(action: { showingDocumentPicker = true }) {
                    Label("Dokument auswählen", systemImage: "doc").foregroundColor(.white)
                }
                if let funktionärDocumentURL = funktionärDocumentURL {
                    Text("Hochgeladen: \(funktionärDocumentURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
        }
    }

    private var nationalityPickerSheet: some View {
        NavigationView {
            MultiPicker(
                title: "Nationalitäten auswählen",
                selection: $selectedNationalities,
                options: Constants.nationalities,
                isNationalityPicker: true
            )
            .navigationTitle("Nationalitäten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Fertig") { showingNationalityPicker = false }.foregroundColor(.white)
                }
            }
            .background(Color.black)
        }
    }

    private var documentPickerSheet: some View {
        DocumentPicker(
            allowedContentTypes: [.pdf, .text],
            onPick: { url in Task { await loadFunktionärDocument(from: url) } }
        )
    }

    private func loadClubOptions() async {
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run { self.clubOptions = clubs }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)" }
        }
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else {
            await MainActor.run { self.profileImage = nil }
            return
        }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.profileImage = image
                    self.imageURL = ""
                    self.funktionär.profilbildURL = nil
                }
            }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)" }
        }
    }

    private func loadFunktionärDocument(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run { self.funktionärDocumentData = data }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Laden des Dokuments: \(error.localizedDescription)" }
        }
    }

    private func downloadImage(from urlString: String) async throws -> UIImage {
        guard let url = URL(string: urlString) else { throw URLError(.badURL) }
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else { throw URLError(.badServerResponse) }
        guard let image = UIImage(data: data) else { throw URLError(.cannotDecodeContentData) }
        return image
    }

    private func saveFunktionär(updatedFunktionär: Funktionär) async {
        do {
            var funktionärToSave = updatedFunktionär
            let documentID = funktionär.id ?? UUID().uuidString
            if let image = profileImage {
                await MainActor.run { isUploadingImage = true }
                let url = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: image,
                    collection: "profile_images"
                )
                funktionärToSave.profilbildURL = url
            } else if !imageURL.isEmpty {
                let downloadedImage = try await downloadImage(from: imageURL)
                let url = try await FirestoreManager.shared.uploadImage(
                    documentID: documentID,
                    image: downloadedImage,
                    collection: "profile_images"
                )
                funktionärToSave.profilbildURL = url
            }

            if let docData = funktionärDocumentData {
                let url = try await FirestoreManager.shared.uploadFile(
                    documentID: documentID,
                    data: docData,
                    collection: "functionary_documents",
                    fileName: "doc_\(documentID)"
                )
                funktionärToSave.functionaryDocumentURL = url
            }

            if funktionärToSave.id != nil {
                try await FirestoreManager.shared.updateFunktionär(funktionär: funktionärToSave)
            } else {
                let newFunktionärID = try await FirestoreManager.shared.createFunktionär(funktionär: funktionärToSave)
                funktionärToSave.id = newFunktionärID
                try await FirestoreManager.shared.updateFunktionär(funktionär: funktionärToSave)
            }
            await MainActor.run { isUploadingImage = false }
            onSave(funktionärToSave)
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                isUploadingImage = false
            }
        }
    }
}

#Preview {
    AddFunktionärView(
        funktionär: .constant(Funktionär(
            name: "Mustermann",
            vorname: "Max",
            abteilung: "Männer",
            positionImVerein: "Trainer"
        )),
        onSave: { _ in },
        onCancel: {}
    )
}



//
//  EditFunktionärView.swift

import SwiftUI
import FirebaseFirestore
import PhotosUI
import UniformTypeIdentifiers

struct EditFunktionärView: View {
    @Binding var funktionär: Funktionär
    let onSave: (Funktionär) -> Void
    let onCancel: () -> Void

    @State private var name: String
    @State private var vorname: String
    @State private var vereinID: String?
    @State private var abteilung: String?
    @State private var positionImVerein: String?
    @State private var kontaktTelefon: String?
    @State private var kontaktEmail: String?
    @State private var adresse: String?
    @State private var geburtsdatum: Date?
    @State private var mannschaft: String?
    @State private var clubOptions: [Club] = []
    @State private var showingNationalityPicker = false
    @State private var selectedNationalities: [String]
    @State private var selectedPhoto: PhotosPickerItem? = nil
    @State private var profileImage: UIImage? = nil
    @State private var isUploadingImage = false
    @State private var imageURL: String = ""
    @State private var funktionärDocumentData: Data? = nil
    @State private var funktionärDocumentURL: String? = nil
    @State private var showingDocumentPicker = false
    @State private var errorMessage: String = ""

    init(funktionär: Binding<Funktionär>, onSave: @escaping (Funktionär) -> Void, onCancel: @escaping () -> Void) {
        self._funktionär = funktionär
        self.onSave = onSave
        self.onCancel = onCancel
        let wrappedValue = funktionär.wrappedValue
        self._name = State(initialValue: wrappedValue.name)
        self._vorname = State(initialValue: wrappedValue.vorname)
        self._vereinID = State(initialValue: wrappedValue.vereinID)
        self._abteilung = State(initialValue: wrappedValue.abteilung)
        self._positionImVerein = State(initialValue: wrappedValue.positionImVerein)
        self._kontaktTelefon = State(initialValue: wrappedValue.kontaktTelefon)
        self._kontaktEmail = State(initialValue: wrappedValue.kontaktEmail)
        self._adresse = State(initialValue: wrappedValue.adresse)
        self._geburtsdatum = State(initialValue: wrappedValue.geburtsdatum)
        self._mannschaft = State(initialValue: wrappedValue.mannschaft)
        self._selectedNationalities = State(initialValue: wrappedValue.nationalitaet ?? [])
        self._funktionärDocumentURL = State(initialValue: wrappedValue.functionaryDocumentURL)
    }

    var body: some View {
        NavigationView {
            mainFormContent
                .navigationTitle("Funktionär bearbeiten")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("Abbrechen") { onCancel() }
                            .foregroundColor(.white)
                    }
                    ToolbarItem(placement: .confirmationAction) {
                        Button("Speichern") {
                            let updatedFunktionär = Funktionär(
                                id: funktionär.id,
                                name: name,
                                vorname: vorname,
                                abteilung: abteilung,
                                vereinID: vereinID,
                                kontaktTelefon: kontaktTelefon,
                                kontaktEmail: kontaktEmail,
                                adresse: adresse,
                                clients: funktionär.clients,
                                profilbildURL: funktionär.profilbildURL,
                                geburtsdatum: geburtsdatum,
                                positionImVerein: positionImVerein,
                                mannschaft: mannschaft,
                                nationalitaet: selectedNationalities.isEmpty ? nil : selectedNationalities,
                                functionaryDocumentURL: funktionärDocumentURL
                            )
                            Task { await saveFunktionär(updatedFunktionär: updatedFunktionär) }
                        }
                        .disabled(name.isEmpty || vorname.isEmpty || (vereinID != nil && abteilung == nil))
                        .foregroundColor(.white)
                    }
                }
                .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) { errorMessage = "" }
                    )
                }
        }
    }

    // Hauptformular-Inhalt
    private var mainFormContent: some View {
        Form {
            funktionärDataSection
            profileImageSection
            documentsSection
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
        .onChange(of: selectedPhoto) { _ in Task { await loadSelectedImage() } }
        .sheet(isPresented: $showingDocumentPicker) { documentPickerSheet }
        .sheet(isPresented: $showingNationalityPicker) { nationalityPickerSheet }
        .task { await loadClubOptions() }
    }

    // Funktionär-Daten Sektion
    private var funktionärDataSection: some View {
        Section(header: Text("Funktionär-Daten").foregroundColor(.white)) {
            TextField("Name", text: $name)
                .foregroundColor(.white)
            TextField("Vorname", text: $vorname)
                .foregroundColor(.white)
            vereinPicker
            abteilungPicker
            positionPicker
            nationalityButton
            contactFields
            datePicker
            TextField("Mannschaft", text: Binding(
                get: { mannschaft ?? "" },
                set: { mannschaft = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
        }
    }

    // Verein Picker
    private var vereinPicker: some View {
        Picker("Verein", selection: $vereinID) {
            Text("Kein Verein").tag(String?.none)
            ForEach(clubOptions) { club in
                Text(club.name).tag(club.id as String?)
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(.white)
        .accentColor(.white)
        .onChange(of: vereinID) { _ in abteilung = nil }
    }

    // Abteilung Picker
    private var abteilungPicker: some View {
        Group {
            if let selectedVereinID = vereinID,
               let selectedClub = clubOptions.first(where: { $0.id == selectedVereinID }) {
                Picker("Abteilung", selection: $abteilung) {
                    Text("Keine Abteilung").tag(String?.none)
                    if selectedClub.mensDepartment != nil {
                        Text("Männer").tag("Männer" as String?)
                    }
                    if selectedClub.womensDepartment != nil {
                        Text("Frauen").tag("Frauen" as String?)
                    }
                }
                .pickerStyle(.menu)
                .foregroundColor(.white)
                .accentColor(.white)
            }
        }
    }

    // Position Picker
    private var positionPicker: some View {
        Picker("Position im Verein", selection: $positionImVerein) {
            Text("Keine Position").tag(String?.none)
            ForEach(Constants.functionaryPositionOptions, id: \.self) { position in
                Text(position).tag(String?.some(position))
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(.white)
        .accentColor(.white)
    }

    // Nationalitäten Button
    private var nationalityButton: some View {
        Button(action: { showingNationalityPicker = true }) {
            Text(selectedNationalities.isEmpty ? "Nationalitäten auswählen" : selectedNationalities.joined(separator: ", "))
                .foregroundColor(selectedNationalities.isEmpty ? .gray : .white)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
    }

    // Kontaktfelder
    private var contactFields: some View {
        Group {
            TextField("Telefon", text: Binding(
                get: { kontaktTelefon ?? "" },
                set: { kontaktTelefon = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("E-Mail", text: Binding(
                get: { kontaktEmail ?? "" },
                set: { kontaktEmail = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("Adresse", text: Binding(
                get: { adresse ?? "" },
                set: { adresse = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
        }
    }

    // Geburtsdatum Picker
    private var datePicker: some View {
        DatePicker("Geburtsdatum", selection: Binding(
            get: { geburtsdatum ?? Date() },
            set: { geburtsdatum = $0 }
        ), displayedComponents: .date)
            .foregroundColor(.white)
            .accentColor(.white)
    }

    // Profilbild Sektion
    private var profileImageSection: some View {
        Section(header: Text("Profilbild").foregroundColor(.white)) {
            PhotosPicker(
                selection: $selectedPhoto,
                matching: .images,
                photoLibrary: .shared()
            ) {
                Label("Bild aus Fotogalerie auswählen", systemImage: "photo")
                    .foregroundColor(.white)
            }
            TextField("Oder Bild-URL eingeben", text: $imageURL)
                .autocapitalization(.none)
                .keyboardType(.URL)
                .foregroundColor(.white)
            imagePreview
        }
    }

    // Bildvorschau
    private var imagePreview: some View {
        Group {
            if isUploadingImage {
                ProgressView("Bild wird hochgeladen...")
                    .tint(.white)
            } else if let image = profileImage {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            } else if let urlString = funktionär.profilbildURL, !urlString.isEmpty, let url = URL(string: urlString) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image.resizable().scaledToFit().frame(height: 100).clipShape(RoundedRectangle(cornerRadius: 10))
                    case .failure, .empty:
                        Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                    @unknown default:
                        Image(systemName: "photo").resizable().scaledToFit().frame(height: 100).foregroundColor(.gray)
                    }
                }
            } else {
                Image(systemName: "photo")
                    .resizable()
                    .scaledToFit()
                    .frame(height: 100)
                    .foregroundColor(.gray)
            }
        }
    }

    // Dokumente Sektion
    private var documentsSection: some View {
        Section(header: Text("Dokumente").foregroundColor(.white)) {
            VStack(alignment: .leading, spacing: 10) {
                Text("Funktionär-Dokument")
                    .font(.subheadline)
                    .foregroundColor(.white)
                Button(action: { showingDocumentPicker = true }) {
                    Label("Dokument auswählen", systemImage: "doc")
                        .foregroundColor(.white)
                }
                if let funktionärDocumentURL = funktionärDocumentURL {
                    Text("Aktuell: \(funktionärDocumentURL.split(separator: "/").last ?? "")")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
        }
    }

    // Nationalitäten-Picker Sheet
    private var nationalityPickerSheet: some View {
        NavigationView {
            MultiPicker(
                title: "Nationalitäten auswählen",
                selection: $selectedNationalities,
                options: Constants.nationalities,
                isNationalityPicker: true
            )
            .navigationTitle("Nationalitäten")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Fertig") { showingNationalityPicker = false }
                        .foregroundColor(.white)
                }
            }
            .background(Color.black)
        }
    }

    // Dokumenten-Picker Sheet
    private var documentPickerSheet: some View {
        DocumentPicker(
            allowedContentTypes: [.pdf, .text],
            onPick: { url in Task { await loadFunktionärDocument(from: url) } }
        )
    }

    private func loadClubOptions() async {
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run { self.clubOptions = clubs }
        } catch {
            print("Fehler beim Laden der Vereine: \(error.localizedDescription)")
            await MainActor.run { errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)" }
        }
    }

    private func loadSelectedImage() async {
        guard let photoItem = selectedPhoto else {
            await MainActor.run { self.profileImage = nil }
            return
        }
        do {
            if let data = try await photoItem.loadTransferable(type: Data.self),
               let image = UIImage(data: data) {
                await MainActor.run {
                    self.profileImage = image
                    self.imageURL = ""
                    self.funktionär.profilbildURL = nil
                }
            }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Laden des Bildes: \(error.localizedDescription)" }
        }
    }

    private func loadFunktionärDocument(from url: URL) async {
        do {
            let data = try Data(contentsOf: url)
            await MainActor.run { self.funktionärDocumentData = data }
        } catch {
            await MainActor.run { errorMessage = "Fehler beim Laden des Dokuments: \(error.localizedDescription)" }
        }
    }

    private func downloadImage(from urlString: String) async throws -> UIImage {
        guard let url = URL(string: urlString) else { throw URLError(.badURL) }
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else { throw URLError(.badServerResponse) }
        guard let image = UIImage(data: data) else { throw URLError(.cannotDecodeContentData) }
        return image
    }

    private func saveFunktionär(updatedFunktionär: Funktionär) async {
        do {
            var funktionärToSave = updatedFunktionär
            if let funktionärID = funktionärToSave.id {
                await MainActor.run { isUploadingImage = true }
                if let image = profileImage {
                    let url = try await FirestoreManager.shared.uploadImage(
                        documentID: funktionärID,
                        image: image,
                        collection: "profile_images"
                    )
                    funktionärToSave.profilbildURL = url
                } else if !imageURL.isEmpty {
                    let downloadedImage = try await downloadImage(from: imageURL)
                    let url = try await FirestoreManager.shared.uploadImage(
                        documentID: funktionärID,
                        image: downloadedImage,
                        collection: "profile_images"
                    )
                    funktionärToSave.profilbildURL = url
                }

                if let docData = funktionärDocumentData {
                    let url = try await FirestoreManager.shared.uploadFile(
                        documentID: funktionärID,
                        data: docData,
                        collection: "functionary_documents",
                        fileName: "doc_\(funktionärID)"
                    )
                    funktionärToSave.functionaryDocumentURL = url
                }

                try await FirestoreManager.shared.updateFunktionär(funktionär: funktionärToSave)
                await MainActor.run { isUploadingImage = false }
                onSave(funktionärToSave)
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
                isUploadingImage = false
            }
        }
    }
}

#Preview {
    EditFunktionärView(
        funktionär: .constant(Funktionär(
            name: "Mustermann",
            vorname: "Max",
            abteilung: "Männer",
            positionImVerein: "Trainer"
        )),
        onSave: { _ in },
        onCancel: {}
    )
}



//
//  FunktionärListView.swift

import SwiftUI
import FirebaseFirestore

struct FunktionärListView: View {
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var viewModel: FunktionärViewModel
    @Environment(\.colorScheme) var colorScheme
    @State private var showingAddFunktionärSheet = false
    @State private var showingEditFunktionärSheet = false
    @State private var newFunktionär = Funktionär(name: "", vorname: "")
    @State private var selectedFunktionär: Funktionär?

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                if viewModel.funktionäre.isEmpty {
                    Text("Keine Funktionäre vorhanden.")
                        .foregroundColor(.gray)
                        .padding()
                } else {
                    List {
                        ForEach(viewModel.funktionäre, id: \.id) { funktionär in
                            NavigationLink(destination: FunktionärView(funktionär: .constant(funktionär))) {
                                funktionärRow(for: funktionär)
                            }
                            .swipeActions {
                                Button(role: .destructive) {
                                    Task {
                                        await viewModel.deleteFunktionär(funktionär)
                                    }
                                } label: {
                                    Label("Löschen", systemImage: "trash")
                                }
                                Button(action: {
                                    selectedFunktionär = funktionär
                                    showingEditFunktionärSheet = true
                                }) {
                                    Label("Bearbeiten", systemImage: "pencil")
                                }
                                .tint(.blue)
                            }
                        }
                        if viewModel.isLoading {
                            ProgressView()
                                .frame(maxWidth: .infinity)
                        }
                    }
                    .background(colorScheme == .dark ? Color.black : Color(.systemBackground))
                }
            }
            .navigationTitle("Funktionäre verwalten")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { showingAddFunktionärSheet = true }) {
                        Image(systemName: "plus")
                            .foregroundColor(.blue)
                    }
                }
            }
            .sheet(isPresented: $showingAddFunktionärSheet) {
                AddFunktionärView(
                    funktionär: $newFunktionär,
                    onSave: { updatedFunktionär in
                        Task {
                            await viewModel.saveFunktionär(updatedFunktionär)
                            await MainActor.run {
                                resetNewFunktionär()
                                showingAddFunktionärSheet = false
                            }
                        }
                    },
                    onCancel: {
                        resetNewFunktionär()
                        showingAddFunktionärSheet = false
                    }
                )
            }
            .sheet(isPresented: $showingEditFunktionärSheet) {
                if let selectedFunktionär = selectedFunktionär {
                    EditFunktionärView(
                        funktionär: Binding(
                            get: { selectedFunktionär },
                            set: { self.selectedFunktionär = $0 }
                        ),
                        onSave: { updatedFunktionär in
                            Task {
                                await viewModel.saveFunktionär(updatedFunktionär)
                                await MainActor.run {
                                    showingEditFunktionärSheet = false
                                    self.selectedFunktionär = nil
                                }
                            }
                        },
                        onCancel: {
                            showingEditFunktionärSheet = false
                            self.selectedFunktionär = nil
                        }
                    )
                }
            }
            .alert(isPresented: $viewModel.isShowingError) {
                Alert(
                    title: Text("Fehler"),
                    message: Text(viewModel.errorMessage),
                    dismissButton: .default(Text("OK")) {
                        viewModel.resetError()
                    }
                )
            }
            .task {
                await viewModel.loadClubs()
            }
        }
    }

    @ViewBuilder
    private func funktionärRow(for funktionär: Funktionär) -> some View {
        HStack(spacing: 10) {
            if let profilbildURL = funktionär.profilbildURL, let url = URL(string: profilbildURL) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                            .frame(width: 40, height: 40)
                    case .success(let image):
                        image
                            .resizable()
                            .scaledToFill()
                            .frame(width: 40, height: 40)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    case .failure:
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .scaledToFill()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    @unknown default:
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .scaledToFill()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    }
                }
            } else {
                Image(systemName: "person.circle.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(width: 40, height: 40)
                    .foregroundColor(.gray)
                    .clipShape(Circle())
                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
            }

            VStack(alignment: .leading, spacing: 2) {
                Text("\(funktionär.vorname) \(funktionär.name)")
                    .font(.headline)
                    .foregroundColor(colorScheme == .dark ? .white : .black)
                if let position = funktionär.positionImVerein {
                    Text(position)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                if let vereinID = funktionär.vereinID,
                   let club = viewModel.clubs.first(where: { $0.id == vereinID }) {
                    HStack(spacing: 5) {
                        if let logoURL = club.sharedInfo?.logoURL, let url = URL(string: logoURL) {
                            AsyncImage(url: url) { phase in
                                switch phase {
                                case .success(let image):
                                    image
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .clipShape(Circle())
                                case .failure, .empty:
                                    Image(systemName: "building.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                @unknown default:
                                    Image(systemName: "building.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                }
                            }
                        } else {
                            Image(systemName: "building.fill")
                                .resizable()
                                .scaledToFit()
                                .frame(width: 20, height: 20)
                                .foregroundColor(.gray)
                                .clipShape(Circle())
                        }
                        Text(club.name)
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
                if let abteilung = funktionär.abteilung {
                    Text(abteilung)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding(.vertical, 5)
    }

    private func resetNewFunktionär() {
        newFunktionär = Funktionär(
            name: "",
            vorname: ""
        )
    }
}

#Preview {
    FunktionärListView()
        .environmentObject(AuthManager())
        .environmentObject(FunktionärViewModel())
}



//
//  FunktinoärView.swift

import SwiftUI

struct FunktionärView: View {
    @Binding var funktionär: Funktionär
    @State private var image: UIImage? = nil
    @State private var showingEditSheet = false
    @State private var clubName: String? = nil
    @State private var clubLogoURL: String? = nil

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    var body: some View {
        NavigationStack {
            VStack {
                if let image = image {
                    Image(uiImage: image)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 100, height: 100)
                        .clipShape(Circle())
                } else {
                    Image(systemName: "person.circle.fill")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 100, height: 100)
                        .foregroundColor(.gray)
                        .clipShape(Circle())
                }

                Text("\(funktionär.vorname) \(funktionär.name)\(calculateAge().map { ", \($0) Jahre" } ?? "")")
                    .font(.title)
                    .padding()
                    .foregroundColor(.white)

                if let vereinID = funktionär.vereinID {
                    HStack(spacing: 10) {
                        if let logoURL = clubLogoURL, let url = URL(string: logoURL) {
                            AsyncImage(url: url) { phase in
                                switch phase {
                                case .success(let image):
                                    image
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .clipShape(Circle())
                                case .failure, .empty:
                                    Image(systemName: "building.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                @unknown default:
                                    Image(systemName: "building.fill")
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 20, height: 20)
                                        .foregroundColor(.gray)
                                        .clipShape(Circle())
                                }
                            }
                        } else {
                            Image(systemName: "building.fill")
                                .resizable()
                                .scaledToFit()
                                .frame(width: 20, height: 20)
                                .foregroundColor(.gray)
                                .clipShape(Circle())
                        }
                        Text(clubName ?? vereinID)
                            .font(.headline)
                            .foregroundColor(.white)
                    }
                } else {
                    Text("Ohne Verein")
                        .font(.headline)
                        .foregroundColor(.white)
                }

                if let position = funktionär.positionImVerein {
                    Text("Position: \(position)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }

                if let abteilung = funktionär.abteilung {
                    Text("Abteilung: \(abteilung)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }

                if let mannschaft = funktionär.mannschaft {
                    Text("Mannschaft: \(mannschaft)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }

                if let nationalitaet = funktionär.nationalitaet, !nationalitaet.isEmpty {
                    Text("Nationalität: \(nationalitaet.joined(separator: ", "))")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }

                if let kontaktEmail = funktionär.kontaktEmail {
                    Text("E-Mail: \(kontaktEmail)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }
                if let kontaktTelefon = funktionär.kontaktTelefon {
                    Text("Telefon: \(kontaktTelefon)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }
                if let adresse = funktionär.adresse {
                    Text("Adresse: \(adresse)")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }
                if let documentURL = funktionär.functionaryDocumentURL {
                    Text("Dokument: \(documentURL.split(separator: "/").last ?? "")")
                        .font(.subheadline)
                        .foregroundColor(.white)
                }

                HStack {
                    Spacer()
                    Button(action: { showingEditSheet = true }) {
                        Image(systemName: "pencil")
                            .font(.system(size: 16))
                            .foregroundColor(.white)
                    }
                    .sheet(isPresented: $showingEditSheet) {
                        EditFunktionärView(
                            funktionär: $funktionär,
                            onSave: { updatedFunktionär in
                                Task {
                                    do {
                                        try await FirestoreManager.shared.updateFunktionär(funktionär: updatedFunktionär)
                                        await loadClubDetails()
                                        print("Funktionär erfolgreich aktualisiert")
                                    } catch {
                                        print("Fehler beim Aktualisieren: \(error.localizedDescription)")
                                    }
                                }
                                showingEditSheet = false
                            },
                            onCancel: { showingEditSheet = false }
                        )
                    }
                    Spacer()
                }
                .padding(.bottom)

                Spacer()
            }
            .padding()
            .background(Color.black)
            .navigationTitle("\(funktionär.vorname) \(funktionär.name)")
            .foregroundColor(.white)
            .task {
                loadImage()
                await loadClubDetails()
            }
        }
    }

    private func loadImage() {
        if let profilbildURL = funktionär.profilbildURL, let url = URL(string: profilbildURL) {
            URLSession.shared.dataTask(with: url) { data, _, _ in
                if let data = data, let loadedImage = UIImage(data: data) {
                    DispatchQueue.main.async {
                        self.image = loadedImage
                    }
                }
            }.resume()
        }
    }

    private func loadClubDetails() async {
        guard let vereinID = funktionär.vereinID else { return }
        do {
            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            if let club = clubs.first(where: { $0.id == vereinID }) {
                await MainActor.run {
                    clubName = club.name
                    clubLogoURL = club.sharedInfo?.logoURL
                }
            }
        } catch {
            print("Fehler beim Laden der Vereinsdetails: \(error.localizedDescription)")
        }
    }

    private func calculateAge() -> Int? {
        guard let birthDate = funktionär.geburtsdatum else { return nil }
        let calendar = Calendar.current
        let now = Date()
        let ageComponents = calendar.dateComponents([.year], from: birthDate, to: now)
        return ageComponents.year
    }
}



//
//  FunktionärViewModel.swift

import SwiftUI
import FirebaseFirestore

class FunktionärViewModel: ObservableObject {
    @Published var funktionäre: [Funktionär] = []
    @Published var clubs: [Club] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = []
    @Published var isShowingError = false
    @Published var isLoading: Bool = false
    private var listener: ListenerRegistration?
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    init() {
        setupRealtimeListener()
    }

    deinit {
        listener?.remove()
    }

    private func setupRealtimeListener() {
        listener = Firestore.firestore().collection("funktionare")
            .order(by: "name")
            .addSnapshotListener { [weak self] snapshot, error in
                guard let self = self else { return }
                if let error = error {
                    self.addErrorToQueue("Fehler beim Listener: \(error.localizedDescription)")
                    print("Listener-Fehler: \(error.localizedDescription)")
                    return
                }
                guard let documents = snapshot?.documents else {
                    print("Keine Dokumente gefunden")
                    return
                }
                print("Anzahl der Dokumente: \(documents.count)")
                print("Dokument-IDs: \(documents.map { $0.documentID })")
                let updatedFunktionäre = documents.compactMap { doc -> Funktionär? in
                    do {
                        var funktionär = try doc.data(as: Funktionär.self)
                        funktionär.id = doc.documentID
                        print("Geladener Funktionär - ID: \(funktionär.id ?? "nil"), Name: \(funktionär.vorname) \(funktionär.name)")
                        return funktionär
                    } catch {
                        print("Fehler beim Dekodieren des Funktionärs \(doc.documentID): \(error)")
                        print("Rohdaten des Dokuments: \(doc.data())")
                        return nil
                    }
                }
                DispatchQueue.main.async {
                    print("Aktualisierte Funktionäre (vor Zuweisung): \(updatedFunktionäre.map { "\($0.id ?? "nil"): \($0.vorname) \($0.name)" })")
                    self.funktionäre = updatedFunktionäre
                    self.isLoading = false
                }
            }
    }

    func loadFunktionäre(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newFunktionäre, newLastDoc) = try await FirestoreManager.shared.getFunktionäre(
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore { funktionäre.append(contentsOf: newFunktionäre) } else { funktionäre = newFunktionäre }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }
    }

    func saveFunktionär(_ funktionär: Funktionär) async {
        do {
            if funktionär.id != nil {
                try await FirestoreManager.shared.updateFunktionär(funktionär: funktionär)
                print("Funktionär erfolgreich aktualisiert in Firestore")
            } else {
                try await FirestoreManager.shared.createFunktionär(funktionär: funktionär)
                print("Neuer Funktionär erstellt in Firestore")
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
                print("Fehler beim Speichern: \(error.localizedDescription)")
            }
        }
    }

    func deleteFunktionär(_ funktionär: Funktionär) async {
        guard let id = funktionär.id else {
            await MainActor.run {
                addErrorToQueue("Keine Funktionär-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteFunktionär(funktionärID: id)
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    func loadClubs() async {
        do {
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.clubs = loadedClubs
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Vereine: \(error.localizedDescription)")
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/7. TransferProzess
//
//  AddEditNoteView.swift

import SwiftUI

struct AddEditNoteView: View {
    @Binding var transferProcess: TransferProcess
    @State var note: Note?
    let onSave: (Note) -> Void
    @Environment(\.dismiss) var dismiss

    @State private var beschreibung: String
    @State private var vereinsDokumenteText: String // Für die Eingabe als kommagetrennte Liste

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    init(transferProcess: Binding<TransferProcess>, note: Note?, onSave: @escaping (Note) -> Void) {
        self._transferProcess = transferProcess
        self.note = note
        self.onSave = onSave

        // Initialisierung der Zustandsvariablen
        let initialNote = note ?? Note(beschreibung: "")
        _beschreibung = State(initialValue: initialNote.beschreibung)
        _vereinsDokumenteText = State(initialValue: initialNote.vereinsDokumente?.joined(separator: ", ") ?? "")
    }

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                ScrollView {
                    VStack(spacing: 16) {
                        // Titel
                        Text(note == nil ? "Hinweis hinzufügen" : "Hinweis bearbeiten")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(textColor)
                            .padding(.top, 16)

                        // Hinweis-Details
                        VStack(alignment: .leading, spacing: 12) {
                            // Beschreibung
                            TextField("Beschreibung", text: $beschreibung, axis: .vertical)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Vereinsdokumente
                            TextField("Dokumente (URLs, kommagetrennt)", text: $vereinsDokumenteText, axis: .vertical)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )
                        }
                        .padding()
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(accentColor.opacity(0.2), lineWidth: 1)
                        )
                        .padding(.horizontal)
                    }
                    .padding(.bottom, 16)
                }
            }
            .navigationTitle(note == nil ? "Hinweis hinzufügen" : "Hinweis bearbeiten")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { dismiss() }
                        .foregroundColor(accentColor)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        let vereinsDokumente = vereinsDokumenteText.split(separator: ",")
                            .map { String($0.trimmingCharacters(in: .whitespaces)) }
                            .filter { !$0.isEmpty }
                        let updatedNote = Note(
                            id: note?.id ?? UUID().uuidString,
                            beschreibung: beschreibung,
                            vereinsDokumente: vereinsDokumente.isEmpty ? nil : vereinsDokumente
                        )
                        onSave(updatedNote)
                        dismiss()
                    }
                    .foregroundColor(beschreibung.isEmpty ? secondaryTextColor : accentColor)
                    .disabled(beschreibung.isEmpty)
                }
            }
        }
    }
}

#Preview {
    AddEditNoteView(
        transferProcess: .constant(TransferProcess(clientID: "1", vereinID: "1")),
        note: Note(beschreibung: "Verein interessiert", vereinsDokumente: ["doc1.pdf"]),
        onSave: { _ in }
    )
}



//
//  AddEditReminderView.swift

import SwiftUI

struct AddEditReminderView: View {
    @Binding var transferProcess: TransferProcess
    @State var reminder: Reminder?
    let onSave: (Reminder) -> Void
    @Environment(\.dismiss) var dismiss

    @State private var datum: Date
    @State private var beschreibung: String
    @State private var kategorie: String

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    init(transferProcess: Binding<TransferProcess>, reminder: Reminder?, onSave: @escaping (Reminder) -> Void) {
        self._transferProcess = transferProcess
        self.reminder = reminder
        self.onSave = onSave

        // Initialisierung der Zustandsvariablen
        let initialReminder = reminder ?? Reminder(datum: Date(), beschreibung: "")
        _datum = State(initialValue: initialReminder.datum)
        _beschreibung = State(initialValue: initialReminder.beschreibung)
        _kategorie = State(initialValue: initialReminder.kategorie ?? "")
    }

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                ScrollView {
                    VStack(spacing: 16) {
                        // Titel
                        Text(reminder == nil ? "Erinnerung hinzufügen" : "Erinnerung bearbeiten")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(textColor)
                            .padding(.top, 16)

                        // Erinnerung-Details
                        VStack(alignment: .leading, spacing: 12) {
                            // Datum
                            DatePicker("Datum", selection: $datum, displayedComponents: [.date, .hourAndMinute])
                                .foregroundColor(textColor)
                                .accentColor(accentColor)
                                .padding(.vertical, 8)
                                .padding(.horizontal, 12)
                                .background(cardBackgroundColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Beschreibung
                            TextField("Beschreibung", text: $beschreibung)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Kategorie
                            Picker("Kategorie", selection: $kategorie) {
                                Text("Keine").tag("")
                                Text("Nachfrage").tag("nachfrageErinnerung")
                                Text("Vertragsprüfung").tag("vertragsprüfung")
                                Text("Termin").tag("termin")
                            }
                            .pickerStyle(.menu)
                            .padding(.vertical, 8)
                            .padding(.horizontal, 12)
                            .background(cardBackgroundColor)
                            .foregroundColor(textColor)
                            .clipShape(RoundedRectangle(cornerRadius: 8))
                        }
                        .padding()
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(accentColor.opacity(0.2), lineWidth: 1)
                        )
                        .padding(.horizontal)
                    }
                    .padding(.bottom, 16)
                }
            }
            .navigationTitle(reminder == nil ? "Erinnerung hinzufügen" : "Erinnerung bearbeiten")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { dismiss() }
                        .foregroundColor(accentColor)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        let updatedReminder = Reminder(
                            id: reminder?.id ?? UUID().uuidString,
                            datum: datum,
                            beschreibung: beschreibung,
                            kategorie: kategorie.isEmpty ? nil : kategorie
                        )
                        onSave(updatedReminder)
                        dismiss()
                    }
                    .foregroundColor(beschreibung.isEmpty ? secondaryTextColor : accentColor)
                    .disabled(beschreibung.isEmpty)
                }
            }
        }
    }
}

#Preview {
    AddEditReminderView(
        transferProcess: .constant(TransferProcess(clientID: "1", vereinID: "1")),
        reminder: Reminder(datum: Date(), beschreibung: "Nachfragen", kategorie: "nachfrageErinnerung"),
        onSave: { _ in }
    )
}



//
//  AddEditStepView.swift

import SwiftUI

struct AddEditStepView: View {
    @Binding var transferProcess: TransferProcess
    @State var step: Step?
    let onSave: (Step) -> Void
    @Environment(\.dismiss) var dismiss

    @State private var typ: String
    @State private var status: String
    @State private var datum: Date
    @State private var notizen: String
    @State private var erfolgschance: String
    @State private var checklisteText: String // Für die Eingabe als kommagetrennte Liste

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    init(transferProcess: Binding<TransferProcess>, step: Step?, onSave: @escaping (Step) -> Void) {
        self._transferProcess = transferProcess
        self.step = step
        self.onSave = onSave

        // Initialisierung der Zustandsvariablen
        let initialStep = step ?? Step(typ: "Kontaktaufnahme", status: "geplant", datum: Date())
        _typ = State(initialValue: initialStep.typ)
        _status = State(initialValue: initialStep.status)
        _datum = State(initialValue: initialStep.datum)
        _notizen = State(initialValue: initialStep.notizen ?? "")
        _erfolgschance = State(initialValue: initialStep.erfolgschance.map { String($0) } ?? "")
        _checklisteText = State(initialValue: initialStep.checkliste?.joined(separator: ", ") ?? "")
    }

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                ScrollView {
                    VStack(spacing: 16) {
                        // Titel
                        Text(step == nil ? "Schritt hinzufügen" : "Schritt bearbeiten")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(textColor)
                            .padding(.top, 16)

                        // Schritt-Details
                        VStack(alignment: .leading, spacing: 12) {
                            // Typ
                            Picker("Typ", selection: $typ) {
                                Text("Kontaktaufnahme").tag("Kontaktaufnahme")
                                Text("Zweiter Kontakt").tag("zweitKontakt")
                                Text("Klient informieren").tag("klientInfo")
                                Text("Vertrag verhandeln").tag("vertragVerhandeln")
                            }
                            .pickerStyle(.menu)
                            .padding(.vertical, 8)
                            .padding(.horizontal, 12)
                            .background(cardBackgroundColor)
                            .foregroundColor(textColor)
                            .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Status
                            Picker("Status", selection: $status) {
                                Text("Geplant").tag("geplant")
                                Text("Abgeschlossen").tag("abgeschlossen")
                            }
                            .pickerStyle(.menu)
                            .padding(.vertical, 8)
                            .padding(.horizontal, 12)
                            .background(cardBackgroundColor)
                            .foregroundColor(textColor)
                            .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Datum
                            DatePicker("Datum", selection: $datum, displayedComponents: [.date, .hourAndMinute])
                                .foregroundColor(textColor)
                                .accentColor(accentColor)
                                .padding(.vertical, 8)
                                .padding(.horizontal, 12)
                                .background(cardBackgroundColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Notizen
                            TextField("Notizen", text: $notizen, axis: .vertical)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Erfolgschance
                            TextField("Erfolgschance (%)", text: $erfolgschance)
                                .keyboardType(.numberPad)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Checkliste
                            TextField("Checkliste (kommagetrennt)", text: $checklisteText, axis: .vertical)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )
                        }
                        .padding()
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(accentColor.opacity(0.2), lineWidth: 1)
                        )
                        .padding(.horizontal)
                    }
                    .padding(.bottom, 16)
                }
            }
            .navigationTitle(step == nil ? "Schritt hinzufügen" : "Schritt bearbeiten")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { dismiss() }
                        .foregroundColor(accentColor)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        let checkliste = checklisteText.split(separator: ",")
                            .map { String($0.trimmingCharacters(in: .whitespaces)) }
                            .filter { !$0.isEmpty }
                        let updatedStep = Step(
                            id: step?.id ?? UUID().uuidString,
                            typ: typ,
                            status: status,
                            datum: datum,
                            notizen: notizen.isEmpty ? nil : notizen,
                            erfolgschance: Int(erfolgschance),
                            checkliste: checkliste.isEmpty ? nil : checkliste
                        )
                        onSave(updatedStep)
                        dismiss()
                    }
                    .foregroundColor(typ.isEmpty ? secondaryTextColor : accentColor)
                    .disabled(typ.isEmpty)
                }
            }
        }
    }
}

#Preview {
    AddEditStepView(
        transferProcess: .constant(TransferProcess(clientID: "1", vereinID: "1")),
        step: Step(typ: "Kontaktaufnahme", status: "geplant", datum: Date(), erfolgschance: 80, checkliste: ["Gehalt abfragen"]),
        onSave: { _ in }
    )
}



//
//  AddEditTransferDeatilView.swift

import SwiftUI

struct AddEditTransferDetailsView: View {
    @Binding var transferProcess: TransferProcess
    @State var transferDetails: TransferDetails?
    let onSave: (TransferDetails) -> Void
    @Environment(\.dismiss) var dismiss

    @State private var vonVereinID = ""
    @State private var zuVereinID = ""
    @State private var funktionärID = ""
    @State private var datum = Date()
    @State private var ablösesumme = ""
    @State private var isAblösefrei = false
    @State private var transferdetails = ""

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                ScrollView {
                    VStack(spacing: 16) {
                        // Titel
                        Text("Transferdetails bearbeiten")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(textColor)
                            .padding(.top, 16)

                        // Transferdetails
                        VStack(alignment: .leading, spacing: 12) {
                            // Von Verein ID
                            TextField("Von Verein ID", text: $vonVereinID)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Zu Verein ID
                            TextField("Zu Verein ID", text: $zuVereinID)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Funktionär ID
                            TextField("Funktionär ID", text: $funktionärID)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Datum
                            DatePicker("Datum", selection: $datum, displayedComponents: [.date])
                                .foregroundColor(textColor)
                                .accentColor(accentColor)
                                .padding(.vertical, 8)
                                .padding(.horizontal, 12)
                                .background(cardBackgroundColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Ablösesumme
                            TextField("Ablösesumme", text: $ablösesumme)
                                .keyboardType(.decimalPad)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )

                            // Ablösefrei
                            Toggle("Ablösefrei", isOn: $isAblösefrei)
                                .foregroundColor(textColor)
                                .tint(accentColor)
                                .padding(.vertical, 8)
                                .padding(.horizontal, 12)
                                .background(cardBackgroundColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))

                            // Details
                            TextField("Details", text: $transferdetails)
                                .padding()
                                .background(cardBackgroundColor)
                                .foregroundColor(textColor)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(accentColor.opacity(0.2), lineWidth: 1)
                                )
                        }
                        .padding()
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(accentColor.opacity(0.2), lineWidth: 1)
                        )
                        .padding(.horizontal)

                        Spacer(minLength: 80) // Platz für die untere Leiste
                    }
                    .padding(.bottom, 16)
                }
            }
            .ignoresSafeArea(edges: .bottom)
            .navigationTitle("Transferdetails bearbeiten")
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button(action: { dismiss() }) {
                        Text("Abbrechen")
                            .foregroundColor(accentColor)
                            .font(.system(size: 16, weight: .medium))
                    }
                }
                ToolbarItem(placement: .topBarTrailing) {
                    Button(action: {
                        let updatedDetails = TransferDetails(
                            id: transferDetails?.id ?? UUID().uuidString,
                            vonVereinID: vonVereinID.isEmpty ? nil : vonVereinID,
                            zuVereinID: zuVereinID.isEmpty ? nil : zuVereinID,
                            funktionärID: funktionärID.isEmpty ? nil : funktionärID,
                            datum: datum,
                            ablösesumme: Double(ablösesumme),
                            isAblösefrei: isAblösefrei,
                            transferdetails: transferdetails.isEmpty ? nil : transferdetails
                        )
                        onSave(updatedDetails)
                        dismiss()
                    }) {
                        Text("Speichern")
                            .foregroundColor(accentColor)
                            .font(.system(size: 16, weight: .medium))
                    }
                }
            }
            .onAppear {
                if let details = transferDetails {
                    vonVereinID = details.vonVereinID ?? ""
                    zuVereinID = details.zuVereinID ?? ""
                    funktionärID = details.funktionärID ?? ""
                    datum = details.datum
                    ablösesumme = details.ablösesumme?.description ?? ""
                    isAblösefrei = details.isAblösefrei
                    transferdetails = details.transferdetails ?? ""
                }
            }
        }
    }
}



//
//  AddTransferProcessView.swift

import SwiftUI
import FirebaseFirestore

struct AddTransferProcessView: View {
    @EnvironmentObject var viewModel: TransferProcessViewModel
    @Environment(\.dismiss) var dismiss
    
    @State private var clientID: String?
    @State private var vereinID: String?
    @State private var status: String = "in Bearbeitung"
    @State private var startDatum: Date = Date()
    @State private var priorität: String = "mittel" // String für UI, wird später in Int umgewandelt
    @State private var art: String = "Vereinswechsel"
    @State private var errorMessage: String = ""
    @State private var selectedParallelProcess: TransferProcess?

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var parallelProcesses: [TransferProcess] {
        guard let selectedClientID = clientID else { return [] }
        return viewModel.transferProcesses.filter { $0.clientID == selectedClientID && $0.status == "in Bearbeitung" }
    }

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)
                ScrollView {
                    VStack(spacing: 16) {
                        headerView
                        detailsView
                        Spacer(minLength: 80) // Platz für die untere Leiste
                    }
                    .padding(.bottom, 16)
                }
            }
            .ignoresSafeArea(.all, edges: .bottom)
            .navigationTitle("Neuer Transferprozess")
            .toolbar { toolbarContent }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(textColor),
                    message: Text(errorMessage).foregroundColor(secondaryTextColor),
                    dismissButton: .default(Text("OK").foregroundColor(accentColor)) { errorMessage = "" }
                )
            }
            .onAppear {
                Task {
                    await viewModel.loadTransferProcesses()
                }
            }
        }
    }

    // Sub-Views

    private var headerView: some View {
        Text("Neuer Transferprozess")
            .font(.title)
            .fontWeight(.bold)
            .foregroundColor(textColor)
            .padding(.top, 16)
    }

    private var detailsView: some View {
        VStack(alignment: .leading, spacing: 12) {
            clientPicker
            parallelProcessesMenu
            vereinPicker
            statusPicker
            priorityPicker
            artPicker
            startDatumPicker
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor.opacity(0.2), lineWidth: 1)
        )
        .padding(.horizontal)
    }

    private var clientPicker: some View {
        Picker("Klient", selection: $clientID) {
            Text("Kein Klient ausgewählt").tag(String?.none)
            ForEach(viewModel.clients) { client in
                Text("\(client.vorname) \(client.name)").tag(client.id as String?)
            }
        }
        .pickerStyle(.menu)
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(cardBackgroundColor)
        .foregroundColor(textColor)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(accentColor.opacity(0.2), lineWidth: 1)
        )
        .onChange(of: clientID) { _ in
            selectedParallelProcess = nil
        }
    }

    private var parallelProcessesMenu: some View {
        Group {
            if let selectedClientID = clientID, !parallelProcesses.isEmpty {
                Menu {
                    ForEach(parallelProcesses) { process in
                        Button(action: {
                            selectedParallelProcess = process
                            vereinID = process.vereinID
                            status = process.status
                            startDatum = process.startDatum
                            priorität = process.priority.map { $0 == 3 ? "hoch" : $0 == 2 ? "mittel" : "niedrig" } ?? "mittel"
                            art = process.art ?? "Vereinswechsel"
                        }) {
                            Text("Prozess vom \(dateFormatter.string(from: process.startDatum))")
                        }
                    }
                } label: {
                    Text(selectedParallelProcess != nil ? "Prozess vom \(dateFormatter.string(from: selectedParallelProcess!.startDatum))" : "Parallele Prozesse (\(parallelProcesses.count))")
                        .foregroundColor(textColor)
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(accentColor.opacity(0.2), lineWidth: 1)
                        )
                }
            }
        }
    }

    private var vereinPicker: some View {
        Picker("Verein", selection: $vereinID) {
            Text("Kein Verein ausgewählt").tag(String?.none)
            ForEach(viewModel.clubs) { club in
                if let clubID = club.id {
                    Text(club.name).tag(clubID as String?)
                }
            }
        }
        .pickerStyle(.menu)
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(cardBackgroundColor)
        .foregroundColor(textColor)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(accentColor.opacity(0.2), lineWidth: 1)
        )
    }

    private var statusPicker: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Status")
                .foregroundColor(secondaryTextColor)
                .font(.subheadline)
            Picker("Status", selection: $status) {
                Text("In Bearbeitung").tag("in Bearbeitung")
                Text("Abgeschlossen").tag("abgeschlossen")
                Text("Abgebrochen").tag("abgebrochen")
            }
            .pickerStyle(.segmented)
            .colorScheme(.dark) // Für dunkles Design
        }
    }

    private var priorityPicker: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Priorität")
                .foregroundColor(secondaryTextColor)
                .font(.subheadline)
            Picker("Priorität", selection: $priorität) {
                Text("Hoch").tag("hoch")
                Text("Mittel").tag("mittel")
                Text("Niedrig").tag("niedrig")
            }
            .pickerStyle(.segmented)
            .colorScheme(.dark)
        }
    }

    private var artPicker: some View {
        Picker("Art", selection: $art) {
            Text("Vereinswechsel").tag("Vereinswechsel")
            Text("Vertragsverlängerung").tag("Vertragsverlängerung")
        }
        .pickerStyle(.menu)
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(cardBackgroundColor)
        .foregroundColor(textColor)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(accentColor.opacity(0.2), lineWidth: 1)
        )
    }

    private var startDatumPicker: some View {
        DatePicker("Startdatum", selection: $startDatum, displayedComponents: [.date])
            .foregroundColor(textColor)
            .accentColor(accentColor)
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(cardBackgroundColor)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(accentColor.opacity(0.2), lineWidth: 1)
            )
    }

    private var toolbarContent: some ToolbarContent {
        Group {
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: { dismiss() }) {
                    Text("Abbrechen")
                        .foregroundColor(accentColor)
                        .font(.system(size: 16, weight: .medium))
                }
            }
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: { saveTransferProcess() }) {
                    Text("Speichern")
                        .foregroundColor(clientID == nil || vereinID == nil ? secondaryTextColor : accentColor)
                        .font(.system(size: 16, weight: .medium))
                }
                .disabled(clientID == nil || vereinID == nil)
            }
        }
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    private func saveTransferProcess() {
        guard let clientID = clientID, let vereinID = vereinID else {
            errorMessage = "Bitte wählen Sie einen Klienten und einen Verein aus."
            return
        }

        // Konvertiere priorität (String) in priority (Int?)
        let priorityValue: Int? = {
            switch priorität {
            case "hoch": return 3
            case "mittel": return 2
            case "niedrig": return 1
            default: return nil
            }
        }()

        let newProcess = TransferProcess(
            id: selectedParallelProcess?.id,
            clientID: clientID,
            vereinID: vereinID,
            status: status,
            startDatum: startDatum,
            schritte: selectedParallelProcess?.schritte ?? [],
            erinnerungen: selectedParallelProcess?.erinnerungen,
            hinweise: selectedParallelProcess?.hinweise,
            transferDetails: selectedParallelProcess?.transferDetails,
            mitarbeiterID: nil,
            priority: priorityValue,
            konditionen: nil, // Optional hinzufügen, falls benötigt
            art: art
        )

        Task {
            do {
                try await viewModel.saveTransferProcess(newProcess)
                dismiss()
            } catch {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
            }
        }
    }
}

#Preview {
    AddTransferProcessView()
        .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



//
//  EmailPreviewView.swift

import SwiftUI
import MessageUI // Für MFMailComposeViewController

struct EmailPreviewView: View {
    @Binding var isPresented: Bool
    @Binding var emailContent: String // Änderung: Binding statt State
    let process: TransferProcess
    let step: Step
    let viewModel: TransferProcessViewModel
    let onCopy: (String) -> Void
    
    @State private var selectedLanguage: String = "Deutsch" // Standard: Deutsch
    @State private var includeClubDocs = false
    @State private var includePlayerCV = false
    @State private var includeVideo = false
    @State private var showMailComposer = false

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)
                
                ScrollView {
                    VStack(spacing: 16) {
                        Text("E-Mail-Vorschau")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(textColor)
                            .padding(.top, 16)
                        
                        // Sprachauswahl
                        Picker("Sprache", selection: $selectedLanguage) {
                            Text("Deutsch").tag("Deutsch")
                            Text("Englisch").tag("Englisch")
                            Text("Französisch").tag("Französisch")
                            Text("Spanisch").tag("Spanisch")
                        }
                        .pickerStyle(.menu)
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(cardBackgroundColor)
                        .foregroundColor(textColor)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .onChange(of: selectedLanguage) { _ in
                            regenerateEmail()
                        }

                        // E-Mail-Editor
                        TextEditor(text: $emailContent)
                            .frame(minHeight: 300)
                            .padding()
                            .background(cardBackgroundColor)
                            .foregroundColor(textColor)
                            .clipShape(RoundedRectangle(cornerRadius: 12))
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(accentColor.opacity(0.2), lineWidth: 1)
                            )

                        // Anhangsoptionen
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Anhänge")
                                .font(.headline)
                                .foregroundColor(textColor)
                            Toggle("Vereinsdokumente", isOn: $includeClubDocs)
                                .foregroundColor(textColor)
                            Toggle("Spieler-CV", isOn: $includePlayerCV)
                                .foregroundColor(textColor)
                            Toggle("Videomaterial", isOn: $includeVideo)
                                .foregroundColor(textColor)
                        }
                        .padding()
                        .background(cardBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 16)
                }
            }
            .navigationTitle("E-Mail-Vorschau")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") {
                        isPresented = false
                    }
                    .foregroundColor(accentColor)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Menu {
                        Button(action: {
                            onCopy(emailContent)
                            isPresented = false
                        }) {
                            Label("Kopieren", systemImage: "doc.on.clipboard")
                        }
                        Button(action: {
                            showMailComposer = true
                        }) {
                            Label("Senden", systemImage: "paperplane")
                        }
                    } label: {
                        Image(systemName: "ellipsis")
                            .foregroundColor(accentColor)
                    }
                }
            }
            .sheet(isPresented: $showMailComposer) {
                MailComposeView(
                    subject: extractSubject(from: emailContent),
                    body: emailContent,
                    isPresented: $showMailComposer
                )
            }
        }
    }

    // E-Mail basierend auf der Sprache neu generieren
    private func regenerateEmail() {
        Task {
            let newEmail = await viewModel.generateEmail(for: process, step: step, language: selectedLanguage)
            await MainActor.run {
                emailContent = newEmail
            }
        }
    }

    // Betreff aus der E-Mail extrahieren
    private func extractSubject(from email: String) -> String {
        let lines = email.split(separator: "\n")
        if let subjectLine = lines.first(where: { $0.starts(with: "Betreff:") }) {
            return String(subjectLine.dropFirst(8)).trimmingCharacters(in: .whitespaces)
        }
        return ""
    }
}

// Wrapper für MFMailComposeViewController
struct MailComposeView: UIViewControllerRepresentable {
    let subject: String
    let body: String
    @Binding var isPresented: Bool

    func makeUIViewController(context: Context) -> MFMailComposeViewController {
        let mailComposer = MFMailComposeViewController()
        mailComposer.mailComposeDelegate = context.coordinator
        mailComposer.setSubject(subject)
        mailComposer.setMessageBody(body, isHTML: false)
        return mailComposer
    }

    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, MFMailComposeViewControllerDelegate {
        let parent: MailComposeView

        init(_ parent: MailComposeView) {
            self.parent = parent
        }

        func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
            parent.isPresented = false
        }
    }
}

#Preview {
    EmailPreviewView(
        isPresented: .constant(true),
        emailContent: .constant("Betreff: Kontaktaufnahme für Max Mustermann - FC Beispiel\n\nSehr geehrte Damen und Herren,\n\nim Rahmen des Transfers von Max Mustermann haben wir am 30. März 2025 die Kontaktaufnahme mit FC Beispiel erfolgreich abgeschlossen.\n\nMit freundlichen Grüßen,\nSports Transfer Team"),
        process: TransferProcess(clientID: "client1", vereinID: "club1", status: "in Bearbeitung", startDatum: Date()),
        step: Step(typ: "Kontaktaufnahme", status: "abgeschlossen", datum: Date()),
        viewModel: TransferProcessViewModel(authManager: AuthManager()),
        onCopy: { _ in }
    )
}



//
//  TransferProcessDetailView.swift

import SwiftUI

struct TransferProcessDetailView: View {
    @State var transferProcess: TransferProcess
    @EnvironmentObject var authManager: AuthManager
    @EnvironmentObject var transferProcessViewModel: TransferProcessViewModel
    @State private var client: Client?
    @State private var club: Club?
    @State private var errorMessage = ""
    @State private var showingAddStepSheet = false
    @State private var showingAddReminderSheet = false
    @State private var showingAddNoteSheet = false
    @State private var showingAddTransferDetailsSheet = false
    @State private var editingStep: Step?
    @State private var editingReminder: Reminder?
    @State private var editingNote: Note?
    @State private var showingDeleteConfirmation = false
    @State private var reminderToDelete: Reminder?
    @State private var noteToDelete: Note?
    @State private var stepToDelete: Step?
    @State private var showingEmailPreview = false
    @State private var generatedEmail = ""

    // Farben für das dunkle Design (definiert in Extensions.swift)
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)
                ScrollView {
                    VStack(spacing: 16) {
                        headerView
                        basicInfoView
                        if transferProcess.status == "abgeschlossen" {
                            transferDetailsView
                        }
                        stepsView
                        remindersView
                        notesView
                        Spacer(minLength: 80) // Platz für die untere Leiste
                    }
                    .padding(.bottom, 16)
                }
            }
            .ignoresSafeArea(edges: .bottom)
            .navigationTitle("Transferprozess")
            .toolbar { toolbarContent }
            .sheet(isPresented: $showingEmailPreview) {
                EmailPreviewView(
                    isPresented: $showingEmailPreview,
                    emailContent: $generatedEmail,
                    process: transferProcess,
                    step: transferProcess.schritte.first ?? Step(typ: "Unbekannt", status: "geplant", datum: Date()),
                    viewModel: transferProcessViewModel,
                    onCopy: { content in
                        UIPasteboard.general.string = content
                        errorMessage = "E-Mail in Zwischenablage kopiert"
                    }
                )
            }
            .sheet(isPresented: $showingAddStepSheet) {
                AddEditStepView(
                    transferProcess: $transferProcess,
                    step: editingStep,
                    onSave: saveStep
                )
            }
            .sheet(isPresented: $showingAddReminderSheet) {
                AddEditReminderView(
                    transferProcess: $transferProcess,
                    reminder: editingReminder,
                    onSave: saveReminder
                )
            }
            .sheet(isPresented: $showingAddNoteSheet) {
                AddEditNoteView(
                    transferProcess: $transferProcess,
                    note: editingNote,
                    onSave: saveNote
                )
            }
            .sheet(isPresented: $showingAddTransferDetailsSheet) {
                AddEditTransferDetailsView(
                    transferProcess: $transferProcess,
                    transferDetails: transferProcess.transferDetails,
                    onSave: saveTransferDetails
                )
            }
            .alert("Löschen bestätigen", isPresented: $showingDeleteConfirmation) {
                Button("Abbrechen", role: .cancel) { clearDeleteSelection() }
                Button("Löschen", role: .destructive) { deleteSelectedItem() }
            } message: {
                if reminderToDelete != nil { Text("Möchten Sie diese Erinnerung wirklich löschen?") }
                else if noteToDelete != nil { Text("Möchten Sie diesen Hinweis wirklich löschen?") }
                else if stepToDelete != nil { Text("Möchten Sie diesen Schritt wirklich löschen?") }
            }
            .task { await loadClientAndClub() }
            .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
                Alert(
                    title: Text("Fehler").foregroundColor(textColor),
                    message: Text(errorMessage).foregroundColor(secondaryTextColor),
                    dismissButton: .default(Text("OK").foregroundColor(accentColor))
                )
            }
        }
    }

    // Sub-Views für Modularität

    private var headerView: some View {
        Text("Transferprozess Details")
            .font(.title2)
            .fontWeight(.bold)
            .foregroundColor(textColor)
            .padding(.top, 16)
            .padding(.horizontal)
    }

    private var basicInfoView: some View {
        VStack(alignment: .leading, spacing: 12) {
            if let client = client {
                Text("Klient: \(client.vorname) \(client.name)")
                    .font(.headline)
                    .foregroundColor(textColor)
            }
            if let club = club {
                Text("Verein: \(club.name)")
                    .font(.headline)
                    .foregroundColor(textColor)
            }
            Text("Art: \(transferProcess.art ?? "Nicht angegeben")")
                .font(.headline)
                .foregroundColor(textColor)
            statusView
            Text("Startdatum: \(dateFormatter.string(from: transferProcess.startDatum))")
                .font(.subheadline)
                .foregroundColor(secondaryTextColor)
            if authManager.userRole == .mitarbeiter {
                mitarbeiterPicker
                priorityPicker
            } else {
                if let mitarbeiterID = transferProcess.mitarbeiterID {
                    Text("Mitarbeiter: \(mitarbeiterID)")
                        .font(.subheadline)
                        .foregroundColor(secondaryTextColor)
                }
                if let priority = transferProcess.priority {
                    Text("Priorität: \(priority)")
                        .font(.subheadline)
                        .foregroundColor(secondaryTextColor)
                }
            }
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor, lineWidth: 1)
        )
        .opacity(0.2)
        .padding(.horizontal)
    }

    private var statusView: some View {
        HStack {
            Text("Status:")
                .font(.headline)
                .foregroundColor(textColor)
            if authManager.userRole == .mitarbeiter {
                Picker("Status", selection: $transferProcess.status) {
                    Text("In Bearbeitung").tag("in Bearbeitung")
                    Text("Abgeschlossen").tag("abgeschlossen")
                    Text("Abgebrochen").tag("abgebrochen")
                }
                .pickerStyle(.menu)
                .foregroundColor(statusColor)
                .padding(.vertical, 6)
                .padding(.horizontal, 12)
                .background(cardBackgroundColor)
                .clipShape(RoundedRectangle(cornerRadius: 8))
                .onChange(of: transferProcess.status) { _ in
                    saveTransferProcess()
                }
            } else {
                Text(transferProcess.status)
                    .foregroundColor(statusColor)
                    .font(.headline)
            }
        }
    }

    private var mitarbeiterPicker: some View {
        Picker("Mitarbeiter", selection: $transferProcess.mitarbeiterID) {
            Text("Nicht zugewiesen").tag(String?.none)
            ForEach(transferProcessViewModel.mitarbeiter, id: \.self) { mitarbeiter in
                Text(mitarbeiter).tag(mitarbeiter as String?)
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(textColor)
        .padding(.vertical, 6)
        .padding(.horizontal, 12)
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .onChange(of: transferProcess.mitarbeiterID) { _ in
            saveTransferProcess()
        }
    }

    private var priorityPicker: some View {
        Picker("Priorität", selection: $transferProcess.priority) {
            Text("Keine").tag(Int?.none)
            ForEach(1...5, id: \.self) { value in
                Text("\(value)").tag(value as Int?)
            }
        }
        .pickerStyle(.menu)
        .foregroundColor(textColor)
        .padding(.vertical, 6)
        .padding(.horizontal, 12)
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .onChange(of: transferProcess.priority) { _ in
            saveTransferProcess()
        }
    }

    private var transferDetailsView: some View {
        VStack(spacing: 8) {
            SectionHeader(
                title: "Transferdetails",
                action: authManager.userRole == .mitarbeiter ? { showingAddTransferDetailsSheet = true } : nil,
                icon: transferProcess.transferDetails == nil ? "plus.circle" : "pencil.circle"
            )
            if let details = transferProcess.transferDetails {
                TransferDetailsItemView(transferDetails: details)
            } else {
                Text("Keine Transferdetails vorhanden.")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .center)
            }
        }
    }

    private var stepsView: some View {
        VStack(spacing: 8) {
            SectionHeader(
                title: "Schritte",
                action: authManager.userRole == .mitarbeiter ? { editingStep = nil; showingAddStepSheet = true } : nil,
                icon: "plus.circle"
            )
            if transferProcess.schritte.isEmpty {
                Text("Keine Schritte vorhanden.")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .center)
            } else {
                ForEach(transferProcess.schritte) { step in
                    StepCard(step: step)
                        .onTapGesture {
                            if authManager.userRole == .mitarbeiter {
                                editingStep = step
                                showingAddStepSheet = true
                            }
                        }
                        .contextMenu {
                            if authManager.userRole == .mitarbeiter {
                                Button(role: .destructive, action: {
                                    stepToDelete = step
                                    showingDeleteConfirmation = true
                                }) {
                                    Label("Löschen", systemImage: "trash")
                                }
                            }
                        }
                }
            }
        }
    }

    private var remindersView: some View {
        VStack(spacing: 8) {
            SectionHeader(
                title: "Erinnerungen",
                action: authManager.userRole == .mitarbeiter ? { editingReminder = nil; showingAddReminderSheet = true } : nil,
                icon: "plus.circle"
            )
            if let erinnerungen = transferProcess.erinnerungen, !erinnerungen.isEmpty {
                ForEach(erinnerungen.indices, id: \.self) { index in
                    ReminderCard(erinnerung: erinnerungen[index])
                        .onTapGesture {
                            if authManager.userRole == .mitarbeiter {
                                editingReminder = erinnerungen[index]
                                showingAddReminderSheet = true
                            }
                        }
                        .contextMenu {
                            if authManager.userRole == .mitarbeiter {
                                Button(role: .destructive, action: {
                                    reminderToDelete = erinnerungen[index]
                                    showingDeleteConfirmation = true
                                }) {
                                    Label("Löschen", systemImage: "trash")
                                }
                                Button(action: {
                                    Task {
                                        do {
                                            try await transferProcessViewModel.addReminderToCalendar(reminder: erinnerungen[index], for: transferProcess)
                                        } catch {
                                            errorMessage = "Fehler beim Hinzufügen zum Kalender: \(error.localizedDescription)"
                                        }
                                    }
                                }) {
                                    Label("Zum Kalender hinzufügen", systemImage: "calendar")
                                }
                            }
                        }
                }
            } else {
                Text("Keine Erinnerungen vorhanden.")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .center)
            }
        }
    }

    private var notesView: some View {
        VStack(spacing: 8) {
            SectionHeader(
                title: "Hinweise",
                action: authManager.userRole == .mitarbeiter ? { editingNote = nil; showingAddNoteSheet = true } : nil,
                icon: "plus.circle"
            )
            if let hinweise = transferProcess.hinweise, !hinweise.isEmpty {
                ForEach(hinweise) { hinweis in
                    NoteCard(hinweis: hinweis)
                        .onTapGesture {
                            if authManager.userRole == .mitarbeiter {
                                editingNote = hinweis
                                showingAddNoteSheet = true
                            }
                        }
                        .contextMenu {
                            if authManager.userRole == .mitarbeiter {
                                Button(role: .destructive, action: {
                                    noteToDelete = hinweis
                                    showingDeleteConfirmation = true
                                }) {
                                    Label("Löschen", systemImage: "trash")
                                }
                            }
                        }
                }
            } else {
                Text("Keine Hinweise vorhanden.")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .center)
            }
        }
    }

    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .topBarTrailing) {
            Menu {
                Button(action: {
                    Task {
                        if let firstStep = transferProcess.schritte.first {
                            let emailContent = await transferProcessViewModel.generateEmail(for: transferProcess, step: firstStep)
                            await MainActor.run {
                                generatedEmail = emailContent
                                showingEmailPreview = true
                            }
                        } else {
                            await MainActor.run {
                                errorMessage = "Keine Schritte vorhanden, um eine E-Mail zu generieren"
                            }
                        }
                    }
                }) {
                    Label("E-Mail generieren", systemImage: "envelope")
                }
            } label: {
                Image(systemName: "ellipsis.circle")
                    .foregroundColor(accentColor)
                    .font(.system(size: 20, weight: .medium))
            }
        }
    }

    // Section-Header mit Titel und optionalem Button
    private func SectionHeader(title: String, action: (() -> Void)?, icon: String?) -> some View {
        HStack {
            Text(title)
                .font(.title3)
                .fontWeight(.semibold)
                .foregroundColor(textColor)
            Spacer()
            if let action = action, let icon = icon {
                Button(action: action) {
                    Image(systemName: icon)
                        .foregroundColor(accentColor)
                        .font(.system(size: 20, weight: .medium))
                }
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
    }

    // Card für Schritte
    private func StepCard(step: Step) -> some View {
        HStack(alignment: .top, spacing: 12) {
            Image(systemName: step.status == "abgeschlossen" ? "checkmark.circle.fill" : "circle")
                .foregroundColor(step.status == "abgeschlossen" ? .green : secondaryTextColor)
                .font(.system(size: 20))
            VStack(alignment: .leading, spacing: 6) {
                Text(step.typ)
                    .font(.headline)
                    .foregroundColor(textColor)
                Text("Datum: \(dateFormatter.string(from: step.datum))")
                    .font(.subheadline)
                    .foregroundColor(secondaryTextColor)
                if let notizen = step.notizen {
                    Text("Notizen: \(notizen)")
                        .font(.caption)
                        .foregroundColor(secondaryTextColor)
                        .lineLimit(2)
                }
                if let chance = step.erfolgschance {
                    Text("Erfolgschance: \(chance)%")
                        .font(.caption)
                        .foregroundColor(.yellow)
                }
                if let checkliste = step.checkliste, !checkliste.isEmpty {
                    Text("Checkliste: \(checkliste.joined(separator: ", "))")
                        .font(.caption)
                        .foregroundColor(secondaryTextColor)
                        .lineLimit(1)
                }
            }
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor, lineWidth: 1)
        )
        .opacity(0.2)
        .padding(.horizontal)
    }

    // Card für Erinnerungen
    private func ReminderCard(erinnerung: Reminder) -> some View {
        HStack(alignment: .top, spacing: 12) {
            Image(systemName: "bell.fill")
                .foregroundColor(accentColor)
                .font(.system(size: 20))
            VStack(alignment: .leading, spacing: 6) {
                Text("Datum: \(dateFormatter.string(from: erinnerung.datum))")
                    .font(.subheadline)
                    .foregroundColor(secondaryTextColor)
                Text(erinnerung.beschreibung)
                    .font(.headline)
                    .foregroundColor(textColor)
                if let category = erinnerung.kategorie {
                    Text("Kategorie: \(category)")
                        .font(.caption)
                        .foregroundColor(.yellow)
                }
            }
            Spacer()
            if authManager.userRole == .mitarbeiter {
                Button(action: {
                    Task {
                        do {
                            try await transferProcessViewModel.addReminderToCalendar(reminder: erinnerung, for: transferProcess)
                        } catch {
                            errorMessage = "Fehler beim Hinzufügen zum Kalender: \(error.localizedDescription)"
                        }
                    }
                }) {
                    Image(systemName: "calendar")
                        .foregroundColor(accentColor)
                        .font(.system(size: 20))
                }
            }
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor, lineWidth: 1)
        )
        .opacity(0.2)
        .padding(.horizontal)
    }

    // Card für Hinweise
    private func NoteCard(hinweis: Note) -> some View {
        HStack(alignment: .top, spacing: 12) {
            Image(systemName: "note.text")
                .foregroundColor(accentColor)
                .font(.system(size: 20))
            VStack(alignment: .leading, spacing: 6) {
                Text(hinweis.beschreibung)
                    .font(.body)
                    .foregroundColor(textColor)
                    .lineLimit(3)
                if let docs = hinweis.vereinsDokumente, !docs.isEmpty {
                    Text("Dokumente: \(docs.joined(separator: ", "))")
                        .font(.caption)
                        .foregroundColor(.yellow)
                        .lineLimit(1)
                }
            }
            Spacer()
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor, lineWidth: 1)
        )
        .opacity(0.2)
        .padding(.horizontal)
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter
    }()

    private var statusColor: Color {
        switch transferProcess.status {
        case "in Bearbeitung": return .orange
        case "abgeschlossen": return .green
        case "abgebrochen": return .red
        default: return secondaryTextColor
        }
    }

    private func loadClientAndClub() async {
        do {
            let (clients, _) = try await FirestoreManager.shared.getClients(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.client = clients.first { $0.id == transferProcess.clientID }
            }

            let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.club = clubs.first { $0.id == transferProcess.vereinID }
            }
        } catch {
            errorMessage = "Fehler beim Laden: \(error.localizedDescription)"
        }
    }

    private func saveStep(_ updatedStep: Step) {
        if let index = transferProcess.schritte.firstIndex(where: { $0.id == updatedStep.id }) {
            transferProcess.schritte[index] = updatedStep
        } else {
            transferProcess.schritte.append(updatedStep)
        }
        saveTransferProcess()
    }

    private func saveReminder(_ updatedReminder: Reminder) {
        var updatedErinnerungen = transferProcess.erinnerungen ?? []
        if let index = updatedErinnerungen.firstIndex(where: { $0.id == updatedReminder.id }) {
            updatedErinnerungen[index] = updatedReminder
        } else {
            updatedErinnerungen.append(updatedReminder)
        }
        transferProcess.erinnerungen = updatedErinnerungen
        saveTransferProcess()
    }

    private func saveNote(_ updatedNote: Note) {
        var updatedHinweise = transferProcess.hinweise ?? []
        if let index = updatedHinweise.firstIndex(where: { $0.id == updatedNote.id }) {
            updatedHinweise[index] = updatedNote
        } else {
            updatedHinweise.append(updatedNote)
        }
        transferProcess.hinweise = updatedHinweise
        saveTransferProcess()
    }

    private func saveTransferDetails(_ updatedDetails: TransferDetails) {
        transferProcess.transferDetails = updatedDetails
        saveTransferProcess()
    }

    private func saveTransferProcess() {
        Task {
            do {
                try await FirestoreManager.shared.updateTransferProcess(transferProcess: transferProcess)
                transferProcessViewModel.updateTransferProcessLocally(transferProcess)
            } catch {
                errorMessage = "Fehler beim Speichern: \(error.localizedDescription)"
            }
        }
    }

    private func deleteSelectedItem() {
        if let reminder = reminderToDelete {
            transferProcess.erinnerungen = transferProcess.erinnerungen?.filter { $0.id != reminder.id }
        } else if let note = noteToDelete {
            transferProcess.hinweise = transferProcess.hinweise?.filter { $0.id != note.id }
        } else if let step = stepToDelete {
            transferProcess.schritte = transferProcess.schritte.filter { $0.id != step.id }
        }
        saveTransferProcess()
        clearDeleteSelection()
    }

    private func clearDeleteSelection() {
        reminderToDelete = nil
        noteToDelete = nil
        stepToDelete = nil
    }
}

struct TransferDetailsItemView: View {
    let transferDetails: TransferDetails

    // Farben für das dunkle Design (definiert in Extensions.swift)
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")
    private let accentColor = Color(hex: "#00C4B4")

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Datum: \(dateFormatter.string(from: transferDetails.datum))")
                .font(.subheadline)
                .foregroundColor(secondaryTextColor)
            if let ablöse = transferDetails.ablösesumme {
                Text("Ablösesumme: \(ablöse, specifier: "%.2f")")
                    .font(.body)
                    .foregroundColor(textColor)
            }
            Text("Ablösefrei: \(transferDetails.isAblösefrei ? "Ja" : "Nein")")
                .font(.body)
                .foregroundColor(textColor)
            if let details = transferDetails.transferdetails {
                Text("Details: \(details)")
                    .font(.body)
                    .foregroundColor(secondaryTextColor)
                    .lineLimit(3)
            }
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor, lineWidth: 1)
        )
        .opacity(0.2)
        .padding(.horizontal)
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()
}

#Preview {
    TransferProcessDetailView(
        transferProcess: TransferProcess(
            id: "1",
            clientID: "client1",
            vereinID: "club1",
            status: "in Bearbeitung",
            startDatum: Date(),
            schritte: [
                Step(typ: "Kontaktaufnahme", status: "abgeschlossen", datum: Date(), erfolgschance: 80, checkliste: ["Gehalt abfragen"])
            ],
            erinnerungen: [
                Reminder(datum: Date().addingTimeInterval(86400), beschreibung: "Nachfragen", kategorie: "nachfrageErinnerung")
            ],
            hinweise: [
                Note(beschreibung: "Verein interessiert", vereinsDokumente: ["doc1.pdf"])
            ],
            mitarbeiterID: "mitarbeiter_a",
            priority: 2
        )
    )
    .environmentObject(AuthManager())
    .environmentObject(TransferProcessViewModel(authManager: AuthManager()))
}



//
//  TransferProcessListView.swift

import SwiftUI

struct TransferProcessListView: View {
    @ObservedObject var viewModel: TransferProcessViewModel
    @State private var filterMitarbeiter: String? = nil
    @State private var filterPriorität: String? = nil
    @State private var showingAddTransferSheet = false

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var filteredTransferProcesses: [TransferProcess] {
        var filtered = viewModel.transferProcesses
        if let mitarbeiterID = filterMitarbeiter {
            filtered = filtered.filter { process in
                process.mitarbeiterID == mitarbeiterID
            }
        }
        if let priorität = filterPriorität {
            filtered = filtered.filter { process in
                process.priority.map { priorityToString($0) } == priorität
            }
        }
        return filtered.sorted { (p1, p2) in
            let priority1 = p1.priority ?? 0
            let priority2 = p2.priority ?? 0
            return priority1 > priority2
        }
    }

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                VStack(spacing: 0) {
                    // Filter
                    HStack(spacing: 12) {
                        Picker("Mitarbeiter", selection: $filterMitarbeiter) {
                            Text("Alle").tag(String?.none)
                            ForEach(viewModel.mitarbeiter, id: \.self) { mitarbeiter in
                                Text(mitarbeiter)
                                    .tag(mitarbeiter as String?)
                            }
                        }
                        .pickerStyle(MenuPickerStyle())
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(cardBackgroundColor)
                        .foregroundColor(textColor)
                        .clipShape(RoundedRectangle(cornerRadius: 8))

                        Picker("Priorität", selection: $filterPriorität) {
                            Text("Alle").tag(String?.none)
                            Text("Hoch").tag(String?.some("hoch"))
                            Text("Mittel").tag(String?.some("mittel"))
                            Text("Niedrig").tag(String?.some("niedrig"))
                        }
                        .pickerStyle(MenuPickerStyle())
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(cardBackgroundColor)
                        .foregroundColor(textColor)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                    }
                    .padding(.horizontal)
                    .padding(.vertical, 8)

                    ScrollView {
                        VStack(spacing: 12) {
                            if filteredTransferProcesses.isEmpty {
                                Text("Keine Transferprozesse vorhanden.")
                                    .foregroundColor(secondaryTextColor)
                                    .font(.subheadline)
                                    .padding(.top, 20)
                            } else {
                                ForEach(filteredTransferProcesses) { process in
                                    NavigationLink(destination: TransferProcessDetailView(transferProcess: process)) {
                                        TransferProcessCard(process: process)
                                    }
                                }
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 8)
                    }
                }
            }
            .navigationTitle("Transferprozesse")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button(action: { showingAddTransferSheet = true }) {
                        Image(systemName: "plus")
                            .foregroundColor(accentColor)
                            .font(.system(size: 20, weight: .medium))
                    }
                }
            }
            .sheet(isPresented: $showingAddTransferSheet) {
                AddTransferProcessView()
                    .environmentObject(viewModel)
            }
            .task {
                await viewModel.loadTransferProcesses()
                print("TransferProcesses: \(viewModel.transferProcesses.count), Clients: \(viewModel.clients.count), Clubs: \(viewModel.clubs.count)")
            }
        }
    }

    private func TransferProcessCard(process: TransferProcess) -> some View {
        let clientName = viewModel.clients.first { $0.id == process.clientID }?.name ?? "Unbekannt"
        let clubName = viewModel.clubs.first { $0.id == process.vereinID }?.name ?? "Unbekannt"
        let priorityText = process.priority.map { "Priorität: \(priorityToString($0))" } ?? "Priorität: Unbekannt"
        let priorityColorValue = process.priority.map { priorityColor($0) } ?? .gray

        return VStack(alignment: .leading, spacing: 8) {
            Text("Klient: \(clientName)")
                .foregroundColor(textColor)
                .font(.headline)
            Text("Verein: \(clubName)")
                .foregroundColor(secondaryTextColor)
                .font(.subheadline)

            HStack {
                Text("Status: \(process.status)")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                Spacer()
                Text(priorityText)
                    .foregroundColor(priorityColorValue)
                    .font(.subheadline)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(priorityColorValue.opacity(0.2))
                    .clipShape(RoundedRectangle(cornerRadius: 4))
            }
        }
        .padding()
        .background(cardBackgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(accentColor.opacity(0.2), lineWidth: 1)
        )
    }

    private func priorityToString(_ priority: Int) -> String {
        switch priority {
        case 1..<3: return "niedrig"
        case 3..<5: return "mittel"
        case 5: return "hoch"
        default: return "niedrig"
        }
    }

    private func priorityColor(_ priority: Int) -> Color {
        switch priority {
        case 1..<3: return .green
        case 3..<5: return .yellow
        case 5: return .red
        default: return .gray
        }
    }
}



//
//  TransferProcessViewModel.swift

import SwiftUI
import FirebaseFirestore
import EventKit // Für Kalenderzugriff

class TransferProcessViewModel: ObservableObject {
    @Published var transferProcesses: [TransferProcess] = []
    @Published var clients: [Client] = []
    @Published var clubs: [Club] = []
    @Published var mitarbeiter: [String] = []
    private let db = Firestore.firestore()

    init(authManager: AuthManager? = nil) {
        // authManager wird derzeit nicht verwendet, kann aber später genutzt werden
    }

    func loadTransferProcesses() async {
        do {
            // Lade Transferprozesse
            let (processes, _) = try await FirestoreManager.shared.getTransferProcesses(lastDocument: nil, limit: 50)
            
            // Lade Clients
            let (loadedClients, _) = try await FirestoreManager.shared.getAllClients(lastDocument: nil, limit: 100)
            
            // Lade Clubs
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 100)
            
            // Lade Mitarbeiter
            let snapshot = try await Firestore.firestore().collection("users")
                .whereField("rolle", isEqualTo: "Mitarbeiter")
                .getDocuments()
            let loadedMitarbeiter = snapshot.documents.map { doc in
                doc.data()["email"] as? String ?? doc.documentID
            }

            await MainActor.run {
                transferProcesses = processes
                clients = loadedClients
                clubs = loadedClubs
                mitarbeiter = loadedMitarbeiter
            }
        } catch {
            print("Fehler beim Laden: \(error)")
        }
    }

    func saveTransferProcess(_ process: TransferProcess) async throws {
        let ref = db.collection("transferProcesses").document(process.id ?? UUID().uuidString)
        try await ref.setData(from: process, merge: true)
        await loadTransferProcesses()
    }

    func updateTransferProcessLocally(_ updatedProcess: TransferProcess) {
        if let index = transferProcesses.firstIndex(where: { $0.id == updatedProcess.id }) {
            transferProcesses[index] = updatedProcess
        }
    }

    func generateEmail(for process: TransferProcess, step: Step, language: String = "Deutsch") async -> String {
        // Einfache E-Mail-Generierung basierend auf der Sprache
        let client = clients.first { $0.id == process.clientID }
        let club = clubs.first { $0.id == process.vereinID }
        
        let clientName = "\(client?.vorname ?? "Unbekannt") \(client?.name ?? "Unbekannt")"
        let clubName = club?.name ?? "Unbekannt"
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .medium
        let dateString = dateFormatter.string(from: step.datum)

        switch language {
        case "Deutsch":
            return """
            Betreff: \(step.typ) für \(clientName) - \(clubName)

            Sehr geehrte Damen und Herren,

            im Rahmen des Transfers von \(clientName) haben wir am \(dateString) die \(step.typ) mit \(clubName) erfolgreich abgeschlossen.

            Mit freundlichen Grüßen,
            Sports Transfer Team
            """
        case "Englisch":
            return """
            Subject: \(step.typ) for \(clientName) - \(clubName)

            Dear Sir or Madam,

            As part of the transfer of \(clientName), we successfully completed the \(step.typ) with \(clubName) on \(dateString).

            Best regards,
            Sports Transfer Team
            """
        case "Französisch":
            return """
            Objet : \(step.typ) pour \(clientName) - \(clubName)

            Madame, Monsieur,

            Dans le cadre du transfert de \(clientName), nous avons finalisé avec succès la \(step.typ) avec \(clubName) le \(dateString).

            Cordialement,
            Équipe Sports Transfer
            """
        case "Spanisch":
            return """
            Asunto: \(step.typ) para \(clientName) - \(clubName)

            Estimados señores,

            En el marco de la transferencia de \(clientName), hemos completado con éxito la \(step.typ) con \(clubName) el \(dateString).

            Atentamente,
            Equipo de Sports Transfer
            """
        default:
            return "E-Mail konnte nicht generiert werden."
        }
    }

    func addReminderToCalendar(reminder: Reminder, for process: TransferProcess) async throws {
        let eventStore = EKEventStore()
        
        // Berechtigung für Kalenderzugriff anfordern
        let authorizationStatus = EKEventStore.authorizationStatus(for: .event)
        if authorizationStatus != .authorized {
            let granted = try await eventStore.requestAccess(to: .event)
            if !granted {
                throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Kalenderzugriff verweigert"])
            }
        }

        let event = EKEvent(eventStore: eventStore)
        event.title = "Erinnerung: \(reminder.beschreibung)"
        event.startDate = reminder.datum
        event.endDate = reminder.datum.addingTimeInterval(3600) // 1 Stunde Dauer
        event.notes = "Transferprozess: \(process.title ?? "Unbekannt")"
        event.calendar = eventStore.defaultCalendarForNewEvents
        try eventStore.save(event, span: .thisEvent)
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/8. Contract
//
//  AddContractView.swift

import SwiftUI
import FirebaseFirestore

struct AddContractView: View {
    @Binding var contract: Contract
    var isEditing: Bool
    var onSave: (Contract) -> Void
    var onCancel: () -> Void
    @EnvironmentObject var authManager: AuthManager

    @State private var selectedClient: Client? = nil
    @State private var selectedVerein: Club? = nil
    @State private var startDatum: Date = Date()
    @State private var endDatum: Date? = nil
    @State private var gehalt: Double? = nil
    @State private var vertragsdetails: String? = nil
    @State private var clients: [Client] = []
    @State private var clubs: [Club] = []
    @State private var showingAddClubSheet = false
    @State private var newClub = Club(name: "")
    @State private var errorMessage = ""

    var body: some View {
        NavigationView {
            Form {
                if authManager.userRole == .mitarbeiter {
                    Section(header: Text("Vertragsdaten").foregroundColor(.white)) {
                        Picker("Klient", selection: $selectedClient) {
                            Text("Kein Klient ausgewählt").tag(Client?.none)
                            ForEach(clients) { client in
                                Text("\(client.vorname) \(client.name)")
                                    .tag(client as Client?)
                            }
                        }
                        .pickerStyle(MenuPickerStyle())
                        .foregroundColor(.white) // Weiße Schrift
                        .accentColor(.white) // Weiße Akzente

                        VStack {
                            Picker("Verein", selection: $selectedVerein) {
                                Text("Kein Verein ausgewählt").tag(Club?.none)
                                ForEach(clubs) { club in
                                    Text(club.name).tag(club as Club?)
                                }
                            }
                            .pickerStyle(MenuPickerStyle())
                            .foregroundColor(.white) // Weiße Schrift
                            .accentColor(.white) // Weiße Akzente
                            
                            Button(action: { showingAddClubSheet = true }) {
                                HStack {
                                    Image(systemName: "plus.circle")
                                        .foregroundColor(.white) // Weißes Symbol
                                    Text("Neuer Verein")
                                        .foregroundColor(.white) // Weiße Schrift
                                }
                            }
                            .padding(.top, 8)
                        }

                        DatePicker("Startdatum", selection: $startDatum, displayedComponents: .date)
                            .foregroundColor(.white) // Weiße Schrift
                            .accentColor(.white) // Weiße Akzente
                        DatePicker("Enddatum", selection: Binding(
                            get: { endDatum ?? Date() },
                            set: { endDatum = $0 }
                        ), displayedComponents: .date)
                            .foregroundColor(.white) // Weiße Schrift
                            .accentColor(.white) // Weiße Akzente
                        TextField("Gehalt (€)", value: $gehalt, format: .number)
                            .foregroundColor(.white) // Weiße Schrift
                        TextField("Vertragsdetails", text: Binding(
                            get: { vertragsdetails ?? "" },
                            set: { vertragsdetails = $0.isEmpty ? nil : $0 }
                        ))
                            .foregroundColor(.white) // Weiße Schrift
                    }
                } else {
                    Text("Nur Mitarbeiter können Verträge bearbeiten.")
                        .foregroundColor(.gray)
                }
            }
            .scrollContentBackground(.hidden) // Standard-Hintergrund der Form ausblenden
            .background(Color.black) // Schwarzer Hintergrund für die Form
            .navigationTitle(isEditing ? "Vertrag bearbeiten" : "Vertrag anlegen")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { onCancel() }
                        .foregroundColor(.white) // Weiße Schrift
                }
                ToolbarItem(placement: .confirmationAction) {
                    if authManager.userRole == .mitarbeiter {
                        Button("Speichern") {
                            if validateInputs() {
                                contract.clientID = selectedClient?.id
                                contract.vereinID = selectedVerein?.name
                                contract.startDatum = startDatum
                                contract.endDatum = endDatum
                                contract.gehalt = gehalt
                                contract.vertragsdetails = vertragsdetails
                                onSave(contract)
                            }
                        }
                        .disabled(selectedClient == nil || selectedVerein == nil)
                        .foregroundColor(.white) // Weiße Schrift
                    }
                }
            }
            .sheet(isPresented: $showingAddClubSheet) {
                AddClubView(
                    club: $newClub,
                    onSave: { updatedClub in
                        Task {
                            do {
                                try await FirestoreManager.shared.createClub(club: updatedClub)
                                await loadClubs()
                                selectedVerein = clubs.first { $0.name == updatedClub.name }
                                await MainActor.run {
                                    newClub = Club(name: "")
                                }
                            } catch {
                                await MainActor.run {
                                    errorMessage = "Fehler beim Speichern des Vereins: \(error.localizedDescription)"
                                }
                            }
                            await MainActor.run {
                                showingAddClubSheet = false
                            }
                        }
                    },
                    onCancel: {
                        Task {
                            await MainActor.run {
                                newClub = Club(name: "")
                                showingAddClubSheet = false
                            }
                        }
                    }
                )
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
            .task {
                await loadClients()
                await loadClubs()
                if isEditing {
                    startDatum = contract.startDatum
                    endDatum = contract.endDatum
                    gehalt = contract.gehalt
                    vertragsdetails = contract.vertragsdetails
                    if let clientID = contract.clientID {
                        selectedClient = clients.first { $0.id == clientID }
                    }
                    if let vereinID = contract.vereinID {
                        selectedVerein = clubs.first { $0.name == vereinID }
                    }
                }
            }
        }
    }

    private func loadClients() async {
        do {
            let (loadedClients, _) = try await FirestoreManager.shared.getClients(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.clients = loadedClients
                if let clientID = contract.clientID {
                    self.selectedClient = loadedClients.first { $0.id == clientID }
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Fehler beim Laden der Klienten: \(error.localizedDescription)"
            }
        }
    }

    private func loadClubs() async {
        do {
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                self.clubs = loadedClubs
                if let vereinID = contract.vereinID {
                    self.selectedVerein = loadedClubs.first { $0.name == vereinID }
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Fehler beim Laden der Vereine: \(error.localizedDescription)"
            }
        }
    }

    private func validateInputs() -> Bool {
        if let endDatum = endDatum, endDatum < startDatum {
            errorMessage = "Das Enddatum darf nicht vor dem Startdatum liegen."
            return false
        }
        if let gehalt = gehalt, gehalt < 0 {
            errorMessage = "Das Gehalt darf nicht negativ sein."
            return false
        }
        return true
    }
}

#Preview {
    AddContractView(
        contract: .constant(Contract(
            id: nil,
            clientID: nil,
            vereinID: nil,
            startDatum: Date(),
            endDatum: nil,
            gehalt: nil,
            vertragsdetails: nil
        )),
        isEditing: false,
        onSave: { _ in },
        onCancel: {}
    )
    .environmentObject(AuthManager())
}



//
//  ClientContractsView.swift

import SwiftUI
import FirebaseFirestore

struct ClientContractsView: View {
    let client: Client
    @State private var contracts: [Contract] = []
    @State private var showingAddContract = false
    @State private var isEditing = false
    @State private var errorMessage: String = ""
    @State private var newContract = Contract(
        id: nil,
        clientID: nil,
        vereinID: nil,
        startDatum: Date(),
        endDatum: nil,
        gehalt: nil,
        vertragsdetails: nil
    )

    var body: some View {
        NavigationStack {
            List {
                ForEach(contracts) { contract in
                    NavigationLink(destination: ContractDetailView(contract: contract)) {
                        VStack(alignment: .leading) {
                            Text("\(client.vorname) \(client.name)")
                                .font(.headline)
                                .foregroundColor(.white) // Weiße Schrift
                            if let vereinID = contract.vereinID {
                                Text(vereinID)
                                    .foregroundColor(.white) // Weiße Schrift
                            }
                            if let endDatum = contract.endDatum {
                                Text("Ende: \(dateFormatter.string(from: endDatum))")
                                    .foregroundColor(.white) // Weiße Schrift
                            }
                        }
                    }
                    .listRowBackground(Color.gray.opacity(0.2)) // Dunklerer Hintergrund für Listenelemente
                    .swipeActions {
                        Button {
                            isEditing = true
                            newContract = contract
                            showingAddContract = true
                        } label: {
                            Label("Bearbeiten", systemImage: "pencil")
                                .foregroundColor(.white) // Weiße Schrift und Symbol
                        }
                        Button(role: .destructive) {
                            Task {
                                await deleteContract(contract)
                            }
                        } label: {
                            Label("Löschen", systemImage: "trash")
                                .foregroundColor(.white) // Weiße Schrift und Symbol
                        }
                    }
                }
            }
            .scrollContentBackground(.hidden) // Standard-Hintergrund der Liste ausblenden
            .background(Color.black) // Schwarzer Hintergrund für die Liste
            .navigationTitle("Verträge von \(client.vorname) \(client.name)")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Neuen Vertrag anlegen") {
                        showingAddContract = true
                        isEditing = false
                        newContract = Contract(
                            id: nil,
                            clientID: client.id,
                            vereinID: nil,
                            startDatum: Date(),
                            endDatum: nil,
                            gehalt: nil,
                            vertragsdetails: nil
                        )
                    }
                    .foregroundColor(.white) // Weiße Schrift
                }
            }
            .sheet(isPresented: $showingAddContract) {
                AddContractView(
                    contract: $newContract,
                    isEditing: isEditing,
                    onSave: { contract in
                        Task {
                            if isEditing {
                                await updateContract(contract)
                            } else {
                                await createContract(contract)
                            }
                            await MainActor.run {
                                showingAddContract = false
                                isEditing = false
                                newContract = Contract(
                                    id: nil,
                                    clientID: client.id,
                                    vereinID: nil,
                                    startDatum: Date(),
                                    endDatum: nil,
                                    gehalt: nil,
                                    vertragsdetails: nil
                                )
                            }
                        }
                    },
                    onCancel: {
                        Task {
                            await MainActor.run {
                                showingAddContract = false
                                isEditing = false
                                newContract = Contract(
                                    id: nil,
                                    clientID: client.id,
                                    vereinID: nil,
                                    startDatum: Date(),
                                    endDatum: nil,
                                    gehalt: nil,
                                    vertragsdetails: nil
                                )
                            }
                        }
                    }
                )
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
            .task {
                await loadContracts()
            }
        }
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    private func loadContracts() async {
        guard let clientID = client.id else { return }
        do {
            let (loadedContracts, _) = try await FirestoreManager.shared.getContracts(lastDocument: nil, limit: 1000)
            await MainActor.run {
                contracts = loadedContracts.filter { $0.clientID == clientID }
            }
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Laden der Verträge: \(error.localizedDescription)"
            }
        }
    }

    private func createContract(_ contract: Contract) async {
        do {
            try await FirestoreManager.shared.createContract(contract: contract)
            await loadContracts()
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Hinzufügen des Vertrags: \(error.localizedDescription)"
            }
        }
    }

    private func updateContract(_ contract: Contract) async {
        do {
            try await FirestoreManager.shared.updateContract(contract: contract)
            await loadContracts()
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Aktualisieren des Vertrags: \(error.localizedDescription)"
            }
        }
    }

    private func deleteContract(_ contract: Contract) async {
        guard let id = contract.id else { return }
        do {
            try await FirestoreManager.shared.deleteContract(contractID: id)
            await loadContracts()
        } catch {
            await MainActor.run {
                errorMessage = "Fehler beim Löschen des Vertrags: \(error.localizedDescription)"
            }
        }
    }
}

#Preview {
    ClientContractsView(client: Client(
        typ: "Spieler",
        name: "Mustermann",
        vorname: "Max",
        geschlecht: "männlich",
        vereinID: nil
    ))
    .environmentObject(AuthManager())
}



//
//  ContractDetailView.swift

import SwiftUI
import FirebaseFirestore

struct ContractDetailView: View {
    let contract: Contract
    @EnvironmentObject var authManager: AuthManager
    @State private var showingEditSheet = false
    @State private var client: Client? = nil
    @State private var club: Club? = nil
    @State private var errorMessage = ""
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                Text("Vertragsdetails")
                    .font(.title)
                    .fontWeight(.bold)
                    .padding()
                    .foregroundColor(.white) // Weiße Schrift
                
                VStack(alignment: .leading, spacing: 10) {
                    if let client = client {
                        Text("Klient: \(client.vorname) \(client.name)")
                            .font(.headline)
                            .foregroundColor(.white) // Weiße Schrift
                    }
                    if let club = club {
                        Text("Verein: \(club.name)")
                            .font(.headline)
                            .foregroundColor(.white) // Weiße Schrift
                    }
                    Text("Startdatum: \(dateFormatter.string(from: contract.startDatum))")
                        .foregroundColor(.white) // Weiße Schrift
                    if let endDatum = contract.endDatum {
                        Text("Enddatum: \(dateFormatter.string(from: endDatum))")
                            .foregroundColor(.white) // Weiße Schrift
                    }
                    if let gehalt = contract.gehalt {
                        Text("Gehalt: \(String(format: "%.2f €", gehalt))")
                            .foregroundColor(.white) // Weiße Schrift
                    }
                    if let vertragsdetails = contract.vertragsdetails {
                        Text("Details: \(vertragsdetails)")
                            .foregroundColor(.white) // Weiße Schrift
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.2)) // Dunklerer Hintergrund
                .cornerRadius(10)
                
                if authManager.userRole == .mitarbeiter {
                    Button("Bearbeiten") {
                        showingEditSheet = true
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.blue) // Blaue Schaltfläche
                    .foregroundColor(.white) // Weiße Schrift
                    .padding()
                }
                
                Spacer()
            }
            .padding()
            .background(Color.black) // Schwarzer Hintergrund für die gesamte View
            .navigationTitle("Vertrag")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .task {
                await loadClientAndClub()
            }
            .sheet(isPresented: $showingEditSheet) {
                AddContractView(
                    contract: .constant(contract),
                    isEditing: true,
                    onSave: { _ in
                        showingEditSheet = false
                    },
                    onCancel: {
                        showingEditSheet = false
                    }
                )
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
        }
    }
    
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter
    }()
    
    private func loadClientAndClub() async {
        do {
            if let clientID = contract.clientID {
                let (clients, _) = try await FirestoreManager.shared.getClients(lastDocument: nil, limit: 1000)
                await MainActor.run {
                    self.client = clients.first { $0.id == clientID }
                }
            }
            if let vereinID = contract.vereinID {
                let (clubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
                await MainActor.run {
                    self.club = clubs.first { $0.name == vereinID }
                }
            }
        } catch {
            errorMessage = "Fehler beim Laden der Daten: \(error.localizedDescription)"
        }
    }
}

#Preview {
    ContractDetailView(contract: Contract(
        id: "1",
        clientID: "client1",
        vereinID: "Verein1",
        startDatum: Date(),
        endDatum: Date().addingTimeInterval(3600 * 24 * 365),
        gehalt: 50000.0,
        vertragsdetails: "Standardvertrag"
    ))
    .environmentObject(AuthManager())
}



//
//  ContractListView.swift

import SwiftUI
import FirebaseFirestore

struct ContractListView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var viewModel = ContractViewModel()
    @State private var showingAddContract = false
    @State private var isEditing = false
    @State private var newContract: Contract = defaultContract()
    @State private var errorMessage = ""

    var body: some View {
        NavigationStack {
            contractList
                .navigationTitle(isEditing ? "Vertrag bearbeiten" : "Vertragsübersicht")
                .foregroundColor(.white)
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        if authManager.userRole == .mitarbeiter {
                            Button("Neuen Vertrag anlegen") {
                                if authManager.isLoggedIn {
                                    showingAddContract = true
                                    isEditing = false
                                    resetNewContract()
                                } else {
                                    errorMessage = "Du musst angemeldet sein."
                                }
                            }
                            .foregroundColor(.white)
                            .disabled(!authManager.isLoggedIn)
                        }
                    }
                }
                .sheet(isPresented: $showingAddContract) {
                    AddContractView(
                        contract: $newContract,
                        isEditing: isEditing,
                        onSave: { contract in
                            Task {
                                await viewModel.saveContract(contract)
                                await MainActor.run {
                                    showingAddContract = false
                                    isEditing = false
                                    resetNewContract()
                                }
                            }
                        },
                        onCancel: {
                            showingAddContract = false
                            isEditing = false
                            resetNewContract()
                        }
                    )
                }
                .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) {
                            errorMessage = ""
                        }
                    )
                }
                .task {
                    await viewModel.loadContracts()
                }
                .background(Color.black)
        }
    }

    private var contractList: some View {
        List {
            ForEach(viewModel.contracts) { contract in
                ContractRowView(
                    contract: contract,
                    viewModel: viewModel,
                    onDelete: {
                        if authManager.userRole == .mitarbeiter {
                            Task { await viewModel.deleteContract(contract) }
                        }
                    },
                    onEdit: {
                        if authManager.userRole == .mitarbeiter {
                            isEditing = true
                            newContract = contract
                            showingAddContract = true
                        }
                    },
                    isLast: contract == viewModel.contracts.last
                )
                .listRowBackground(Color.gray.opacity(0.2))
            }
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .tint(.white)
                    .listRowBackground(Color.black)
            }
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    private func resetNewContract() {
        newContract = ContractListView.defaultContract()
    }

    private static func defaultContract() -> Contract {
        Contract(
            id: nil,
            clientID: nil,
            vereinID: nil,
            startDatum: Date(),
            endDatum: nil,
            gehalt: nil,
            vertragsdetails: nil
        )
    }
}

struct ContractRowView: View {
    let contract: Contract
    let viewModel: ContractViewModel
    let onDelete: () -> Void
    let onEdit: () -> Void
    let isLast: Bool
    @EnvironmentObject var authManager: AuthManager
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    var body: some View {
        VStack(alignment: .leading) {
            clientText
            vereinText
            endDatumText
        }
        .swipeActions {
            if authManager.userRole == .mitarbeiter {
                Button(role: .destructive, action: onDelete) {
                    Label("Löschen", systemImage: "trash")
                        .foregroundColor(.white)
                }
                Button(action: onEdit) {
                    Label("Bearbeiten", systemImage: "pencil")
                        .foregroundColor(.white)
                }
                .tint(.blue)
            }
        }
        .onAppear {
            if isLast {
                Task { await viewModel.loadContracts(loadMore: true) }
            }
        }
    }

    private var clientText: some View {
        if let clientID = contract.clientID,
           let client = viewModel.clients.first(where: { $0.id == clientID }) {
            Text("\(client.vorname) \(client.name)")
                .font(.headline)
                .foregroundColor(.white)
        } else {
            Text("Unbekannt")
                .font(.headline)
                .foregroundColor(.white)
        }
    }

    private var vereinText: some View {
        if let vereinID = contract.vereinID,
           let club = viewModel.clubs.first(where: { $0.name == vereinID }) {
            Text(club.name)
                .foregroundColor(.white)
        } else {
            Text("Unbekannt")
                .foregroundColor(.white)
        }
    }

    private var endDatumText: some View {
        Group {
            if let endDatum = contract.endDatum {
                Text("Ende: \(dateFormatter.string(from: endDatum))")
                    .foregroundColor(.white)
            } else {
                EmptyView()
            }
        }
    }
}

#Preview {
    ContractListView()
        .environmentObject(AuthManager())
}



//
//  ContractViewModel.swift

import SwiftUI
import FirebaseFirestore

class ContractViewModel: ObservableObject {
    @Published var contracts: [Contract] = []
    @Published var clients: [Client] = []
    @Published var clubs: [Club] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = [] // Warteschlange für Fehlermeldungen
    @Published var isShowingError = false
    @Published var isLoading: Bool = false
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    func loadContracts(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newContracts, newLastDoc) = try await FirestoreManager.shared.getContracts(
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore { contracts.append(contentsOf: newContracts) } else { contracts = newContracts }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }

        do {
            let (loadedClients, _) = try await FirestoreManager.shared.getClients(lastDocument: nil, limit: 1000)
            let (loadedClubs, _) = try await FirestoreManager.shared.getClubs(lastDocument: nil, limit: 1000)
            await MainActor.run {
                clients = loadedClients
                clubs = loadedClubs
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Laden der Klienten/Vereine: \(error.localizedDescription)")
            }
        }
    }

    func saveContract(_ contract: Contract) async {
        do {
            if contract.id != nil {
                try await FirestoreManager.shared.updateContract(contract: contract)
            } else {
                try await FirestoreManager.shared.createContract(contract: contract)
            }
            await loadContracts()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
            }
        }
    }

    func deleteContract(_ contract: Contract) async {
        guard let id = contract.id else {
            await MainActor.run {
                addErrorToQueue("Keine Vertrags-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteContract(contractID: id)
            await loadContracts()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    func expiringContracts(days: Int) -> [Contract] {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: days, to: Date())!
        return contracts
            .filter { contract in
                guard let endDatum = contract.endDatum else { return false }
                return endDatum <= cutoffDate && endDatum >= Date()
            }
            .sorted { $0.endDatum! < $1.endDatum! }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/9. Contacts
//
//  ContactsView.swift

import SwiftUI
import FirebaseFirestore

struct ContactsView: View {
    @EnvironmentObject var authManager: AuthManager
    @State private var clients: [Client] = []
    @State private var funktionäre: [Funktionär] = []
    @State private var filterType: Constants.ContactFilterType = .all
    @State private var groupBy: Constants.GroupByOption = .none
    @State private var showingAddClientSheet = false
    @State private var showingAddFunktionärSheet = false
    @State private var newClient = Client(
        typ: "Spieler",
        name: "",
        vorname: "",
        geschlecht: "männlich"
    )
    @State private var newFunktionär = Funktionär(
        name: "",
        vorname: ""
    )
    @State private var errorMessage = ""
    @State private var clientListener: ListenerRegistration?
    @State private var funktionärListener: ListenerRegistration?

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                filterPicker
                groupByPicker
                contactsList
            }
            .navigationTitle("Kontakte")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .toolbar { toolbarContent }
            .sheet(isPresented: $showingAddClientSheet) {
                AddClientView()
                    .environmentObject(authManager)
            }
            .sheet(isPresented: $showingAddFunktionärSheet) {
                AddFunktionärView(
                    funktionär: $newFunktionär,
                    onSave: { updatedFunktionär in
                        Task {
                            do {
                                try await FirestoreManager.shared.createFunktionär(funktionär: updatedFunktionär)
                                await MainActor.run {
                                    resetNewFunktionär()
                                    showingAddFunktionärSheet = false
                                }
                            } catch {
                                errorMessage = "Fehler beim Speichern des Funktionärs: \(error.localizedDescription)"
                            }
                        }
                    },
                    onCancel: {
                        resetNewFunktionär()
                        showingAddFunktionärSheet = false
                    }
                )
            }
            .alert(isPresented: .constant(!errorMessage.isEmpty)) {
                Alert(
                    title: Text("Fehler").foregroundColor(.white),
                    message: Text(errorMessage).foregroundColor(.white),
                    dismissButton: .default(Text("OK").foregroundColor(.white)) {
                        errorMessage = ""
                    }
                )
            }
            .task {
                await setupRealtimeListeners()
            }
            .onDisappear {
                clientListener?.remove()
                funktionärListener?.remove()
            }
            .background(Color.black) // Schwarzer Hintergrund für die gesamte View
        }
    }

    private var filterPicker: some View {
        Picker("Filter", selection: $filterType) {
            ForEach(Constants.ContactFilterType.allCases, id: \.self) { type in
                Text(type.rawValue).tag(type)
            }
        }
        .pickerStyle(SegmentedPickerStyle())
        .foregroundColor(.white) // Weiße Schrift
        .padding()
        .background(Color.black) // Schwarzer Hintergrund
    }

    private var groupByPicker: some View {
        Picker("Gruppieren nach", selection: $groupBy) {
            ForEach(Constants.GroupByOption.allCases, id: \.self) { option in
                Text(option.rawValue).tag(option)
            }
        }
        .pickerStyle(SegmentedPickerStyle())
        .foregroundColor(.white) // Weiße Schrift
        .padding()
        .background(Color.black) // Schwarzer Hintergrund
    }

    private var contactsList: some View {
        Group {
            if groupedContacts.isEmpty {
                Text("Keine Kontakte vorhanden.")
                    .foregroundColor(.gray)
                    .padding()
            } else {
                List {
                    if groupBy == .none {
                        ForEach(filteredContacts) { contact in
                            contactRow(for: contact)
                        }
                    } else {
                        ForEach(groupedContacts.keys.sorted(), id: \.self) { key in
                            Section(header: Text(key).font(.headline).foregroundColor(.white)) {
                                ForEach(groupedContacts[key] ?? []) { contact in
                                    contactRow(for: contact)
                                }
                            }
                        }
                    }
                }
                .scrollContentBackground(.hidden) // Standard-Hintergrund der Liste ausblenden
                .background(Color.black) // Schwarzer Hintergrund für die Liste
            }
        }
    }

    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            HStack {
                Button(action: { showingAddClientSheet = true }) {
                    Image(systemName: "person.badge.plus")
                        .foregroundColor(.white) // Weißes Symbol
                }
                Button(action: { showingAddFunktionärSheet = true }) {
                    Image(systemName: "person.2.badge.gearshape")
                        .foregroundColor(.white) // Weißes Symbol
                }
            }
        }
    }

    private var filteredContacts: [Contact] {
        switch filterType {
        case .all:
            return clients.map { Contact.client($0) } + funktionäre.map { Contact.funktionär($0) }
        case .clients:
            return clients.map { Contact.client($0) }
        case .funktionäre:
            return funktionäre.map { Contact.funktionär($0) }
        }
    }

    private var groupedContacts: [String: [Contact]] {
        var grouped: [String: [Contact]] = [:]
        let contacts = filteredContacts

        switch groupBy {
        case .none:
            return [:]
        case .club:
            for contact in contacts {
                let key = contact.club ?? "Ohne Verein"
                if grouped[key] == nil {
                    grouped[key] = []
                }
                grouped[key]?.append(contact)
            }
        case .type:
            for contact in contacts {
                let key: String
                switch contact {
                case .client(let client):
                    key = client.typ
                case .funktionär(let funktionär):
                    key = funktionär.positionImVerein ?? "Funktionär"
                }
                if grouped[key] == nil {
                    grouped[key] = []
                }
                grouped[key]?.append(contact)
            }
        }
        return grouped
    }

    @ViewBuilder
    private func contactRow(for contact: Contact) -> some View {
        switch contact {
        case .client(let client):
            NavigationLink(destination: ClientView(client: .constant(client))) {
                HStack(spacing: 10) {
                    if let profilbildURL = client.profilbildURL, let url = URL(string: profilbildURL) {
                        AsyncImage(url: url) { phase in
                            switch phase {
                            case .empty:
                                ProgressView()
                                    .frame(width: 40, height: 40)
                                    .tint(.white) // Weißer Ladeindikator
                            case .success(let image):
                                image
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            case .failure:
                                Image(systemName: "person.circle.fill")
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .foregroundColor(.gray)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            @unknown default:
                                Image(systemName: "person.circle.fill")
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .foregroundColor(.gray)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            }
                        }
                    } else {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .scaledToFill()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    }

                    VStack(alignment: .leading, spacing: 2) {
                        Text("\(client.vorname) \(client.name)")
                            .font(.headline)
                            .foregroundColor(.white) // Weiße Schrift
                        if let vereinID = client.vereinID {
                            Text(vereinID)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        if let abteilung = client.abteilung {
                            Text(abteilung)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)

                    Text(client.typ == "Spieler" ? "♂" : "♀")
                        .font(.system(size: 14))
                        .foregroundColor(client.typ == "Spieler" ? .blue : .pink)
                }
                .padding(.vertical, 5)
            }
            .listRowBackground(Color.gray.opacity(0.2)) // Dunklerer Hintergrund für Listenelemente
        case .funktionär(let funktionär):
            NavigationLink(destination: FunktionärView(funktionär: .constant(funktionär))) {
                HStack(spacing: 10) {
                    if let profilbildURL = funktionär.profilbildURL, let url = URL(string: profilbildURL) {
                        AsyncImage(url: url) { phase in
                            switch phase {
                            case .empty:
                                ProgressView()
                                    .frame(width: 40, height: 40)
                                    .tint(.white) // Weißer Ladeindikator
                            case .success(let image):
                                image
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            case .failure:
                                Image(systemName: "person.circle.fill")
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .foregroundColor(.gray)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            @unknown default:
                                Image(systemName: "person.circle.fill")
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 40, height: 40)
                                    .foregroundColor(.gray)
                                    .clipShape(Circle())
                                    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                            }
                        }
                    } else {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .scaledToFill()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                            .clipShape(Circle())
                            .overlay(Circle().stroke(Color.gray, lineWidth: 1))
                    }

                    VStack(alignment: .leading, spacing: 2) {
                        Text("\(funktionär.vorname) \(funktionär.name)")
                            .font(.headline)
                            .foregroundColor(.white) // Weiße Schrift
                        if let position = funktionär.positionImVerein {
                            Text(position)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        if let vereinID = funktionär.vereinID {
                            Text(vereinID)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        if let abteilung = funktionär.abteilung {
                            Text(abteilung)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }
                .padding(.vertical, 5)
            }
            .listRowBackground(Color.gray.opacity(0.2)) // Dunklerer Hintergrund für Listenelemente
        }
    }

    private func resetNewClient() {
        newClient = Client(
            typ: "Spieler",
            name: "",
            vorname: "",
            geschlecht: "männlich"
        )
    }

    private func resetNewFunktionär() {
        newFunktionär = Funktionär(
            name: "",
            vorname: ""
        )
    }

    private func setupRealtimeListeners() async {
        let clientListener = Firestore.firestore().collection("clients")
            .order(by: "name")
            .addSnapshotListener { snapshot, error in
                if let error = error {
                    self.errorMessage = "Fehler beim Laden der Klienten: \(error.localizedDescription)"
                    return
                }
                guard let documents = snapshot?.documents else { return }
                let updatedClients = documents.compactMap { try? $0.data(as: Client.self) }
                DispatchQueue.main.async {
                    self.clients = updatedClients
                }
            }

        let funktionärListener = Firestore.firestore().collection("funktionare")
            .order(by: "name")
            .addSnapshotListener { snapshot, error in
                if let error = error {
                    self.errorMessage = "Fehler beim Laden der Funktionäre: \(error.localizedDescription)"
                    return
                }
                guard let documents = snapshot?.documents else { return }
                let updatedFunktionäre = documents.compactMap { try? $0.data(as: Funktionär.self) }
                DispatchQueue.main.async {
                    self.funktionäre = updatedFunktionäre
                }
            }

        await MainActor.run {
            self.clientListener = clientListener
            self.funktionärListener = funktionärListener
        }
    }
}

enum Contact: Identifiable {
    case client(Client)
    case funktionär(Funktionär)

    var id: String {
        switch self {
        case .client(let client):
            return client.id ?? UUID().uuidString
        case .funktionär(let funktionär):
            return funktionär.id ?? UUID().uuidString
        }
    }

    var club: String? {
        switch self {
        case .client(let client):
            return client.vereinID
        case .funktionär(let funktionär):
            return funktionär.vereinID
        }
    }
}

#Preview {
    ContactsView()
        .environmentObject(AuthManager())
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/10. Sponsor
//
//  AddSponsorView.swift

import SwiftUI

struct AddSponsorView: View {
    @Binding var sponsor: Sponsor
    var onSave: (Sponsor) -> Void
    var onCancel: () -> Void

    @State private var contacts: [Sponsor.Contact] = []
    @State private var showingAddContact = false
    @State private var newContactName: String = ""
    @State private var newContactRegion: String? = nil
    @State private var newContactTelefon: String = ""
    @State private var newContactEmail: String = ""

    var body: some View {
        NavigationView {
            mainFormContent
                .navigationTitle("Sponsor anlegen")
                .foregroundColor(.white)
                .toolbar { toolbarItems }
                .sheet(isPresented: $showingAddContact) { addContactSheet }
                .onAppear { if let existingContacts = sponsor.contacts { contacts = existingContacts } }
        }
    }

    // Hauptformular-Inhalt
    private var mainFormContent: some View {
        Form {
            sponsorDataSection
            contactInfoSection
            contactsSection
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    // Toolbar-Items
    private var toolbarItems: some ToolbarContent {
        Group {
            ToolbarItem(placement: .cancellationAction) {
                Button("Abbrechen") { onCancel() }
                    .foregroundColor(.white)
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Speichern") {
                    sponsor.contacts = contacts.isEmpty ? nil : contacts
                    onSave(sponsor)
                }
                .disabled(sponsor.name.isEmpty)
                .foregroundColor(.white)
            }
        }
    }

    // Sponsordaten Sektion
    private var sponsorDataSection: some View {
        Section(header: Text("Sponsordaten").foregroundColor(.white)) {
            TextField("Name", text: $sponsor.name)
                .foregroundColor(.white)
            Picker("Kategorie", selection: $sponsor.category) {
                Text("Keine Kategorie").tag(String?.none)
                ForEach(Constants.sponsorCategories, id: \.self) { category in
                    Text(category).tag(String?.some(category))
                }
            }
            .pickerStyle(.menu)
            .foregroundColor(.white)
            .accentColor(.white)
        }
    }

    // Kontaktinformationen Sektion
    private var contactInfoSection: some View {
        Section(header: Text("Kontaktinformationen").foregroundColor(.white)) {
            TextField("Telefon", text: Binding(
                get: { sponsor.kontaktTelefon ?? "" },
                set: { sponsor.kontaktTelefon = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("E-Mail", text: Binding(
                get: { sponsor.kontaktEmail ?? "" },
                set: { sponsor.kontaktEmail = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
            TextField("Adresse", text: Binding(
                get: { sponsor.adresse ?? "" },
                set: { sponsor.adresse = $0.isEmpty ? nil : $0 }
            ))
                .foregroundColor(.white)
        }
    }

    // Ansprechpartner Sektion
    private var contactsSection: some View {
        Section(header: Text("Ansprechpartner").foregroundColor(.white)) {
            if contacts.isEmpty {
                Text("Keine Ansprechpartner vorhanden.")
                    .foregroundColor(.gray)
            } else {
                ForEach(contacts) { contact in
                    contactRow(contact: contact)
                }
            }
            Button("Ansprechpartner hinzufügen") {
                showingAddContact = true
                newContactName = ""
                newContactRegion = nil
                newContactTelefon = ""
                newContactEmail = ""
            }
            .foregroundColor(.white)
        }
    }

    // Ansprechpartner Zeile
    private func contactRow(contact: Sponsor.Contact) -> some View {
        VStack(alignment: .leading) {
            Text("\(contact.name) (\(contact.region))")
                .font(.subheadline)
                .foregroundColor(.white)
            if let telefon = contact.telefon {
                Text("Telefon: \(telefon)")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            if let email = contact.email {
                Text("E-Mail: \(email)")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
        .swipeActions {
            Button(role: .destructive) {
                contacts.removeAll { $0.id == contact.id }
            } label: {
                Label("Löschen", systemImage: "trash")
                    .foregroundColor(.white)
            }
        }
    }

    // Ansprechpartner Hinzufügen Sheet
    private var addContactSheet: some View {
        NavigationView {
            Form {
                Section(header: Text("Ansprechpartner").foregroundColor(.white)) {
                    TextField("Name", text: $newContactName)
                        .foregroundColor(.white)
                    Picker("Region", selection: $newContactRegion) {
                        Text("Keine Region").tag(String?.none)
                        ForEach(Constants.nationalities, id: \.self) { country in
                            Text(country).tag(String?.some(country))
                        }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Telefon", text: $newContactTelefon)
                        .foregroundColor(.white)
                    TextField("E-Mail", text: $newContactEmail)
                        .foregroundColor(.white)
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Ansprechpartner hinzufügen")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { showingAddContact = false }
                        .foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Hinzufügen") {
                        let newContact = Sponsor.Contact(
                            id: UUID().uuidString,
                            name: newContactName,
                            region: newContactRegion ?? "Andere",
                            telefon: newContactTelefon.isEmpty ? nil : newContactTelefon,
                            email: newContactEmail.isEmpty ? nil : newContactEmail
                        )
                        contacts.append(newContact)
                        showingAddContact = false
                    }
                    .disabled(newContactName.isEmpty || newContactRegion == nil)
                    .foregroundColor(.white)
                }
            }
        }
    }
}

#Preview {
    AddSponsorView(
        sponsor: .constant(Sponsor(
            id: nil,
            name: "",
            category: nil,
            contacts: nil,
            kontaktTelefon: nil,
            kontaktEmail: nil,
            adresse: nil,
            gesponsorteVereine: nil
        )),
        onSave: { _ in },
        onCancel: {}
    )
}



//
//  EditSponsorView.swift

import SwiftUI

struct EditSponsorView: View {
    @Binding var sponsor: Sponsor
    var onSave: (Sponsor) -> Void
    var onCancel: () -> Void

    @State private var contacts: [Sponsor.Contact] = []
    @State private var showingAddContact = false
    @State private var newContactName: String = ""
    @State private var newContactRegion: String? = nil
    @State private var newContactTelefon: String = ""
    @State private var newContactEmail: String = ""

    var body: some View {
        NavigationView {
            mainFormContent
                .navigationTitle("Sponsor bearbeiten")
                .foregroundColor(.white)
                .toolbar { toolbarItems }
                .sheet(isPresented: $showingAddContact) { addContactSheet }
                .onAppear { if let existingContacts = sponsor.contacts { contacts = existingContacts } }
        }
    }

    private var mainFormContent: some View {
        Form {
            sponsorDataSection
            contactInfoSection
            contactsSection
        }
        .scrollContentBackground(.hidden)
        .background(Color.black)
    }

    private var toolbarItems: some ToolbarContent {
        Group {
            ToolbarItem(placement: .cancellationAction) {
                Button("Abbrechen") { onCancel() }
                    .foregroundColor(.white)
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Speichern") {
                    sponsor.contacts = contacts.isEmpty ? nil : contacts
                    onSave(sponsor)
                }
                .disabled(sponsor.name.isEmpty)
                .foregroundColor(.white)
            }
        }
    }

    private var sponsorDataSection: some View {
        Section(header: Text("Sponsordaten").foregroundColor(.white)) {
            TextField("Name", text: $sponsor.name).foregroundColor(.white)
            Picker("Kategorie", selection: $sponsor.category) {
                Text("Keine Kategorie").tag(String?.none)
                ForEach(Constants.sponsorCategories, id: \.self) { category in
                    Text(category).tag(String?.some(category))
                }
            }
            .pickerStyle(.menu)
            .foregroundColor(.white)
            .accentColor(.white)
        }
    }

    private var contactInfoSection: some View {
        Section(header: Text("Kontaktinformationen").foregroundColor(.white)) {
            TextField("Telefon", text: Binding(get: { sponsor.kontaktTelefon ?? "" }, set: { sponsor.kontaktTelefon = $0.isEmpty ? nil : $0 })).foregroundColor(.white)
            TextField("E-Mail", text: Binding(get: { sponsor.kontaktEmail ?? "" }, set: { sponsor.kontaktEmail = $0.isEmpty ? nil : $0 })).foregroundColor(.white)
            TextField("Adresse", text: Binding(get: { sponsor.adresse ?? "" }, set: { sponsor.adresse = $0.isEmpty ? nil : $0 })).foregroundColor(.white)
        }
    }

    private var contactsSection: some View {
        Section(header: Text("Ansprechpartner").foregroundColor(.white)) {
            if contacts.isEmpty {
                Text("Keine Ansprechpartner vorhanden.").foregroundColor(.gray)
            } else {
                ForEach(contacts) { contact in contactRow(contact: contact) }
            }
            Button("Ansprechpartner hinzufügen") {
                showingAddContact = true
                newContactName = ""
                newContactRegion = nil
                newContactTelefon = ""
                newContactEmail = ""
            }
            .foregroundColor(.white)
        }
    }

    private func contactRow(contact: Sponsor.Contact) -> some View {
        VStack(alignment: .leading) {
            Text("\(contact.name) (\(contact.region))").font(.subheadline).foregroundColor(.white)
            if let telefon = contact.telefon { Text("Telefon: \(telefon)").font(.caption).foregroundColor(.gray) }
            if let email = contact.email { Text("E-Mail: \(email)").font(.caption).foregroundColor(.gray) }
        }
        .swipeActions {
            Button(role: .destructive) { contacts.removeAll { $0.id == contact.id } } label: {
                Label("Löschen", systemImage: "trash").foregroundColor(.white)
            }
        }
    }

    private var addContactSheet: some View {
        NavigationView {
            Form {
                Section(header: Text("Ansprechpartner").foregroundColor(.white)) {
                    TextField("Name", text: $newContactName).foregroundColor(.white)
                    Picker("Region", selection: $newContactRegion) {
                        Text("Keine Region").tag(String?.none)
                        ForEach(Constants.nationalities, id: \.self) { country in Text(country).tag(String?.some(country)) }
                    }
                    .pickerStyle(.menu)
                    .foregroundColor(.white)
                    .accentColor(.white)
                    TextField("Telefon", text: $newContactTelefon).foregroundColor(.white)
                    TextField("E-Mail", text: $newContactEmail).foregroundColor(.white)
                }
            }
            .scrollContentBackground(.hidden)
            .background(Color.black)
            .navigationTitle("Ansprechpartner hinzufügen")
            .foregroundColor(.white)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { showingAddContact = false }.foregroundColor(.white)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Hinzufügen") {
                        let newContact = Sponsor.Contact(
                            id: UUID().uuidString,
                            name: newContactName,
                            region: newContactRegion ?? "Andere",
                            telefon: newContactTelefon.isEmpty ? nil : newContactTelefon,
                            email: newContactEmail.isEmpty ? nil : newContactEmail
                        )
                        contacts.append(newContact)
                        showingAddContact = false
                    }
                    .disabled(newContactName.isEmpty || newContactRegion == nil)
                    .foregroundColor(.white)
                }
            }
        }
    }
}

#Preview {
    EditSponsorView(
        sponsor: .constant(Sponsor(
            id: "1",
            name: "Nike",
            category: "Sportartikelhersteller",
            contacts: [Sponsor.Contact(id: UUID().uuidString, name: "John Doe", region: "USA", telefon: "+123456789", email: "john.doe@nike.com")],
            kontaktTelefon: "+123456789",
            kontaktEmail: "contact@nike.com",
            adresse: "123 Nike Street",
            gesponsorteVereine: ["Bayern München"]
        )),
        onSave: { _ in },
        onCancel: {}
    )
}



//
//  SponsorListView.swift

import SwiftUI
import FirebaseFirestore

struct SponsorListView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var viewModel = SponsorViewModel()
    @State private var showingAddSponsor = false
    @State private var newSponsor = Sponsor(
        id: nil,
        name: "",
        category: nil,
        contacts: nil,
        kontaktTelefon: nil,
        kontaktEmail: nil,
        adresse: nil,
        gesponsorteVereine: nil
    )

    var body: some View {
        NavigationStack {
            sponsorList
                .navigationTitle("Sponsorübersicht")
                .foregroundColor(.white) // Weiße Schrift für den Titel
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Neuen Sponsor anlegen") {
                            if authManager.isLoggedIn {
                                showingAddSponsor = true
                                newSponsor = Sponsor(
                                    id: nil,
                                    name: "",
                                    category: nil,
                                    contacts: nil,
                                    kontaktTelefon: nil,
                                    kontaktEmail: nil,
                                    adresse: nil,
                                    gesponsorteVereine: nil
                                )
                            } else {
                                viewModel.errorMessage = "Du musst angemeldet sein."
                            }
                        }
                        .foregroundColor(.white) // Weiße Schrift
                        .disabled(!authManager.isLoggedIn)
                    }
                }
                .sheet(isPresented: $showingAddSponsor) {
                    AddSponsorView(
                        sponsor: $newSponsor,
                        onSave: { sponsor in
                            Task {
                                await viewModel.saveSponsor(sponsor)
                                await MainActor.run {
                                    showingAddSponsor = false
                                    newSponsor = Sponsor(
                                        id: nil,
                                        name: "",
                                        category: nil,
                                        contacts: nil,
                                        kontaktTelefon: nil,
                                        kontaktEmail: nil,
                                        adresse: nil,
                                        gesponsorteVereine: nil
                                    )
                                }
                            }
                        },
                        onCancel: {
                            showingAddSponsor = false
                            newSponsor = Sponsor(
                                id: nil,
                                name: "",
                                category: nil,
                                contacts: nil,
                                kontaktTelefon: nil,
                                kontaktEmail: nil,
                                adresse: nil,
                                gesponsorteVereine: nil
                            )
                        }
                    )
                }
                .alert(isPresented: .constant(!viewModel.errorMessage.isEmpty)) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(viewModel.errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) { viewModel.resetError() }
                    )
                }
                .task {
                    await viewModel.loadSponsors()
                }
                .background(Color.black) // Schwarzer Hintergrund für die gesamte View
        }
    }

    private var sponsorList: some View {
        List {
            ForEach(viewModel.sponsors) { sponsor in
                NavigationLink(destination: SponsorView(sponsor: sponsor)) {
                    SponsorRowView(
                        sponsor: sponsor,
                        viewModel: viewModel,
                        onDelete: {
                            Task { await viewModel.deleteSponsor(sponsor) }
                        },
                        isLast: sponsor == viewModel.sponsors.last
                    )
                }
                .listRowBackground(Color.gray.opacity(0.2)) // Dunklerer Hintergrund für Listenelemente
            }
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .tint(.white) // Weißer Ladeindikator
                    .listRowBackground(Color.black) // Schwarzer Hintergrund
            }
        }
        .scrollContentBackground(.hidden) // Standard-Hintergrund der Liste ausblenden
        .background(Color.black) // Schwarzer Hintergrund für die Liste
    }
}

struct SponsorRowView: View {
    let sponsor: Sponsor
    let viewModel: SponsorViewModel
    let onDelete: () -> Void
    let isLast: Bool

    var body: some View {
        VStack(alignment: .leading) {
            Text(sponsor.name)
                .font(.headline)
                .foregroundColor(.white) // Weiße Schrift
            if let category = sponsor.category {
                Text("Kategorie: \(category)")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            if let kontaktTelefon = sponsor.kontaktTelefon {
                Text("Telefon: \(kontaktTelefon)")
                    .font(.subheadline)
                    .foregroundColor(.white) // Weiße Schrift
            }
            if let kontaktEmail = sponsor.kontaktEmail {
                Text("E-Mail: \(kontaktEmail)")
                    .font(.subheadline)
                    .foregroundColor(.white) // Weiße Schrift
            }
            if let contacts = sponsor.contacts, !contacts.isEmpty {
                Text("Ansprechpartner:")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                ForEach(contacts) { contact in
                    Text("\(contact.name) (\(contact.region))")
                        .font(.subheadline)
                        .foregroundColor(.white) // Weiße Schrift
                }
            }
        }
        .swipeActions {
            Button(role: .destructive, action: onDelete) {
                Label("Löschen", systemImage: "trash")
                    .foregroundColor(.white) // Weiße Schrift und Symbol
            }
        }
        .onAppear {
            if isLast {
                Task { await viewModel.loadSponsors(loadMore: true) }
            }
        }
    }
}

#Preview {
    SponsorListView()
        .environmentObject(AuthManager())
}



//
//  SponsorView.swift

import SwiftUI
import FirebaseFirestore

struct SponsorView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var viewModel = SponsorViewModel()
    @State var sponsor: Sponsor
    @State private var showingEditSheet = false

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 15) {
                    VStack(spacing: 10) {
                        Text(sponsor.name)
                            .font(.title2)
                            .bold()
                            .multilineTextAlignment(.center)
                            .foregroundColor(.white) // Weiße Schrift

                        if let category = sponsor.category {
                            Text("Kategorie: \(category)")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }

                        if let kontaktTelefon = sponsor.kontaktTelefon {
                            HStack {
                                Text("Telefon: \(kontaktTelefon)")
                                    .font(.subheadline)
                                    .foregroundColor(.white) // Weiße Schrift
                                Spacer()
                                Button(action: { openURL("tel:\(kontaktTelefon)") }) {
                                    Image(systemName: "phone.fill")
                                        .foregroundColor(.white) // Weißes Symbol
                                }
                            }
                        }

                        if let kontaktEmail = sponsor.kontaktEmail {
                            HStack {
                                Text("E-Mail: \(kontaktEmail)")
                                    .font(.subheadline)
                                    .foregroundColor(.white) // Weiße Schrift
                                Spacer()
                                Button(action: { openURL("mailto:\(kontaktEmail)") }) {
                                    Image(systemName: "envelope.fill")
                                        .foregroundColor(.white) // Weißes Symbol
                                }
                            }
                        }

                        if let adresse = sponsor.adresse {
                            Text("Adresse: \(adresse)")
                                .font(.subheadline)
                                .foregroundColor(.white) // Weiße Schrift
                        }

                        if let gesponsorteVereine = sponsor.gesponsorteVereine, !gesponsorteVereine.isEmpty {
                            Text("Gesponsorte Vereine:")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            ForEach(gesponsorteVereine, id: \.self) { verein in
                                Text(verein)
                                    .font(.subheadline)
                                    .foregroundColor(.white) // Weiße Schrift
                            }
                        }

                        if let contacts = sponsor.contacts, !contacts.isEmpty {
                            Text("Ansprechpartner:")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            ForEach(contacts) { contact in
                                VStack(alignment: .leading) {
                                    Text("\(contact.name) (\(contact.region))")
                                        .font(.subheadline)
                                        .foregroundColor(.white) // Weiße Schrift
                                    if let telefon = contact.telefon {
                                        Text("Telefon: \(telefon)")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    if let email = contact.email {
                                        Text("E-Mail: \(email)")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                }
                            }
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.2)) // Dunklerer Hintergrund
                    .cornerRadius(10)
                }
                .padding()
                .background(Color.black) // Schwarzer Hintergrund für die gesamte View
                .navigationTitle(sponsor.name)
                .navigationBarTitleDisplayMode(.inline)
                .foregroundColor(.white) // Weiße Schrift für den Titel
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: { showingEditSheet = true }) {
                            Image(systemName: "pencil")
                                .foregroundColor(.white) // Weißes Symbol
                        }
                    }
                }
                .sheet(isPresented: $showingEditSheet) {
                    EditSponsorView(
                        sponsor: $sponsor,
                        onSave: { updatedSponsor in
                            Task {
                                await viewModel.saveSponsor(updatedSponsor)
                                await MainActor.run {
                                    sponsor = updatedSponsor
                                    showingEditSheet = false
                                }
                            }
                        },
                        onCancel: {
                            showingEditSheet = false
                        }
                    )
                }
            }
        }
    }

    private func openURL(_ urlString: String) {
        if let url = URL(string: urlString), UIApplication.shared.canOpenURL(url) {
            UIApplication.shared.open(url, options: [:], completionHandler: nil)
        }
    }
}

#Preview {
    SponsorView(sponsor: Sponsor(
        id: "1",
        name: "Nike",
        category: "Sportartikelhersteller",
        contacts: [
            Sponsor.Contact(id: UUID().uuidString, name: "John Doe", region: "USA", telefon: "+123456789", email: "john.doe@nike.com")
        ],
        kontaktTelefon: "+123456789",
        kontaktEmail: "contact@nike.com",
        adresse: "123 Nike Street",
        gesponsorteVereine: ["Bayern München"]
    ))
    .environmentObject(AuthManager())
}



//
//  SponsorViewModel.swift

import SwiftUI
import FirebaseFirestore

class SponsorViewModel: ObservableObject {
    @Published var sponsors: [Sponsor] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = [] // Warteschlange für Fehlermeldungen
    @Published var isShowingError = false
    @Published var isLoading: Bool = false
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    func loadSponsors(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newSponsors, newLastDoc) = try await FirestoreManager.shared.getSponsors(
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore { sponsors.append(contentsOf: newSponsors) } else { sponsors = newSponsors }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }
    }

    func saveSponsor(_ sponsor: Sponsor) async {
        do {
            if sponsor.id != nil {
                try await FirestoreManager.shared.updateSponsor(sponsor: sponsor)
            } else {
                try await FirestoreManager.shared.createSponsor(sponsor: sponsor)
            }
            await loadSponsors()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
            }
        }
    }

    func deleteSponsor(_ sponsor: Sponsor) async {
        guard let id = sponsor.id else {
            await MainActor.run {
                addErrorToQueue("Keine Sponsor-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteSponsor(sponsorID: id)
            await loadSponsors()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/11. Match
//
//  MatchListView.swift

import SwiftUI
import FirebaseFirestore

struct MatchListView: View {
    @EnvironmentObject var authManager: AuthManager
    @StateObject private var viewModel = MatchViewModel()
    @State private var showingAddMatch = false
    @State private var isEditing = false

    var body: some View {
        NavigationStack {
            matchList
                .navigationTitle(isEditing ? "Spiel bearbeiten" : "Spielübersicht")
                .foregroundColor(.white) // Weiße Schrift für den Titel
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Neues Spiel anlegen") {
                            if authManager.isLoggedIn {
                                showingAddMatch = true
                                isEditing = false
                            } else {
                                viewModel.errorMessage = "Du musst angemeldet sein."
                            }
                        }
                        .foregroundColor(.white) // Weiße Schrift
                        .disabled(!authManager.isLoggedIn)
                    }
                }
                .sheet(isPresented: $showingAddMatch) {
                    AddMatchView(
                        isEditing: isEditing,
                        initialMatch: isEditing ? viewModel.matches.first : nil,
                        onSave: { match in
                            Task {
                                await viewModel.saveMatch(match)
                                await MainActor.run {
                                    showingAddMatch = false
                                    isEditing = false
                                }
                            }
                        },
                        onCancel: {
                            showingAddMatch = false
                            isEditing = false
                        }
                    )
                }
                .alert(isPresented: .constant(!viewModel.errorMessage.isEmpty)) {
                    Alert(
                        title: Text("Fehler").foregroundColor(.white),
                        message: Text(viewModel.errorMessage).foregroundColor(.white),
                        dismissButton: .default(Text("OK").foregroundColor(.white)) { viewModel.resetError() }
                    )
                }
                .task {
                    await viewModel.loadMatches()
                }
                .background(Color.black) // Schwarzer Hintergrund für die gesamte View
        }
    }

    private var matchList: some View {
        List {
            ForEach(viewModel.matches) { match in
                MatchRowView(
                    match: match,
                    viewModel: viewModel,
                    onDelete: {
                        Task { await viewModel.deleteMatch(match) }
                    },
                    onEdit: {
                        isEditing = true
                        showingAddMatch = true
                    },
                    isLast: match == viewModel.matches.last
                )
                .listRowBackground(Color.gray.opacity(0.2)) // Dunklerer Hintergrund für Listenelemente
            }
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .tint(.white) // Weißer Ladeindikator
                    .listRowBackground(Color.black) // Schwarzer Hintergrund
            }
        }
        .scrollContentBackground(.hidden) // Standard-Hintergrund der Liste ausblenden
        .background(Color.black) // Schwarzer Hintergrund für die Liste
    }
}

struct MatchRowView: View {
    let match: Match
    let viewModel: MatchViewModel
    let onDelete: () -> Void
    let onEdit: () -> Void
    let isLast: Bool
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }()

    var body: some View {
        VStack(alignment: .leading) {
            if let heimVereinID = match.heimVereinID {
                Text("Heim: \(heimVereinID)")
                    .font(.headline)
                    .foregroundColor(.white) // Weiße Schrift
            }
            if let gastVereinID = match.gastVereinID {
                Text("Auswärts: \(gastVereinID)")
                    .foregroundColor(.white) // Weiße Schrift
            }
            Text("Datum: \(dateFormatter.string(from: match.datum))")
                .foregroundColor(.white) // Weiße Schrift
            if let ergebnis = match.ergebnis {
                Text("Ergebnis: \(ergebnis)")
                    .foregroundColor(.white) // Weiße Schrift
            }
        }
        .swipeActions {
            Button(role: .destructive, action: onDelete) {
                Label("Löschen", systemImage: "trash")
                    .foregroundColor(.white) // Weiße Schrift und Symbol
            }
            Button(action: onEdit) {
                Label("Bearbeiten", systemImage: "pencil")
                    .foregroundColor(.white) // Weiße Schrift und Symbol
            }
            .tint(.blue)
        }
        .onAppear {
            if isLast {
                Task { await viewModel.loadMatches(loadMore: true) }
            }
        }
    }
}

struct AddMatchView: View {
    let isEditing: Bool
    let initialMatch: Match?
    let onSave: (Match) -> Void
    let onCancel: () -> Void

    @State private var heimVereinID: String = ""
    @State private var gastVereinID: String = ""
    @State private var datum: Date = Date()
    @State private var ergebnis: String? = nil
    @State private var stadion: String? = nil

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Spieldaten").foregroundColor(.white)) {
                    TextField("Heim-Verein-ID", text: $heimVereinID)
                        .foregroundColor(.white) // Weiße Schrift
                    TextField("Gast-Verein-ID", text: $gastVereinID)
                        .foregroundColor(.white) // Weiße Schrift
                    DatePicker("Datum", selection: $datum, displayedComponents: .date)
                        .foregroundColor(.white) // Weiße Schrift
                        .accentColor(.white) // Weiße Akzente
                    TextField("Ergebnis", text: Binding(
                        get: { ergebnis ?? "" },
                        set: { ergebnis = $0.isEmpty ? nil : $0 }
                    ))
                        .foregroundColor(.white) // Weiße Schrift
                    TextField("Stadion", text: Binding(
                        get: { stadion ?? "" },
                        set: { stadion = $0.isEmpty ? nil : $0 }
                    ))
                        .foregroundColor(.white) // Weiße Schrift
                }
            }
            .scrollContentBackground(.hidden) // Standard-Hintergrund der Form ausblenden
            .background(Color.black) // Schwarzer Hintergrund für die Form
            .navigationTitle(isEditing ? "Spiel bearbeiten" : "Spiel anlegen")
            .foregroundColor(.white) // Weiße Schrift für den Titel
            .onAppear {
                if let match = initialMatch {
                    heimVereinID = match.heimVereinID ?? ""
                    gastVereinID = match.gastVereinID ?? ""
                    datum = match.datum
                    ergebnis = match.ergebnis
                    stadion = match.stadion
                }
            }
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") { onCancel() }
                        .foregroundColor(.white) // Weiße Schrift
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Speichern") {
                        let match = Match(
                            id: initialMatch?.id,
                            heimVereinID: heimVereinID.isEmpty ? nil : heimVereinID,
                            gastVereinID: gastVereinID.isEmpty ? nil : gastVereinID,
                            datum: datum,
                            ergebnis: ergebnis,
                            stadion: stadion
                        )
                        onSave(match)
                    }
                    .foregroundColor(.white) // Weiße Schrift
                }
            }
        }
    }
}

#Preview {
    MatchListView()
        .environmentObject(AuthManager())
}



//
//  MatchViewModel.swift

import SwiftUI
import FirebaseFirestore

class MatchViewModel: ObservableObject {
    @Published var matches: [Match] = []
    @Published var errorMessage: String = ""
    @Published var errorQueue: [String] = [] // Warteschlange für Fehlermeldungen
    @Published var isShowingError = false
    @Published var isLoading: Bool = false
    private var lastDocument: QueryDocumentSnapshot?
    private let pageSize = 20

    func loadMatches(loadMore: Bool = false) async {
        await MainActor.run { isLoading = true }
        do {
            let (newMatches, newLastDoc) = try await FirestoreManager.shared.getMatches(
                lastDocument: loadMore ? lastDocument : nil,
                limit: pageSize
            )
            await MainActor.run {
                if loadMore { matches.append(contentsOf: newMatches) } else { matches = newMatches }
                lastDocument = newLastDoc
                isLoading = false
            }
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler: \(error.localizedDescription)")
                isLoading = false
            }
        }
    }

    func saveMatch(_ match: Match) async {
        do {
            if match.id != nil {
                try await FirestoreManager.shared.updateMatch(match: match)
            } else {
                try await FirestoreManager.shared.createMatch(match: match)
            }
            await loadMatches()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Speichern: \(error.localizedDescription)")
            }
        }
    }

    func deleteMatch(_ match: Match) async {
        guard let id = match.id else {
            await MainActor.run {
                addErrorToQueue("Keine Match-ID vorhanden")
            }
            return
        }
        do {
            try await FirestoreManager.shared.deleteMatch(matchID: id)
            await loadMatches()
        } catch {
            await MainActor.run {
                addErrorToQueue("Fehler beim Löschen: \(error.localizedDescription)")
            }
        }
    }

    private func addErrorToQueue(_ message: String) {
        errorQueue.append(message)
        if !isShowingError {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        }
    }

    func resetError() {
        if !errorQueue.isEmpty {
            errorMessage = errorQueue.removeFirst()
            isShowingError = true
        } else {
            isShowingError = false
            errorMessage = ""
        }
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/12. Zugriff Extern
//
//  SoccerdonnaService.swift

import Foundation
import SwiftSoup

class SoccerdonnaService {
    static let shared = SoccerdonnaService()

    private init() {}

    func fetchPlayerData(forPlayerID playerID: String) async throws -> PlayerData {
        let urlString = "https://www.soccerdonna.de/de/spieler-name/profil/spieler_\(playerID).html"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }

        var request = URLRequest(url: url)
        request.setValue("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36", forHTTPHeaderField: "User-Agent")
        request.setValue("text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", forHTTPHeaderField: "Accept")
        request.setValue("de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7", forHTTPHeaderField: "Accept-Language")
        request.timeoutInterval = 10

        let (data, response) = try await URLSession.shared.data(for: request, delegate: nil)
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }

        let html = String(data: data, encoding: .utf8) ?? ""
        let doc: Document = try SwiftSoup.parse(html)

        var playerData = PlayerData()

        // Name
        if let nameElement = try doc.select("h1[itemprop=name]").first() {
            playerData.name = try nameElement.text()
        }

        // Position
        if let positionElement = try doc.select("td:contains(Spielposition) + td").first() {
            playerData.position = try positionElement.text()
        }

        // Nationalität
        if let nationalityElement = try doc.select("td:contains(Nationalität) + td").first() {
            playerData.nationalitaet = [try nationalityElement.text()]
        }

        // Geburtsdatum
        if let birthdateElement = try doc.select("td:contains(Geburtsdatum) + td").first() {
            let birthdateString = try birthdateElement.text()
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "dd.MM.yyyy" // Format auf Soccerdonna
            if let birthdate = dateFormatter.date(from: birthdateString) {
                playerData.geburtsdatum = birthdate
            }
        }

        // Aktueller Verein
        if let clubElement = try doc.select("td:contains(Verein) + td a").first() {
            playerData.vereinID = try clubElement.text()
        }

        // Vertragsende (falls verfügbar)
        if let contractElement = try doc.select("td:contains(Vertrag bis) + td").first() {
            let contractEndString = try contractElement.text()
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "dd.MM.yyyy"
            if let contractEnd = dateFormatter.date(from: contractEndString) {
                playerData.contractEnd = contractEnd
            }
        }

        return playerData
    }
}



//
//  TransfermarktService.swift

import Foundation
import SwiftSoup

class TransfermarktService {
    static let shared = TransfermarktService()

    private init() {}

    func fetchPlayerData(forPlayerID playerID: String) async throws -> PlayerData {
        let urlString = "https://www.transfermarkt.de/spieler-name/profil/spieler/\(playerID)"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }

        var request = URLRequest(url: url)
        request.setValue("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36", forHTTPHeaderField: "User-Agent")
        request.setValue("text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", forHTTPHeaderField: "Accept")
        request.setValue("en-US,en;q=0.5", forHTTPHeaderField: "Accept-Language")
        request.timeoutInterval = 10

        let (data, response) = try await URLSession.shared.data(for: request, delegate: nil)
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }

        let html = String(data: data, encoding: .utf8) ?? ""
        let doc: Document = try SwiftSoup.parse(html)

        var playerData = PlayerData()

        // Extract name
        if let nameElement = try doc.select(".data-header__name").first() {
            playerData.name = try nameElement.text()
        }

        // Extract position
        if let positionElement = try doc.select(".data-header__position").first() {
            playerData.position = try positionElement.text()
        }

        // Extract nationality
        if let nationalityElement = try doc.select(".data-header__nationality").first() {
            playerData.nationalitaet = [try nationalityElement.text()]
        }

        // Extract date of birth
        if let birthdateElement = try doc.select(".data-header__birthdate").first() {
            let birthdateString = try birthdateElement.text()
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "dd.MM.yyyy"
            if let birthdate = dateFormatter.date(from: birthdateString) {
                playerData.geburtsdatum = birthdate
            }
        }

        // Extract current club
        if let clubElement = try doc.select(".data-header__club").first() {
            playerData.vereinID = try clubElement.text()
        }

        // Extract contract end date
        if let contractElement = try doc.select(".data-contract__end").first() {
            let contractEndString = try contractElement.text()
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "dd.MM.yyyy"
            if let contractEnd = dateFormatter.date(from: contractEndString) {
                playerData.contractEnd = contractEnd
            }
        }

        return playerData
    }
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/13. Chat
//
//  ChatDetailView.swift

import SwiftUI
import FirebaseFirestore

struct ChatDetailView: View {
    let chat: Chat
    let onChatUpdated: () -> Void
    @EnvironmentObject var authManager: AuthManager
    @State private var messages: [ChatMessage] = []
    @State private var newMessage: String = ""
    @State private var errorMessage: String = ""
    @State private var partnerName: String = "Chat" // Standardtitel

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")
    private let textFieldBackgroundColor = Color(hex: "#4A5459") // Hellerer Hintergrund für besseren Kontrast

    var body: some View {
        VStack {
            ScrollView {
                VStack(spacing: 8) {
                    ForEach(messages) { message in
                        MessageRow(message: message)
                    }
                }
                .padding()
            }

            // Eingabefeld für neue Nachricht
            HStack {
                TextField("Nachricht eingeben...", text: $newMessage)
                    .textFieldStyle(PlainTextFieldStyle()) // Entferne den Standardstil für besseren Kontrast
                    .foregroundColor(.white) // Weiße Schrift für besseren Kontrast
                    .padding(10)
                    .background(textFieldBackgroundColor)
                    .clipShape(RoundedRectangle(cornerRadius: 8))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(Color.gray, lineWidth: 1)
                    )
                    .padding(.horizontal)

                Button(action: sendMessage) {
                    Image(systemName: "paperplane.fill")
                        .foregroundColor(newMessage.isEmpty ? secondaryTextColor : accentColor)
                        .font(.system(size: 20))
                }
                .disabled(newMessage.isEmpty)
                .padding(.trailing)
            }
            .padding(.vertical, 8)
            .background(cardBackgroundColor)
        }
        .navigationTitle(partnerName) // Setze den Titel auf den Namen des Chat-Partners
        .foregroundColor(textColor)
        .task {
            await loadPartnerName()
            await loadMessages()
        }
        .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
            Alert(
                title: Text("Fehler").foregroundColor(textColor),
                message: Text(errorMessage).foregroundColor(secondaryTextColor),
                dismissButton: .default(Text("OK").foregroundColor(accentColor))
            )
        }
    }

    private func MessageRow(message: ChatMessage) -> some View {
        let isCurrentUser = message.senderID == authManager.userID
        return HStack {
            if isCurrentUser { Spacer() }
            VStack(alignment: isCurrentUser ? .trailing : .leading, spacing: 4) {
                Text(message.content ?? "")
                    .foregroundColor(textColor)
                    .padding(10)
                    .background(isCurrentUser ? accentColor : cardBackgroundColor)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                Text(dateFormatter.string(from: message.timestamp))
                    .font(.caption)
                    .foregroundColor(secondaryTextColor)
            }
            if !isCurrentUser { Spacer() }
        }
        .padding(.horizontal)
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter
    }()

    private func loadPartnerName() async {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        // Finde die ID des Chat-Partners (nicht der aktuelle Benutzer)
        let partnerID = chat.participantIDs.first { $0 != userID } ?? "Unbekannt"
        
        // Suche den Namen in den Collections
        do {
            // Versuche, den Namen aus der "users"-Collection zu laden
            let userDoc = try await Firestore.firestore().collection("users").document(partnerID).getDocument()
            if userDoc.exists {
                let userData = userDoc.data()!
                if let vorname = userData["vorname"] as? String,
                   let name = userData["name"] as? String {
                    await MainActor.run {
                        partnerName = "\(vorname) \(name)"
                    }
                    return
                }
            }

            // Versuche, den Namen aus der "clients"-Collection zu laden
            let clientSnapshot = try await Firestore.firestore().collection("clients")
                .whereField("globalID", isEqualTo: partnerID)
                .getDocuments()
            if let clientDoc = clientSnapshot.documents.first {
                let clientData = clientDoc.data()
                if let vorname = clientData["vorname"] as? String,
                   let name = clientData["name"] as? String {
                    await MainActor.run {
                        partnerName = "\(vorname) \(name)"
                    }
                    return
                }
            }

            // Versuche, den Namen aus der "funktionare"-Collection zu laden
            let funktionarSnapshot = try await Firestore.firestore().collection("funktionare")
                .whereField("globalID", isEqualTo: partnerID)
                .getDocuments()
            if let funktionarDoc = funktionarSnapshot.documents.first {
                let funktionarData = funktionarDoc.data()
                if let vorname = funktionarData["vorname"] as? String,
                   let name = funktionarData["name"] as? String {
                    await MainActor.run {
                        partnerName = "\(vorname) \(name)"
                    }
                    return
                }
            }

            // Fallback, falls der Name nicht gefunden wird
            await MainActor.run {
                partnerName = "Unbekannt"
            }
        } catch {
            errorMessage = "Fehler beim Laden des Partnernamens: \(error.localizedDescription)"
        }
    }

    private func loadMessages() async {
        do {
            let loadedMessages = try await FirestoreManager.shared.getMessages(forChatID: chat.id ?? "")
            print("Loaded \(loadedMessages.count) messages for chat \(chat.id ?? "unknown")")
            await MainActor.run {
                messages = loadedMessages
            }
        } catch {
            errorMessage = "Fehler beim Laden der Nachrichten: \(error.localizedDescription)"
            print("Error loading messages: \(error)")
        }
    }

    private func sendMessage() {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        guard let userEmail = authManager.userEmail else {
            errorMessage = "Benutzer-E-Mail nicht verfügbar."
            return
        }
        guard let chatID = chat.id else {
            errorMessage = "Chat-ID nicht verfügbar."
            return
        }
        let message = ChatMessage(
            id: UUID().uuidString,
            senderID: userID,
            senderEmail: userEmail,
            content: newMessage,
            fileURL: nil,
            fileType: nil,
            timestamp: Date(),
            readBy: [userID]
        )
        Task {
            do {
                try await FirestoreManager.shared.sendMessage(message, inChatID: chatID)
                print("Message sent: \(message.content ?? "empty")")
                await loadMessages()
                await MainActor.run {
                    newMessage = ""
                    onChatUpdated() // Aktualisiere die Chat-Liste
                }
            } catch {
                errorMessage = "Fehler beim Senden der Nachricht: \(error.localizedDescription)"
                print("Error sending message: \(error)")
            }
        }
    }
}

#Preview {
    ChatDetailView(chat: Chat(
        id: "1",
        participantIDs: ["user1", "user2"],
        lastMessage: "Hallo!",
        lastMessageTimestamp: Date()
    ), onChatUpdated: {})
    .environmentObject(AuthManager())
}



//
//  ChatListView.swift

import SwiftUI
import FirebaseFirestore

struct ChatListView: View {
    @EnvironmentObject var authManager: AuthManager
    @Binding var showingNewChatSheet: Bool
    @Binding var selectedPartner: String?
    @Binding var potentialChatPartners: [(id: String, name: String)]
    @Binding var errorMessage: String
    @Binding var chats: [Chat]
    let onChatCreated: (Chat) -> Void

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        ZStack {
            backgroundColor.edgesIgnoringSafeArea(.all)

            if chats.isEmpty {
                Text("Keine Chats vorhanden.")
                    .foregroundColor(secondaryTextColor)
                    .font(.subheadline)
                    .padding(.top, 20)
            } else {
                List(chats) { chat in
                    NavigationLink(destination: ChatDetailView(chat: chat, onChatUpdated: {
                        Task {
                            await loadChats()
                        }
                    })) {
                        ChatRow(chat: chat)
                    }
                    .listRowBackground(cardBackgroundColor)
                }
                .scrollContentBackground(.hidden)
                .background(backgroundColor)
            }
        }
        .navigationTitle("Chats")
        .foregroundColor(textColor)
        .task {
            print("ChatListView - UserID: \(authManager.userID ?? "nil"), Role: \(authManager.userRole?.rawValue ?? "nil")")
            await loadChats()
        }
        .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
            Alert(
                title: Text("Fehler").foregroundColor(textColor),
                message: Text(errorMessage).foregroundColor(secondaryTextColor),
                dismissButton: .default(Text("OK").foregroundColor(accentColor))
            )
        }
    }

    private func ChatRow(chat: Chat) -> some View {
        HStack {
            Image(systemName: "message.fill")
                .foregroundColor(accentColor)
                .font(.system(size: 20))
            VStack(alignment: .leading, spacing: 4) {
                // Zeige die Namen der Teilnehmer an, außer dem aktuellen Benutzer
                Text(getChatPartnerName(chat: chat))
                    .font(.headline)
                    .foregroundColor(textColor)
                if let lastMessage = chat.lastMessage {
                    Text(lastMessage)
                        .font(.subheadline)
                        .foregroundColor(secondaryTextColor)
                        .lineLimit(1)
                }
            }
            Spacer()
            if let timestamp = chat.lastMessageTimestamp {
                Text(dateFormatter.string(from: timestamp))
                    .font(.caption)
                    .foregroundColor(secondaryTextColor)
            }
        }
        .padding(.vertical, 8)
    }

    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter
    }()

    private func getChatPartnerName(chat: Chat) -> String {
        guard let userID = authManager.userID else { return "Unbekannt" }
        // Finde die ID des Chat-Partners (nicht der aktuelle Benutzer)
        let partnerID = chat.participantIDs.first { $0 != userID } ?? "Unbekannt"
        // Suche den Namen in den potentialChatPartners
        if let partner = potentialChatPartners.first(where: { $0.id == partnerID }) {
            return partner.name
        }
        return partnerID // Fallback auf die ID, falls der Name nicht gefunden wird
    }

    private func loadChats() async {
        guard let userID = authManager.userID else {
            errorMessage = "Benutzer-ID nicht verfügbar."
            return
        }
        do {
            let loadedChats = try await FirestoreManager.shared.getChats(forUserID: userID)
            await MainActor.run {
                chats = loadedChats
                print("Loaded Chats in ChatListView: \(loadedChats.count)")
            }
        } catch {
            errorMessage = "Fehler beim Laden der Chats: \(error.localizedDescription)"
        }
    }
}

struct NewChatView: View {
    let potentialChatPartners: [(id: String, name: String)]
    @Binding var selectedPartner: String?
    let onCreate: (String) -> Void
    let onCancel: () -> Void

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)

                VStack(spacing: 16) {
                    Text("Neuen Chat starten")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(textColor)
                        .padding(.top, 16)

                    if potentialChatPartners.isEmpty {
                        Text("Keine Chat-Partner verfügbar.")
                            .foregroundColor(secondaryTextColor)
                            .font(.subheadline)
                    } else {
                        Picker("Chat-Partner", selection: $selectedPartner) {
                            Text("Partner auswählen").tag(String?.none)
                            ForEach(potentialChatPartners, id: \.id) { partner in
                                Text(partner.name).tag(partner.id as String?)
                            }
                        }
                        .pickerStyle(.menu)
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(cardBackgroundColor)
                        .foregroundColor(textColor)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                    }

                    Spacer()
                }
                .padding(.horizontal)
            }
            .navigationTitle("Neuer Chat")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: onCancel) {
                        Text("Abbrechen")
                            .foregroundColor(accentColor)
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        if let partner = selectedPartner {
                            onCreate(partner)
                        }
                    }) {
                        Text("Erstellen")
                            .foregroundColor(selectedPartner == nil ? secondaryTextColor : accentColor)
                    }
                    .disabled(selectedPartner == nil)
                }
            }
        }
    }
}

#Preview {
    ChatListView(
        showingNewChatSheet: .constant(false),
        selectedPartner: .constant(nil),
        potentialChatPartners: .constant([]),
        errorMessage: .constant(""),
        chats: .constant([]),
        onChatCreated: { _ in }
    )
    .environmentObject(AuthManager())
}



/Users/marioeggimann/Documents/Sports Transfer/Digital/App/SportsTransfer/SportsTransfer/14. Gamify
//
//  LeaderboardView.swift

import SwiftUI
import FirebaseFirestore

struct LeaderboardView: View {
    @State private var users: [User] = []
    @State private var errorMessage = ""

    // Farben für das dunkle Design
    private let backgroundColor = Color(hex: "#1C2526")
    private let cardBackgroundColor = Color(hex: "#2A3439")
    private let accentColor = Color(hex: "#00C4B4")
    private let textColor = Color(hex: "#E0E0E0")
    private let secondaryTextColor = Color(hex: "#B0BEC5")

    var body: some View {
        NavigationStack {
            ZStack {
                backgroundColor.edgesIgnoringSafeArea(.all)
                VStack {
                    if users.isEmpty {
                        Text("Keine Mitarbeiter vorhanden.")
                            .foregroundColor(secondaryTextColor)
                            .padding()
                    } else {
                        List {
                            ForEach(users.indices, id: \.self) { index in
                                let user = users[index]
                                HStack {
                                    Text("\(index + 1).")
                                        .font(.headline)
                                        .foregroundColor(index < 3 ? .yellow : textColor)
                                    Text(user.email)
                                        .foregroundColor(textColor)
                                    Spacer()
                                    Text("\(user.points ?? 0) Punkte")
                                        .foregroundColor(secondaryTextColor)
                                }
                                .padding()
                                .background(cardBackgroundColor)
                                .clipShape(RoundedRectangle(cornerRadius: 10))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 10)
                                        .stroke(accentColor, lineWidth: 1)
                                )
                            }
                        }
                        .scrollContentBackground(.hidden)
                        .background(backgroundColor)
                    }
                }
            }
            .navigationTitle("Rangliste")
            .foregroundColor(textColor)
            .task {
                await loadUsers()
            }
            .alert(isPresented: Binding(get: { !errorMessage.isEmpty }, set: { if !$0 { errorMessage = "" } })) {
                Alert(
                    title: Text("Fehler").foregroundColor(textColor),
                    message: Text(errorMessage).foregroundColor(secondaryTextColor),
                    dismissButton: .default(Text("OK").foregroundColor(accentColor))
                )
            }
        }
    }

    private func loadUsers() async {
        do {
            let snapshot = try await Firestore.firestore().collection("users")
                .whereField("rolle", isEqualTo: "Mitarbeiter")
                .getDocuments()
            let loadedUsers = snapshot.documents.compactMap { doc -> User? in
                var user = try? doc.data(as: User.self)
                user?.id = doc.documentID
                return user
            }
            await MainActor.run {
                users = loadedUsers.sorted { ($0.points ?? 0) > ($1.points ?? 0) }
            }
        } catch {
            errorMessage = "Fehler beim Laden der Rangliste: \(error.localizedDescription)"
        }
    }
}

#Preview {
    LeaderboardView()
}



